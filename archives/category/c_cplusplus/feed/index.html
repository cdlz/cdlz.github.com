<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Only For Sunshine~ &#187; C/C++</title>
	<atom:link href="http://imzc.net/archives/category/c_cplusplus/feed/" rel="self" type="application/rss+xml" />
	<link>http://imzc.net</link>
	<description>-More Thinking,And Then Just do it~~~</description>
	<lastBuildDate>Mon, 09 Jul 2012 03:09:37 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=3.4.1</generator>
		<item>
		<title>使用windows api实现屏幕截图并复制到剪贴板</title>
		<link>http://imzc.net/archives/253/</link>
		<comments>http://imzc.net/archives/253/#comments</comments>
		<pubDate>Mon, 23 Apr 2012 11:10:43 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[C/C++]]></category>
		<category><![CDATA[Ruby&Testing]]></category>

		<guid isPermaLink="false">http://imzc.net/?p=253</guid>
		<description><![CDATA[最新自动化项目需要使用屏幕截图功能,本来通过autoit发送printscreen键,然后从剪贴板copy出来 [...]]]></description>
			<content:encoded><![CDATA[<p>最新自动化项目需要使用屏幕截图功能,本来通过autoit发送printscreen键,然后从剪贴板copy出来即可.</p>

<div class="wp_syntax"><div class="code"><pre class="ruby" style="font-family:monospace;">    <span style="color:#CC0066; font-weight:bold;">require</span> <span style="color:#996600;">&quot;win32ole&quot;</span>
    t = WIN32OLE.<span style="color:#9900CC;">new</span><span style="color:#006600; font-weight:bold;">&#40;</span><span style="color:#996600;">&quot;AutoItX3.Control&quot;</span><span style="color:#006600; font-weight:bold;">&#41;</span>
    t.<span style="color:#9900CC;">Send</span><span style="color:#006600; font-weight:bold;">&#40;</span><span style="color:#996600;">&quot;{PRINTSCREEN}&quot;</span><span style="color:#006600; font-weight:bold;">&#41;</span>   
	<span style="color:#CC0066; font-weight:bold;">sleep</span> <span style="color:#006666;">1</span>
	picture=<span style="color:#6666ff; font-weight:bold;">Win32::Clipboard</span>.<span style="color:#9900CC;">data</span><span style="color:#006600; font-weight:bold;">&#40;</span><span style="color:#6666ff; font-weight:bold;">Win32::Clipboard::DIB</span><span style="color:#006600; font-weight:bold;">&#41;</span> 
	<span style="color:#6666ff; font-weight:bold;">ATT::KeyLog</span>.<span style="color:#9900CC;">info</span> <span style="color:#996600;">&quot;pictrue:#{picture.slice(0..10)}&quot;</span> 
	<span style="color:#CC00FF; font-weight:bold;">File</span>.<span style="color:#CC0066; font-weight:bold;">open</span><span style="color:#006600; font-weight:bold;">&#40;</span><span style="color:#996600;">&quot;xxx.bmp&quot;</span>,<span style="color:#996600;">&quot;wb&quot;</span><span style="color:#006600; font-weight:bold;">&#41;</span><span style="color:#9966CC; font-weight:bold;">do</span> <span style="color:#006600; font-weight:bold;">|</span>f<span style="color:#006600; font-weight:bold;">|</span>
    f.<span style="color:#9900CC;">write</span><span style="color:#006600; font-weight:bold;">&#40;</span>picture<span style="color:#006600; font-weight:bold;">&#41;</span>
	<span style="color:#9966CC; font-weight:bold;">end</span></pre></div></div>

<p>&nbsp;</p>
<p>但是此方法有一定风险,比如在远程桌面连入时,很容易和外部PC的剪贴板混乱.<br />
 因此有了使用原始API截图保存的需求.<br />
使用vs2005创建win32控制台程序,勾选ATL即可.注意工程选项,直接静态编译,使程序能适应各个PC.<br />
下面是源码:<br />
带参数时,保存到对应路径,同时复制到剪贴板.<br />
不带参数时,仅复制到剪贴板.</p>

<div class="wp_syntax"><div class="code"><pre class="cpp" style="font-family:monospace;"><span style="color: #000040;">&amp;</span>nbsp<span style="color: #008080;">;</span>
<span style="color: #666666;">// cap.cpp : 定义控制台应用程序的入口点。</span>
<span style="color: #666666;">//</span>
&nbsp;
<span style="color: #339900;">#include &quot;stdafx.h&quot;  </span>
&nbsp;
<span style="color: #339900;">#include &lt;windows.h&gt;  </span>
<span style="color: #339900;">#include &lt;atlimage.h&gt;  </span>
&nbsp;
&nbsp;
CString GetSuffix<span style="color: #008000;">&#40;</span>CString strFileName<span style="color: #008000;">&#41;</span> 
<span style="color: #008000;">&#123;</span> 
	<span style="color: #0000ff;">return</span> strFileName.<span style="color: #007788;">Right</span><span style="color: #008000;">&#40;</span>strFileName.<span style="color: #007788;">GetLength</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #000040;">-</span>strFileName.<span style="color: #007788;">ReverseFind</span><span style="color: #008000;">&#40;</span><span style="color: #FF0000;">'.'</span><span style="color: #008000;">&#41;</span><span style="color: #000040;">-</span><span style="color: #0000dd;">1</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span> 
<span style="color: #008000;">&#125;</span>
&nbsp;
&nbsp;
<span style="color: #0000ff;">int</span> _tmain<span style="color: #008000;">&#40;</span><span style="color: #0000ff;">int</span> argc, _TCHAR<span style="color: #000040;">*</span> argv<span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span><span style="color: #008000;">&#41;</span>
<span style="color: #008000;">&#123;</span>
&nbsp;
		wprintf<span style="color: #008000;">&#40;</span>_T<span style="color: #008000;">&#40;</span><span style="color: #FF0000;">&quot;Useage:<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\
</span>1.capture.exe  jpg_path (Save bmp and copy  to clipboard.)<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\
</span>2.capture.exe (Only copy bmp to your current clipboard.)<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\
</span>@zc,2012.4.21.&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
&nbsp;
&nbsp;
&nbsp;
		HWND hwnd <span style="color: #000080;">=</span> <span style="color: #008080;">::</span><span style="color: #007788;">GetDesktopWindow</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>  
		HDC hDC <span style="color: #000080;">=</span> <span style="color: #008080;">::</span><span style="color: #007788;">GetDC</span><span style="color: #008000;">&#40;</span>hwnd<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span> <span style="color: #666666;">//根据窗口来确定截图的大概位置</span>
&nbsp;
		RECT rect<span style="color: #008080;">;</span>  
		<span style="color: #008080;">::</span><span style="color: #007788;">GetClientRect</span><span style="color: #008000;">&#40;</span>hwnd, <span style="color: #000040;">&amp;</span>rect<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>  
		HDC hDCMem <span style="color: #000080;">=</span> <span style="color: #008080;">::</span><span style="color: #007788;">CreateCompatibleDC</span><span style="color: #008000;">&#40;</span>hDC<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>   
&nbsp;
		HBITMAP hBitMap <span style="color: #000080;">=</span> <span style="color: #008080;">::</span><span style="color: #007788;">CreateCompatibleBitmap</span><span style="color: #008000;">&#40;</span>hDC, rect.<span style="color: #007788;">right</span>, rect.<span style="color: #007788;">bottom</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>  
		HBITMAP hOldMap <span style="color: #000080;">=</span> <span style="color: #008000;">&#40;</span>HBITMAP<span style="color: #008000;">&#41;</span><span style="color: #008080;">::</span><span style="color: #007788;">SelectObject</span><span style="color: #008000;">&#40;</span>hDCMem, hBitMap<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>  
&nbsp;
		<span style="color: #008080;">::</span><span style="color: #007788;">BitBlt</span><span style="color: #008000;">&#40;</span>hDCMem, <span style="color: #0000dd;">0</span>, <span style="color: #0000dd;">0</span>, rect.<span style="color: #007788;">right</span>, rect.<span style="color: #007788;">bottom</span>, hDC, <span style="color: #0000dd;">0</span>, <span style="color: #0000dd;">0</span>, SRCCOPY<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span> <span style="color: #666666;">//红色部分确定图片的大小位置</span>
&nbsp;
		CImage image<span style="color: #008080;">;</span>  
		image.<span style="color: #007788;">Attach</span><span style="color: #008000;">&#40;</span>hBitMap<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>  
&nbsp;
		<span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span>argc<span style="color: #000080;">==</span><span style="color: #0000dd;">2</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#123;</span>
			GUID imageFormat <span style="color: #000080;">=</span> Gdiplus<span style="color: #008080;">::</span><span style="color: #007788;">ImageFormatBMP</span><span style="color: #008080;">;</span>
			CString suffix <span style="color: #000080;">=</span> GetSuffix<span style="color: #008000;">&#40;</span>argv<span style="color: #008000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #008000;">&#93;</span><span style="color: #008000;">&#41;</span>.<span style="color: #007788;">MakeLower</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
			<span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span>suffix.<span style="color: #007788;">Compare</span><span style="color: #008000;">&#40;</span>_T<span style="color: #008000;">&#40;</span><span style="color: #FF0000;">&quot;jpg&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #000080;">==</span><span style="color: #0000dd;">0</span><span style="color: #008000;">&#41;</span>
			<span style="color: #008000;">&#123;</span>
				imageFormat<span style="color: #000080;">=</span> Gdiplus<span style="color: #008080;">::</span><span style="color: #007788;">ImageFormatJPEG</span><span style="color: #008080;">;</span> 
				wprintf<span style="color: #008000;">&#40;</span>_T<span style="color: #008000;">&#40;</span><span style="color: #FF0000;">&quot;img type:jpg&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span> 
			<span style="color: #008000;">&#125;</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span>suffix.<span style="color: #007788;">Compare</span><span style="color: #008000;">&#40;</span>_T<span style="color: #008000;">&#40;</span><span style="color: #FF0000;">&quot;png&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #000080;">==</span><span style="color: #0000dd;">0</span><span style="color: #008000;">&#41;</span>
			<span style="color: #008000;">&#123;</span>
				imageFormat<span style="color: #000080;">=</span> Gdiplus<span style="color: #008080;">::</span><span style="color: #007788;">ImageFormatPNG</span><span style="color: #008080;">;</span>
				wprintf<span style="color: #008000;">&#40;</span>_T<span style="color: #008000;">&#40;</span><span style="color: #FF0000;">&quot;img type:png&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span> 
			<span style="color: #008000;">&#125;</span><span style="color: #0000ff;">else</span>  
			<span style="color: #008000;">&#123;</span>
				imageFormat<span style="color: #000080;">=</span> Gdiplus<span style="color: #008080;">::</span><span style="color: #007788;">ImageFormatBMP</span><span style="color: #008080;">;</span>
				wprintf<span style="color: #008000;">&#40;</span>_T<span style="color: #008000;">&#40;</span><span style="color: #FF0000;">&quot;img type:bmp&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span> 
			<span style="color: #008000;">&#125;</span>
&nbsp;
			image.<span style="color: #007788;">Save</span><span style="color: #008000;">&#40;</span>argv<span style="color: #008000;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #008000;">&#93;</span>,imageFormat<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>  
		<span style="color: #008000;">&#125;</span>
&nbsp;
		<span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span>OpenClipboard<span style="color: #008000;">&#40;</span><span style="color: #0000ff;">NULL</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span> 
		<span style="color: #008000;">&#123;</span> 
			EmptyClipboard<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span> 
			SetClipboardData<span style="color: #008000;">&#40;</span>CF_BITMAP, image<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span> 
			CloseClipboard<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span> 
		<span style="color: #008000;">&#125;</span> 
		<span style="color: #666666;">//::PostMessage(hwnd, WM_KEYDOWN,44 , 0L); //发送 VK_PRINTSCREEN按下的键盘消息   </span>
&nbsp;
		image.<span style="color: #007788;">Detach</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>   
		<span style="color: #008080;">::</span><span style="color: #007788;">SelectObject</span><span style="color: #008000;">&#40;</span>hDCMem, hOldMap<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>  
		<span style="color: #008080;">::</span><span style="color: #007788;">DeleteObject</span><span style="color: #008000;">&#40;</span>hBitMap<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>  
		<span style="color: #008080;">::</span><span style="color: #007788;">DeleteDC</span><span style="color: #008000;">&#40;</span>hDCMem<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>  
		<span style="color: #008080;">::</span><span style="color: #007788;">DeleteDC</span><span style="color: #008000;">&#40;</span>hDC<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>  
&nbsp;
	<span style="color: #0000ff;">return</span> <span style="color: #0000dd;">0</span><span style="color: #008080;">;</span>
<span style="color: #008000;">&#125;</span></pre></div></div>

<p>&nbsp;<br />
附件下载:<a href='http://imzc.net/wp-content/uploads/2012/04/cap_src_vs2005.rar'>cap_src_vs2005</a></p>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/253/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>解析pcap文件及读取实现源码</title>
		<link>http://imzc.net/archives/181/</link>
		<comments>http://imzc.net/archives/181/#comments</comments>
		<pubDate>Tue, 24 Jan 2012 16:55:40 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[C/C++]]></category>
		<category><![CDATA[pcap]]></category>

		<guid isPermaLink="false">http://imzc.net/?p=181</guid>
		<description><![CDATA[下面pcap文件格式介绍是在网上转的,根据理解，写了个程序来进行解析pcap文件，后续再实现合并pcap功能( [...]]]></description>
			<content:encoded><![CDATA[<p>下面pcap文件格式介绍是在<a href="http://blog.csdn.net/in7deforever/article/details/6460595" target="_blank">网上转的</a>,根据理解，写了个程序来进行解析pcap文件，后续再实现合并pcap功能(wireshark已经自带命令行合并pcap文件工具，在这里只是为了分析pcap文件和学习)。<br />
==========================<br />
默认的*.pcap文件保存格式。</p>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/ALEKS86/1%29%20Pcap%E6%96%87%E4%BB%B6%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E5%92%8CPcap%E6%96%87%E4%BB%B6%E5%A4%B4%E7%BB%93%E6%9E%84.gif" alt="" align="textTop" data-ke-src="http://p.blog.csdn.net/images/p_blog_csdn_net/ALEKS86/1%29%20Pcap%E6%96%87%E4%BB%B6%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E5%92%8CPcap%E6%96%87%E4%BB%B6%E5%A4%B4%E7%BB%93%E6%9E%84.gif" /></p>
<p>Pcap文件头24B各字段说明：</p>
<div>Magic：4B：0x1A 2B 3C 4D:用来标示文件的开始</div>
<div>Major：2B，0&#215;02 00:当前文件主要的版本号</div>
<div>Minor：2B，0&#215;04 00当前文件次要的版本号</div>
<div>ThisZone：4B当地的标准时间；全零</div>
<div>SigFigs：4B时间戳的精度；全零</div>
<div>SnapLen：4B最大的存储长度</div>
<div>LinkType：4B链路类型</div>
<div>常用类型：</div>
<div>0            BSD loopback devices, except for later OpenBSD<br />
1            Ethernet, and Linux loopback devices<br />
6            802.5 Token Ring<br />
7            ARCnet<br />
8            SLIP<br />
9            PPP<br />
10           FDDI<br />
100         LLC/SNAP-encapsulated ATM<br />
101         &#8220;raw IP&#8221;, with no link<br />
102         BSD/OS SLIP<br />
103         BSD/OS PPP<br />
104         Cisco HDLC<br />
105         802.11<br />
108         later OpenBSD loopback devices (with the AF_value in network byte order)<br />
113         special Linux &#8220;cooked&#8221; capture<br />
114         LocalTalk</div>
<div></div>
<div><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/ALEKS86/2%EF%BC%89Packet%20%E5%8C%85%E5%A4%B4%EF%BC%8816B%EF%BC%89%E5%92%8CPacket%E6%95%B0%E6%8D%AE%E7%BB%84%E6%88%90.gif" alt="" align="textTop" data-ke-src="http://p.blog.csdn.net/images/p_blog_csdn_net/ALEKS86/2%EF%BC%89Packet%20%E5%8C%85%E5%A4%B4%EF%BC%8816B%EF%BC%89%E5%92%8CPacket%E6%95%B0%E6%8D%AE%E7%BB%84%E6%88%90.gif" /></div>
<div><strong>Packet </strong><strong>包头和Packet</strong><strong>数据组成</strong></div>
<div>字段说明：</div>
<div>Timestamp：时间戳高位，精确到seconds</div>
<div>Timestamp：时间戳低位，精确到microseconds</div>
<div>Caplen：当前数据区的长度，即抓取到的数据帧长度，由此可以得到下一个数据帧的位置。</div>
<div>Len：离线数据长度<strong>：</strong>网络中实际数据帧的长度，一般不大于caplen，多数情况下和Caplen数值相等。</div>
<div><strong>Packet </strong><strong>数据</strong>： 即 Packet（通常就是链路层的数据帧）具体内容，长度就是Caplen，这个长度的后面，就是当前PCAP文件中存放的下一个Packet数据包，也就 是说：PCAP文件里面并没有规定捕获的Packet数据包之间有什么间隔字符串，下一组数据在文件中的起始位置。我们需要靠第一个Packet包确定。 最后，Packet数据部分的格式其实就是标准的网路协议格式了可以任何网络教材上找得到。</div>
<div>===========================</div>
<div>我的实现：</div>
<div>

<div class="wp_syntax"><table><tr><td class="line_numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre></td><td class="code"><pre class="c" style="font-family:monospace;"><span style="color: #666666; font-style: italic;">//</span>
<span style="color: #666666; font-style: italic;">//  pcap.h</span>
<span style="color: #666666; font-style: italic;">//  pcaptest</span>
<span style="color: #666666; font-style: italic;">//</span>
<span style="color: #666666; font-style: italic;">//  Created by zc on 12-1-24.</span>
<span style="color: #666666; font-style: italic;">//  Copyright 2012年 __MyCompanyName__. All rights reserved.</span>
<span style="color: #666666; font-style: italic;">//</span>
&nbsp;
<span style="color: #339933;">#ifndef pcaptest_pcap_h</span>
<span style="color: #339933;">#define pcaptest_pcap_h</span>
&nbsp;
<span style="color: #993333;">typedef</span> <span style="color: #993333;">unsigned</span> <span style="color: #993333;">int</span>  bpf_u_int32<span style="color: #339933;">;</span>
<span style="color: #993333;">typedef</span> <span style="color: #993333;">unsigned</span> <span style="color: #993333;">short</span>  u_short<span style="color: #339933;">;</span>
<span style="color: #993333;">typedef</span> <span style="color: #993333;">int</span> bpf_int32<span style="color: #339933;">;</span>
&nbsp;
<span style="color: #808080; font-style: italic;">/*
 Pcap文件头24B各字段说明：
 Magic：4B：0x1A 2B 3C 4D:用来标示文件的开始
 Major：2B，0x02 00:当前文件主要的版本号     
 Minor：2B，0x04 00当前文件次要的版本号
 ThisZone：4B当地的标准时间；全零
 SigFigs：4B时间戳的精度；全零
 SnapLen：4B最大的存储长度    
 LinkType：4B链路类型
 常用类型：
 　0            BSD loopback devices, except for later OpenBSD
 1            Ethernet, and Linux loopback devices
 6            802.5 Token Ring
 7            ARCnet
 8            SLIP
 9            PPP
 */</span>
<span style="color: #993333;">typedef</span> <span style="color: #993333;">struct</span> pcap_file_header <span style="color: #009900;">&#123;</span>
	bpf_u_int32 magic<span style="color: #339933;">;</span>
	u_short version_major<span style="color: #339933;">;</span>
	u_short version_minor<span style="color: #339933;">;</span>
	bpf_int32 thiszone<span style="color: #339933;">;</span>    
	bpf_u_int32 sigfigs<span style="color: #339933;">;</span>   
	bpf_u_int32 snaplen<span style="color: #339933;">;</span>   
	bpf_u_int32 linktype<span style="color: #339933;">;</span>  
<span style="color: #009900;">&#125;</span>pcap_file_header<span style="color: #339933;">;</span>
&nbsp;
<span style="color: #808080; font-style: italic;">/*
 Packet 包头和Packet数据组成
 字段说明：
 Timestamp：时间戳高位，精确到seconds     
 Timestamp：时间戳低位，精确到microseconds
 Caplen：当前数据区的长度，即抓取到的数据帧长度，由此可以得到下一个数据帧的位置。
 Len：离线数据长度：网络中实际数据帧的长度，一般不大于caplen，多数情况下和Caplen数值相等。
 Packet 数据：即 Packet（通常就是链路层的数据帧）具体内容，长度就是Caplen，这个长度的后面，就是当前PCAP文件中存放的下一个Packet数据包，也就 是说：PCAP文件里面并没有规定捕获的Packet数据包之间有什么间隔字符串，下一组数据在文件中的起始位置。我们需要靠第一个Packet包确定。
 */</span>
&nbsp;
<span style="color: #993333;">typedef</span> <span style="color: #993333;">struct</span>  timestamp<span style="color: #009900;">&#123;</span>
	bpf_u_int32 timestamp_s<span style="color: #339933;">;</span>
	bpf_u_int32 timestamp_ms<span style="color: #339933;">;</span>
<span style="color: #009900;">&#125;</span>timestamp<span style="color: #339933;">;</span>
&nbsp;
<span style="color: #993333;">typedef</span> <span style="color: #993333;">struct</span> pcap_header<span style="color: #009900;">&#123;</span>
	timestamp ts<span style="color: #339933;">;</span>
	bpf_u_int32 capture_len<span style="color: #339933;">;</span>
	bpf_u_int32 len<span style="color: #339933;">;</span>
&nbsp;
<span style="color: #009900;">&#125;</span>pcap_header<span style="color: #339933;">;</span>
&nbsp;
&nbsp;
<span style="color: #993333;">void</span> prinfPcapFileHeader<span style="color: #009900;">&#40;</span>pcap_file_header <span style="color: #339933;">*</span>pfh<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
<span style="color: #993333;">void</span> printfPcapHeader<span style="color: #009900;">&#40;</span>pcap_header <span style="color: #339933;">*</span>ph<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
<span style="color: #993333;">void</span> printPcap<span style="color: #009900;">&#40;</span><span style="color: #993333;">void</span> <span style="color: #339933;">*</span> data<span style="color: #339933;">,</span>size_t size<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&nbsp;
<span style="color: #339933;">#endif</span></pre></td></tr></table></div>


<div class="wp_syntax"><table><tr><td class="line_numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
</pre></td><td class="code"><pre class="c" style="font-family:monospace;"><span style="color: #666666; font-style: italic;">//</span>
<span style="color: #666666; font-style: italic;">//  pcap.c</span>
<span style="color: #666666; font-style: italic;">//  pcaptest</span>
<span style="color: #666666; font-style: italic;">//</span>
<span style="color: #666666; font-style: italic;">//  Created by zc on 12-1-24.</span>
<span style="color: #666666; font-style: italic;">//  Copyright 2012年 __MyCompanyName__. All rights reserved.</span>
<span style="color: #666666; font-style: italic;">//</span>
&nbsp;
<span style="color: #339933;">#include &lt;stdio.h&gt;</span>
<span style="color: #339933;">#include &quot;pcap.h&quot;</span>
&nbsp;
<span style="color: #993333;">void</span> prinfPcapFileHeader<span style="color: #009900;">&#40;</span>pcap_file_header <span style="color: #339933;">*</span>pfh<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>
	<span style="color: #b1b100;">if</span> <span style="color: #009900;">&#40;</span>pfh<span style="color: #339933;">==</span>NULL<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
		<span style="color: #b1b100;">return</span><span style="color: #339933;">;</span>
	<span style="color: #009900;">&#125;</span>
	<span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;=====================<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span>
		   <span style="color: #ff0000;">&quot;magic:0x%0x<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span>
		   <span style="color: #ff0000;">&quot;version_major:%u<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span>
		   <span style="color: #ff0000;">&quot;version_minor:%u<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span>
		   <span style="color: #ff0000;">&quot;thiszone:%d<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span>
		   <span style="color: #ff0000;">&quot;sigfigs:%u<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span>
		   <span style="color: #ff0000;">&quot;snaplen:%u<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span>
		   <span style="color: #ff0000;">&quot;linktype:%u<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span>
		   <span style="color: #ff0000;">&quot;=====================<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #339933;">,</span>
		   pfh<span style="color: #339933;">-&gt;</span>magic<span style="color: #339933;">,</span>
		   pfh<span style="color: #339933;">-&gt;</span>version_major<span style="color: #339933;">,</span>
		   pfh<span style="color: #339933;">-&gt;</span>version_minor<span style="color: #339933;">,</span>
		   pfh<span style="color: #339933;">-&gt;</span>thiszone<span style="color: #339933;">,</span>
		   pfh<span style="color: #339933;">-&gt;</span>sigfigs<span style="color: #339933;">,</span>
		   pfh<span style="color: #339933;">-&gt;</span>snaplen<span style="color: #339933;">,</span>
		   pfh<span style="color: #339933;">-&gt;</span>linktype<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
<span style="color: #009900;">&#125;</span>
&nbsp;
<span style="color: #993333;">void</span> printfPcapHeader<span style="color: #009900;">&#40;</span>pcap_header <span style="color: #339933;">*</span>ph<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>
	<span style="color: #b1b100;">if</span> <span style="color: #009900;">&#40;</span>ph<span style="color: #339933;">==</span>NULL<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
		<span style="color: #b1b100;">return</span><span style="color: #339933;">;</span>
	<span style="color: #009900;">&#125;</span>
	<span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;=====================<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span>
		   <span style="color: #ff0000;">&quot;ts.timestamp_s:%u<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span>
		   <span style="color: #ff0000;">&quot;ts.timestamp_ms:%u<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span>
		   <span style="color: #ff0000;">&quot;capture_len:%u<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span>
		   <span style="color: #ff0000;">&quot;len:%d<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span>
		   <span style="color: #ff0000;">&quot;=====================<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #339933;">,</span>
		   ph<span style="color: #339933;">-&gt;</span>ts.<span style="color: #202020;">timestamp_s</span><span style="color: #339933;">,</span>
		   ph<span style="color: #339933;">-&gt;</span>ts.<span style="color: #202020;">timestamp_ms</span><span style="color: #339933;">,</span>
		   ph<span style="color: #339933;">-&gt;</span>capture_len<span style="color: #339933;">,</span>
		   ph<span style="color: #339933;">-&gt;</span>len<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&nbsp;
&nbsp;
<span style="color: #009900;">&#125;</span>
&nbsp;
<span style="color: #993333;">void</span> printPcap<span style="color: #009900;">&#40;</span><span style="color: #993333;">void</span> <span style="color: #339933;">*</span> data<span style="color: #339933;">,</span>size_t size<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>
	<span style="color: #993333;">unsigned</span>  <span style="color: #993333;">short</span> iPos <span style="color: #339933;">=</span> <span style="color: #0000dd;">0</span><span style="color: #339933;">;</span>
	<span style="color: #666666; font-style: italic;">//int * p = (int *)data;</span>
	<span style="color: #666666; font-style: italic;">//unsigned short* p = (unsigned short *)data;</span>
	<span style="color: #b1b100;">if</span> <span style="color: #009900;">&#40;</span>data<span style="color: #339933;">==</span>NULL<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
		<span style="color: #b1b100;">return</span><span style="color: #339933;">;</span>
	<span style="color: #009900;">&#125;</span>
&nbsp;
	<span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;<span style="color: #000099; font-weight: bold;">\n</span>==data:0x%x,len:%lu=========&quot;</span><span style="color: #339933;">,</span>data<span style="color: #339933;">,</span>size<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&nbsp;
	<span style="color: #b1b100;">for</span> <span style="color: #009900;">&#40;</span>iPos<span style="color: #339933;">=</span><span style="color: #0000dd;">0</span><span style="color: #339933;">;</span> iPos <span style="color: #339933;">&lt;</span> size<span style="color: #339933;">/</span><span style="color: #993333;">sizeof</span><span style="color: #009900;">&#40;</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">short</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> iPos<span style="color: #339933;">++</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
		<span style="color: #666666; font-style: italic;">//printf(&quot; %x &quot;,(int)( * (p+iPos) ));</span>
		<span style="color: #666666; font-style: italic;">//unsigned short a = ntohs(p[iPos]);</span>
&nbsp;
		<span style="color: #993333;">unsigned</span> <span style="color: #993333;">short</span> a <span style="color: #339933;">=</span> ntohs<span style="color: #009900;">&#40;</span> <span style="color: #339933;">*</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#40;</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">short</span> <span style="color: #339933;">*</span><span style="color: #009900;">&#41;</span>data <span style="color: #339933;">+</span> iPos <span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
		<span style="color: #b1b100;">if</span> <span style="color: #009900;">&#40;</span>iPos<span style="color: #339933;">%</span><span style="color:#800080;">8</span><span style="color: #339933;">==</span><span style="color: #0000dd;">0</span><span style="color: #009900;">&#41;</span> <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
		<span style="color: #b1b100;">if</span> <span style="color: #009900;">&#40;</span>iPos<span style="color: #339933;">%</span><span style="color:#800080;">4</span><span style="color: #339933;">==</span><span style="color: #0000dd;">0</span><span style="color: #009900;">&#41;</span> <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot; &quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&nbsp;
		<span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;%04x&quot;</span><span style="color: #339933;">,</span>a<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&nbsp;
&nbsp;
	<span style="color: #009900;">&#125;</span>
	<span style="color: #808080; font-style: italic;">/*
	 for (iPos=0; iPos &lt;= size/sizeof(int); iPos++) {
		//printf(&quot; %x &quot;,(int)( * (p+iPos) ));
		int a = ntohl(p[iPos]);
&nbsp;
		//int a = ntohl( *((int *)data + iPos ) );
		if (iPos %4==0) printf(&quot;\n&quot;);
&nbsp;
		printf(&quot;%08x &quot;,a);
&nbsp;
&nbsp;
	}
	 */</span>
	<span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;<span style="color: #000099; font-weight: bold;">\n</span>============<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
<span style="color: #009900;">&#125;</span></pre></td></tr></table></div>


<div class="wp_syntax"><table><tr><td class="line_numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
</pre></td><td class="code"><pre class="c" style="font-family:monospace;"><span style="color: #666666; font-style: italic;">//</span>
<span style="color: #666666; font-style: italic;">//  main.c</span>
<span style="color: #666666; font-style: italic;">//  pcaptest</span>
<span style="color: #666666; font-style: italic;">//</span>
<span style="color: #666666; font-style: italic;">//  Created by zc on 12-1-24.</span>
<span style="color: #666666; font-style: italic;">//  Copyright 2012年 __MyCompanyName__. All rights reserved.</span>
<span style="color: #666666; font-style: italic;">//</span>
&nbsp;
<span style="color: #339933;">#include &lt;stdio.h&gt;</span>
<span style="color: #339933;">#include &lt;arpa/inet.h&gt;</span>
<span style="color: #339933;">#include &quot;pcap.h&quot;</span>
&nbsp;
<span style="color: #339933;">#define PCAP_FILE &quot;ping.pcap&quot;</span>
<span style="color: #339933;">#define MAX_ETH_FRAME 1514</span>
<span style="color: #339933;">#define ERROR_FILE_OPEN_FAILED -1</span>
<span style="color: #339933;">#define ERROR_MEM_ALLOC_FAILED -2</span>
<span style="color: #339933;">#define ERROR_PCAP_PARSE_FAILED -3</span>
&nbsp;
&nbsp;
<span style="color: #993333;">int</span> main <span style="color: #009900;">&#40;</span><span style="color: #993333;">int</span> argc<span style="color: #339933;">,</span> <span style="color: #993333;">const</span> <span style="color: #993333;">char</span> <span style="color: #339933;">*</span> argv<span style="color: #009900;">&#91;</span><span style="color: #009900;">&#93;</span><span style="color: #009900;">&#41;</span>
<span style="color: #009900;">&#123;</span>
&nbsp;
	<span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;sizeof:int %lu,unsigned int %lu,char %lu,unsigned char %lu,short:%lu,unsigned short:%lu<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #339933;">,</span>
		    <span style="color: #993333;">sizeof</span><span style="color: #009900;">&#40;</span><span style="color: #993333;">int</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">,</span><span style="color: #993333;">sizeof</span><span style="color: #009900;">&#40;</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">int</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">,</span><span style="color: #993333;">sizeof</span><span style="color: #009900;">&#40;</span><span style="color: #993333;">char</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">,</span><span style="color: #993333;">sizeof</span><span style="color: #009900;">&#40;</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">,</span><span style="color: #993333;">sizeof</span><span style="color: #009900;">&#40;</span><span style="color: #993333;">short</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">,</span><span style="color: #993333;">sizeof</span><span style="color: #009900;">&#40;</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">short</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&nbsp;
	pcap_file_header  pfh<span style="color: #339933;">;</span>
	pcap_header  ph<span style="color: #339933;">;</span>
	<span style="color: #993333;">int</span> count<span style="color: #339933;">=</span><span style="color: #0000dd;">0</span><span style="color: #339933;">;</span>
	<span style="color: #993333;">void</span> <span style="color: #339933;">*</span> buff <span style="color: #339933;">=</span> NULL<span style="color: #339933;">;</span>
	<span style="color: #993333;">int</span> readSize<span style="color: #339933;">=</span><span style="color: #0000dd;">0</span><span style="color: #339933;">;</span>
	<span style="color: #993333;">int</span> ret <span style="color: #339933;">=</span> <span style="color: #0000dd;">0</span><span style="color: #339933;">;</span>
&nbsp;
	FILE <span style="color: #339933;">*</span>fp <span style="color: #339933;">=</span> fopen<span style="color: #009900;">&#40;</span>PCAP_FILE<span style="color: #339933;">,</span> <span style="color: #ff0000;">&quot;rw&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&nbsp;
	<span style="color: #b1b100;">if</span> <span style="color: #009900;">&#40;</span>fp<span style="color: #339933;">==</span>NULL<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
		fprintf<span style="color: #009900;">&#40;</span>stderr<span style="color: #339933;">,</span> <span style="color: #ff0000;">&quot;Open file %s error.&quot;</span><span style="color: #339933;">,</span>PCAP_FILE<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
		ret <span style="color: #339933;">=</span> ERROR_FILE_OPEN_FAILED<span style="color: #339933;">;</span>
		<span style="color: #b1b100;">goto</span> ERROR<span style="color: #339933;">;</span>
	<span style="color: #009900;">&#125;</span>
&nbsp;
	fread<span style="color: #009900;">&#40;</span><span style="color: #339933;">&amp;</span>pfh<span style="color: #339933;">,</span> <span style="color: #993333;">sizeof</span><span style="color: #009900;">&#40;</span>pcap_file_header<span style="color: #009900;">&#41;</span><span style="color: #339933;">,</span> <span style="color: #0000dd;">1</span><span style="color: #339933;">,</span> fp<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>	
	prinfPcapFileHeader<span style="color: #009900;">&#40;</span><span style="color: #339933;">&amp;</span>pfh<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
	<span style="color: #666666; font-style: italic;">//fseek(fp, 0, sizeof(pcap_file_header));</span>
&nbsp;
	buff <span style="color: #339933;">=</span> <span style="color: #009900;">&#40;</span><span style="color: #993333;">void</span> <span style="color: #339933;">*</span><span style="color: #009900;">&#41;</span>malloc<span style="color: #009900;">&#40;</span>MAX_ETH_FRAME<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
	<span style="color: #b1b100;">for</span> <span style="color: #009900;">&#40;</span>count<span style="color: #339933;">=</span><span style="color: #0000dd;">1</span><span style="color: #339933;">;</span> <span style="color: #339933;">;</span> count<span style="color: #339933;">++</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
		memset<span style="color: #009900;">&#40;</span>buff<span style="color: #339933;">,</span><span style="color: #0000dd;">0</span><span style="color: #339933;">,</span>MAX_ETH_FRAME<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
		<span style="color: #666666; font-style: italic;">//read pcap header to get a packet</span>
		<span style="color: #666666; font-style: italic;">//get only a pcap head count .</span>
		readSize<span style="color: #339933;">=</span>fread<span style="color: #009900;">&#40;</span><span style="color: #339933;">&amp;</span>ph<span style="color: #339933;">,</span> <span style="color: #993333;">sizeof</span><span style="color: #009900;">&#40;</span>pcap_header<span style="color: #009900;">&#41;</span><span style="color: #339933;">,</span> <span style="color: #0000dd;">1</span><span style="color: #339933;">,</span> fp<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
		<span style="color: #b1b100;">if</span> <span style="color: #009900;">&#40;</span>readSize<span style="color: #339933;">&lt;=</span><span style="color: #0000dd;">0</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
			<span style="color: #000000; font-weight: bold;">break</span><span style="color: #339933;">;</span>
		<span style="color: #009900;">&#125;</span>
		printfPcapHeader<span style="color: #009900;">&#40;</span><span style="color: #339933;">&amp;</span>ph<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&nbsp;
&nbsp;
		<span style="color: #b1b100;">if</span> <span style="color: #009900;">&#40;</span>buff<span style="color: #339933;">==</span>NULL<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
			fprintf<span style="color: #009900;">&#40;</span>stderr<span style="color: #339933;">,</span> <span style="color: #ff0000;">&quot;malloc memory failed.<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
			ret <span style="color: #339933;">=</span> ERROR_MEM_ALLOC_FAILED<span style="color: #339933;">;</span>
			<span style="color: #b1b100;">goto</span> ERROR<span style="color: #339933;">;</span>
		<span style="color: #009900;">&#125;</span>
&nbsp;
		<span style="color: #666666; font-style: italic;">//get a packet contents.</span>
		<span style="color: #666666; font-style: italic;">//read ph.capture_len bytes.</span>
		readSize<span style="color: #339933;">=</span>fread<span style="color: #009900;">&#40;</span>buff<span style="color: #339933;">,</span><span style="color: #0000dd;">1</span><span style="color: #339933;">,</span>ph.<span style="color: #202020;">capture_len</span><span style="color: #339933;">,</span> fp<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
		<span style="color: #b1b100;">if</span> <span style="color: #009900;">&#40;</span>readSize <span style="color: #339933;">!=</span> ph.<span style="color: #202020;">capture_len</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
			free<span style="color: #009900;">&#40;</span>buff<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
			fprintf<span style="color: #009900;">&#40;</span>stderr<span style="color: #339933;">,</span> <span style="color: #ff0000;">&quot;pcap file parse error.<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
			ret <span style="color: #339933;">=</span> ERROR_PCAP_PARSE_FAILED<span style="color: #339933;">;</span>
			<span style="color: #b1b100;">goto</span> ERROR<span style="color: #339933;">;</span>
		<span style="color: #009900;">&#125;</span>
		printPcap<span style="color: #009900;">&#40;</span>buff<span style="color: #339933;">,</span> ph.<span style="color: #202020;">capture_len</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&nbsp;
&nbsp;
		<span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;===count:%d,readSize:%d===<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #339933;">,</span>count<span style="color: #339933;">,</span>readSize<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&nbsp;
		<span style="color: #b1b100;">if</span> <span style="color: #009900;">&#40;</span>feof<span style="color: #009900;">&#40;</span>fp<span style="color: #009900;">&#41;</span> <span style="color: #339933;">||</span> readSize <span style="color: #339933;">&lt;=</span><span style="color: #0000dd;">0</span> <span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span> 
			<span style="color: #000000; font-weight: bold;">break</span><span style="color: #339933;">;</span>
		<span style="color: #009900;">&#125;</span>
	<span style="color: #009900;">&#125;</span>
&nbsp;
ERROR<span style="color: #339933;">:</span>
	<span style="color: #666666; font-style: italic;">//free</span>
	<span style="color: #b1b100;">if</span> <span style="color: #009900;">&#40;</span>buff<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
		free<span style="color: #009900;">&#40;</span>buff<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
		buff<span style="color: #339933;">=</span>NULL<span style="color: #339933;">;</span>
	<span style="color: #009900;">&#125;</span> 
	<span style="color: #b1b100;">if</span> <span style="color: #009900;">&#40;</span>fp<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
		fclose<span style="color: #009900;">&#40;</span>fp<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
		fp<span style="color: #339933;">=</span>NULL<span style="color: #339933;">;</span>
	<span style="color: #009900;">&#125;</span>	
&nbsp;
    <span style="color: #b1b100;">return</span> ret<span style="color: #339933;">;</span>
<span style="color: #009900;">&#125;</span></pre></td></tr></table></div>

<p>Makefile:</p>

<div class="wp_syntax"><table><tr><td class="line_numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre class="c" style="font-family:monospace;">objects <span style="color: #339933;">=</span> main.<span style="color: #202020;">o</span> pcap.<span style="color: #202020;">o</span>
&nbsp;
pcaptest <span style="color: #339933;">:</span> $<span style="color: #009900;">&#40;</span>objects<span style="color: #009900;">&#41;</span>
	gcc <span style="color: #339933;">-</span>o pcaptest  $<span style="color: #009900;">&#40;</span>objects<span style="color: #009900;">&#41;</span>
&nbsp;
main.<span style="color: #202020;">o</span><span style="color: #339933;">:</span>pcap.<span style="color: #202020;">h</span>
pcap.<span style="color: #202020;">o</span><span style="color: #339933;">:</span>pcap.<span style="color: #202020;">h</span>
&nbsp;
.<span style="color: #202020;">PHONY</span> <span style="color: #339933;">:</span> clean
clean <span style="color: #339933;">:</span>
	rm pcaptest  $<span style="color: #009900;">&#40;</span>objects<span style="color: #009900;">&#41;</span></pre></td></tr></table></div>

</div>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/181/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>Windows获取开机时间</title>
		<link>http://imzc.net/archives/179/</link>
		<comments>http://imzc.net/archives/179/#comments</comments>
		<pubDate>Sat, 21 Jan 2012 08:04:15 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[C/C++]]></category>

		<guid isPermaLink="false">http://imzc.net/?p=179</guid>
		<description><![CDATA[使用GetTickCount()函数即可，注意单位是毫秒。DWORD可保存。 &#160; 1 2 3 4 5 [...]]]></description>
			<content:encoded><![CDATA[<p>使用GetTickCount()函数即可，注意单位是毫秒。DWORD可保存。</p>
<p>&nbsp;</p>

<div class="wp_syntax"><table><tr><td class="line_numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
</pre></td><td class="code"><pre class="cpp" style="font-family:monospace;"><span style="color: #666666;">// uptime_c.cpp : 定义控制台应用程序的入口点。</span>
<span style="color: #666666;">//</span>
&nbsp;
<span style="color: #339900;">#include &quot;stdafx.h&quot;</span>
<span style="color: #339900;">#include &quot;uptime_c.h&quot;</span>
&nbsp;
<span style="color: #339900;">#ifdef _DEBUG</span>
<span style="color: #339900;">#define new DEBUG_NEW</span>
<span style="color: #339900;">#endif</span>
&nbsp;
<span style="color: #666666;">// 唯一的应用程序对象</span>
&nbsp;
CWinApp theApp<span style="color: #008080;">;</span>
&nbsp;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span> std<span style="color: #008080;">;</span>
&nbsp;
CString formatTime<span style="color: #008000;">&#40;</span>DWORD timeStamp<span style="color: #008000;">&#41;</span>
<span style="color: #008000;">&#123;</span>
	DWORD minute <span style="color: #000080;">=</span> timeStamp<span style="color: #000040;">/</span><span style="color: #0000dd;">60</span><span style="color: #008080;">;</span>
	DWORD second  <span style="color: #000080;">=</span> timeStamp <span style="color: #000040;">-</span> minute<span style="color: #000040;">*</span><span style="color: #0000dd;">60</span> <span style="color: #008080;">;</span>
	DWORD hour <span style="color: #000080;">=</span> minute <span style="color: #000040;">/</span> <span style="color: #0000dd;">60</span> <span style="color: #008080;">;</span>
	minute <span style="color: #000080;">=</span> minute <span style="color: #000040;">-</span> hour <span style="color: #000040;">*</span> <span style="color: #0000dd;">60</span><span style="color: #008080;">;</span>
	CString csTime <span style="color: #008080;">;</span>
	csTime.<span style="color: #007788;">Format</span><span style="color: #008000;">&#40;</span>_T<span style="color: #008000;">&#40;</span><span style="color: #FF0000;">&quot;%u:%02u:%02u&quot;</span><span style="color: #008000;">&#41;</span>,hour,minute,second<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
	<span style="color: #0000ff;">return</span> csTime<span style="color: #008080;">;</span>
<span style="color: #008000;">&#125;</span>
&nbsp;
<span style="color: #0000ff;">int</span> _tmain<span style="color: #008000;">&#40;</span><span style="color: #0000ff;">int</span> argc, TCHAR<span style="color: #000040;">*</span> argv<span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span>, TCHAR<span style="color: #000040;">*</span> envp<span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span><span style="color: #008000;">&#41;</span>
<span style="color: #008000;">&#123;</span>
	<span style="color: #0000ff;">int</span> nRetCode <span style="color: #000080;">=</span> <span style="color: #0000dd;">0</span><span style="color: #008080;">;</span>
&nbsp;
	HMODULE hModule <span style="color: #000080;">=</span> <span style="color: #008080;">::</span><span style="color: #007788;">GetModuleHandle</span><span style="color: #008000;">&#40;</span><span style="color: #0000ff;">NULL</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
&nbsp;
	<span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span>hModule <span style="color: #000040;">!</span><span style="color: #000080;">=</span> <span style="color: #0000ff;">NULL</span><span style="color: #008000;">&#41;</span>
	<span style="color: #008000;">&#123;</span>
		<span style="color: #666666;">// 初始化 MFC 并在失败时显示错误</span>
		<span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span><span style="color: #000040;">!</span>AfxWinInit<span style="color: #008000;">&#40;</span>hModule, <span style="color: #0000ff;">NULL</span>, <span style="color: #008080;">::</span><span style="color: #007788;">GetCommandLine</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>, <span style="color: #0000dd;">0</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span>
		<span style="color: #008000;">&#123;</span>
			<span style="color: #666666;">// TODO: 更改错误代码以符合您的需要</span>
			_tprintf<span style="color: #008000;">&#40;</span>_T<span style="color: #008000;">&#40;</span><span style="color: #FF0000;">&quot;错误: MFC 初始化失败<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
			nRetCode <span style="color: #000080;">=</span> <span style="color: #0000dd;">1</span><span style="color: #008080;">;</span>
		<span style="color: #008000;">&#125;</span>
		<span style="color: #0000ff;">else</span>
		<span style="color: #008000;">&#123;</span>
			<span style="color: #666666;">// TODO: 在此处为应用程序的行为编写代码。  </span>
			<span style="color: #0000ff;">if</span> <span style="color: #008000;">&#40;</span>argc<span style="color: #000040;">!</span><span style="color: #000080;">=</span><span style="color: #0000dd;">1</span><span style="color: #008000;">&#41;</span>
			<span style="color: #008000;">&#123;</span><span style="color: #666666;">//有任意参数，则输出时间戳。</span>
				_tprintf<span style="color: #008000;">&#40;</span>_T<span style="color: #008000;">&#40;</span><span style="color: #FF0000;">&quot;%u&quot;</span><span style="color: #008000;">&#41;</span>, GetTickCount<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #000040;">/</span><span style="color: #0000dd;">1000</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
			<span style="color: #008000;">&#125;</span> 
			<span style="color: #0000ff;">else</span>
			<span style="color: #008000;">&#123;</span>
				CString   csStartToNow<span style="color: #008000;">&#40;</span>formatTime<span style="color: #008000;">&#40;</span> GetTickCount<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #000040;">/</span><span style="color: #0000dd;">1000</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
				_tprintf<span style="color: #008000;">&#40;</span>_T<span style="color: #008000;">&#40;</span><span style="color: #FF0000;">&quot;%s&quot;</span><span style="color: #008000;">&#41;</span>,csStartToNow<span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
			<span style="color: #008000;">&#125;</span>
&nbsp;
		<span style="color: #008000;">&#125;</span>
	<span style="color: #008000;">&#125;</span>
	<span style="color: #0000ff;">else</span>
	<span style="color: #008000;">&#123;</span>
		<span style="color: #666666;">// TODO: 更改错误代码以符合您的需要</span>
		_tprintf<span style="color: #008000;">&#40;</span>_T<span style="color: #008000;">&#40;</span><span style="color: #FF0000;">&quot;错误: GetModuleHandle 失败<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008080;">;</span>
		nRetCode <span style="color: #000080;">=</span> <span style="color: #0000dd;">1</span><span style="color: #008080;">;</span>
	<span style="color: #008000;">&#125;</span>
&nbsp;
	<span style="color: #0000ff;">return</span> nRetCode<span style="color: #008080;">;</span>
<span style="color: #008000;">&#125;</span></pre></td></tr></table></div>

]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/179/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>ip头和tcp头checksum计算方法</title>
		<link>http://imzc.net/archives/173/</link>
		<comments>http://imzc.net/archives/173/#comments</comments>
		<pubDate>Sun, 18 Dec 2011 09:02:02 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[C/C++]]></category>

		<guid isPermaLink="false">http://u252.com/blog/?p=173</guid>
		<description><![CDATA[ip头和tcp头checksum计算方法 最近需要用到ip头和tcp头重新校验，已生成对应的pcap包。网上搜 [...]]]></description>
			<content:encoded><![CDATA[<p>ip头和tcp头checksum计算方法</p>
<p>最近需要用到ip头和tcp头重新校验，已生成对应的pcap包。网上搜索了下，貌似没有细化的实现。</p>
<p>只有根据各种片段，实现了。 主要填充代码，从sendip开源软件的tcpv4_csum修改而来。</p>
<p>&nbsp;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;errno.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;signal.h&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include &lt;sys/socket.h&gt;</p>
<p>#include &lt;sys/ioctl.h&gt;</p>
<p>#include &lt;netpacket/packet.h&gt; //sockaddr_ll struct</p>
<p>#include &lt;net/if.h&gt; //ifreq struct</p>
<p>#include &lt;linux/ip.h&gt;</p>
<p>#include &lt;linux/if_ether.h&gt;</p>
<p>#include &lt;linux/tcp.h&gt;</p>
<p>#include &lt;netinet/in.h&gt; //htons</p>
<p>#include &lt;netinet/if_ether.h&gt; //ether_header struct</p>
<p>//计算IP校验和</p>
<p>unsigned short checksum(unsigned short *buffer,int size)</p>
<p>{</p>
<p>unsigned long cksum=0;</p>
<p>while(size&gt;1)</p>
<p>{</p>
<p>cksum+=*buffer++;</p>
<p>size-=sizeof(unsigned short);</p>
<p>}</p>
<p>if(size)</p>
<p>{</p>
<p>cksum+=*(unsigned char *)buffer;</p>
<p>}</p>
<p>//将32位数转换成16</p>
<p>while (cksum&gt;&gt;16)</p>
<p>cksum=(cksum&gt;&gt;16)+(cksum &amp; 0xffff);</p>
<p>return (unsigned short) (~cksum);</p>
<p>}</p>
<p>&nbsp;</p>
<p>void tcpv4_check_addr( __u16 * ppkgdata )</p>
<p>&nbsp;</p>
<p>{</p>
<p>const int MaxEthFrame=1514;</p>
<p>char * indata;</p>
<p>__u16 ippktlen, udppktlen,tcppktlen,wd;</p>
<p>__u32 ipheadlen;</p>
<p>struct iphdr * ipd;</p>
<p>struct tcphdr * tcpd;</p>
<p>struct udphdr * udpd;</p>
<p>__u16 * databegin;</p>
<p>indata = (char *)ppkgdata; //从MAC开始的整个帧</p>
<p>ipheadlen = 14 + (indata[14]&amp;0x0f)*4 ; //MAC和ip头的长度和</p>
<p>databegin = (__u16 *)(indata + ipheadlen); //ip数据</p>
<p>ipd = (struct iphdr *)(indata + 14); //MAC数据</p>
<p>tcpd = (struct tcphdr *)(indata + ipheadlen); //ip数据</p>
<p>ippktlen = htons(ipd-&gt;tot_len); //ip头和ip数据的总长度</p>
<p>&nbsp;</p>
<p>if(ipd-&gt;protocol == 0&#215;6){</p>
<p>tcppktlen = ippktlen +14 &#8211; ipheadlen; //tcp头和tcp数据的总长度</p>
<p>printf(&#8220;ip checksum:%x,sport:%x\n&#8221;,ipd-&gt;check,ipd-&gt;saddr);</p>
<p>ipd-&gt;check = 0;</p>
<p>ipd-&gt;check =  checksum((unsigned short *)ipd,ipheadlen-14);</p>
<p>&nbsp;</p>
<p>printf(&#8220;end ip checksum:%x,sport:%x\n&#8221;,ipd-&gt;check,ipd-&gt;saddr);</p>
<p>printf(&#8220;tcp checksum:%x\n&#8221;,tcpd-&gt;check);</p>
<p>&nbsp;</p>
<p>if (tcppktlen &gt; MaxEthFrame) {</p>
<p>fprintf(stderr,&#8221;Tcplen greater than MaxEthFrame(%d) ,real:%d.\n&#8221;,MaxEthFrame,tcppktlen);</p>
<p>return;</p>
<p>}</p>
<p>&nbsp;</p>
<p>u_int16_t * buf = (__u16 *)malloc(MaxEthFrame);</p>
<p>u_int8_t *tempbuf = (u_int8_t *)buf;</p>
<p>tcpd-&gt;check=0;</p>
<p>if(tempbuf == NULL) {</p>
<p>fprintf(stderr,&#8221;Out of memory: TCP checksum not computed\n&#8221;);</p>
<p>return;</p>
<p>}</p>
<p>&nbsp;</p>
<p>/* Set up the pseudo header */</p>
<p>memcpy(tempbuf,&amp;(ipd-&gt;saddr),sizeof(u_int32_t));</p>
<p>memcpy(&amp;(tempbuf[4]),&amp;(ipd-&gt;daddr),sizeof(u_int32_t));</p>
<p>tempbuf[8]=0;</p>
<p>tempbuf[9]=(u_int16_t)ipd-&gt;protocol;</p>
<p>//tempbuf[10]=(u_int16_t)((indata[14]&amp;0x0f)*4);//ip头长度</p>
<p>//tempbuf[11]=(u_int16_t)(tcppktlen);//tcp 头 + data</p>
<p>tempbuf[10]=(u_int16_t)( tcppktlen &amp;0xFF00)&gt;&gt;8;</p>
<p>tempbuf[11]=(u_int16_t)( tcppktlen &amp;0x00FF);</p>
<p>&nbsp;</p>
<p>/* Copy the TCP header and data */</p>
<p>memcpy(tempbuf+12,tcpd,tcppktlen);</p>
<p>//memcpy(tempbuf+12+tcp_hdr-&gt;alloc_len,data-&gt;data,data-&gt;alloc_len);</p>
<p>&nbsp;</p>
<p>/* printf(&#8220;tcppktlen:%d,iphlen:%d,content:\n&#8221;,tcppktlen,(indata[14]&amp;0x0f)*4);</p>
<p>for(int i=0;i&lt;tcppktlen+12;i++){</p>
<p>printf(&#8220;%02x &#8220;,tempbuf[i]);</p>
<p>if((i+1) % 16 ==0) printf(&#8220;\n&#8221;);</p>
<p>}</p>
<p>printf(&#8220;\n&#8221;);</p>
<p>*/</p>
<p>/* CheckSum it */</p>
<p>tcpd-&gt;check = checksum((__u16 *)buf,12+tcppktlen);</p>
<p>free(buf);</p>
<p>&nbsp;</p>
<p>printf(&#8220;end tcp checksum:%x\n&#8221;,tcpd-&gt;check);</p>
<p>&nbsp;</p>
<p>}//end tcp</p>
<p>&nbsp;</p>
<p>}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>int main(int argc,char ** argv){</p>
<p>const int MaxEthFrame=1514;</p>
<p>FILE * fp = fopen(argv[1],&#8221;rb&#8221;);</p>
<p>FILE * fp_save = fopen(argv[2],&#8221;wb&#8221;);</p>
<p>&nbsp;</p>
<p>u_char * frameBuffer=NULL;</p>
<p>&nbsp;</p>
<p>if(fp &amp;&amp; fp_save){</p>
<p>printf(&#8220;Read File %s ok.&#8221;,argv[1]);</p>
<p>frameBuffer = (u_char *)malloc(MaxEthFrame);</p>
<p>&nbsp;</p>
<p>if(frameBuffer == NULL){</p>
<p>printf(&#8220;Alloc parket mem failed.\n&#8221;);</p>
<p>}</p>
<p>&nbsp;</p>
<p>int size =  fread(frameBuffer,sizeof(u_char),MaxEthFrame, fp);</p>
<p>printf(&#8220;sizeof(u_char):%d,Read %d,content:\n&#8221;,sizeof(u_char),size);</p>
<p>for(int i=0;i&lt;size;i++){</p>
<p>printf(&#8220;%02x &#8220;,frameBuffer[i]);</p>
<p>if((i+1) % 16 ==0) printf(&#8220;\n&#8221;);</p>
<p>}</p>
<p>printf(&#8220;\n&#8221;);</p>
<p>&nbsp;</p>
<p>tcpv4_check_addr(( __u16 * )frameBuffer );</p>
<p>&nbsp;</p>
<p>printf(&#8220;Change content:\n&#8221;,size);</p>
<p>for(int i=0;i&lt;size;i++){</p>
<p>printf(&#8220;%02x &#8220;,frameBuffer[i]);</p>
<p>if((i+1) % 16 ==0) printf(&#8220;\n&#8221;);</p>
<p>}</p>
<p>printf(&#8220;\n&#8221;);</p>
<p>&nbsp;</p>
<p>fwrite(frameBuffer,sizeof(u_char),size,fp_save);</p>
<p>&nbsp;</p>
<p>free(frameBuffer);</p>
<p>frameBuffer = NULL;</p>
<p>fclose(fp);</p>
<p>fclose(fp_save);</p>
<p>}else{</p>
<p>printf(&#8220;open failed.&#8221;);</p>
<p>}</p>
<p>&nbsp;</p>
<p>return 0;</p>
<p>}</p>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/173/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>ipv6字符串地址转换为16个unsigned char.</title>
		<link>http://imzc.net/archives/151/</link>
		<comments>http://imzc.net/archives/151/#comments</comments>
		<pubDate>Wed, 21 Sep 2011 18:35:05 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[C/C++]]></category>

		<guid isPermaLink="false">http://u252.com/blog/?p=151</guid>
		<description><![CDATA[练手的,可能转换过程麻烦了一点.初步验证了下,功能应该是没有问题的. ipv6地址格式介绍: http://z [...]]]></description>
			<content:encoded><![CDATA[<p>练手的,可能转换过程麻烦了一点.初步验证了下,功能应该是没有问题的.<br />
ipv6地址格式介绍:</p>
<p>http://zh.wikipedia.org/wiki/IPv6</p>
<pre>#include &lt;iostream &gt;
#include&lt;cstdio &gt;
#include &lt;cstring &gt;
#include &lt;cassert &gt;
using namespace std;


#define  H(x)  ((unsigned char *) &amp; (x) )[0]
#define  L(x)  ((unsigned char *) &amp; (x) )[1]

//char * abbr, ipv6字符串
//unsigned char * ret_buff,返回和引用的buff
//return 传入buff的指针
unsigned char *  ipv6_to_u (char * abbr,unsigned char * ret_buff){
       char  buff[40]={0};
       int  ipv6_int[8]={0};
       int  two_colon = -1;
       int  ipv6_char_len = strlen(abbr);

       assert(abbr!=NULL &amp;&amp; ret_buff!=NULL);
       //查找是否有缩写的情况
    //   two_colon=abbr.find_first_of("::");
    if( (ipv6_char_len&lt;3 )  \
         ||(abbr[0] ==':' &amp;&amp; abbr[1]!=':') \
         ||(abbr[ipv6_char_len-1]==':' &amp;&amp; abbr[ipv6_char_len-2]!=':' ) ){
                        printf("\nInvalid ipv6 addr[%s]!\n",abbr);
                      return 0;
    }

       for(int i=0,j=0;i&lt;ipv6_char_len;i++){
           if(abbr[i]!=':'){
                j++;
           }else{
                j=0;
            }
            if(abbr[i] == ':' &amp;&amp; abbr[i+1] == ':'){
                if(two_colon == -1){
                    two_colon =i;
                }else{
                      printf("\nInvalid ipv6 addr[%s],:: appears once!\n",abbr);
                      return 0;
                }
            }
            if(j&gt;4){
                      printf("\nInvalid ipv6 addr[%s], every 2Bytes not more than 4 chars!\n",abbr);
                      return 0;
            }
        }

//处理缩写的情况.
       if(two_colon&gt;=0){
           int pos = 0;
           int start_colon_num = 0;
           int end_colon_num = 0;
           int  add_colon_num = 0;
           //找:: 前面:的个数
             for(int i=0;i&lt;two_colon;i++){
                if(abbr[i] == ':' ){
                   start_colon_num ++;
                }
            }
            //找:: 后面:的个数
             for(int i=two_colon+2;i&lt;ipv6_char_len;i++){
                if(abbr[i] == ':' ){
                   end_colon_num ++;
                }
            }
            //计算需要添加 "0:" 的个数,总共只有7个冒号.
            add_colon_num = 7 - start_colon_num - end_colon_num ;
            for(pos =0;pos &lt;two_colon;pos ++){
                    buff[pos] = abbr[pos];
            }

           while(add_colon_num&gt;0){
                 buff[pos++] =':';
                add_colon_num --;
                if(add_colon_num!=0)
                 buff[pos++] ='0';
           }
            for(int i=two_colon+2; i&lt;ipv6_char_len; ){
                    buff[pos++] = abbr[i++];
            }
             buff[pos] = '\0';
       }//end
       else //标准格式
       if(two_colon == -1){
           strncpy(buff,abbr,ipv6_char_len);
       }

    //   printf("%s\n",buff);
        int colon_num = sscanf (buff,"%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x",&amp;ipv6_int[0],&amp;ipv6_int[1],&amp;ipv6_int[2],&amp;ipv6_int[3],\
                                                                                                              &amp;ipv6_int[4],&amp;ipv6_int[5],&amp;ipv6_int[6],&amp;ipv6_int[7]);
        if(colon_num&lt;=0 || (two_colon==-1 &amp;&amp; colon_num !=8 )  ){
            printf("Invalid ipv6 addr [%s] format!\n",abbr);
           return 0 ;
        }
        #if 0
       printf("colon_num:%d,two_colon:%d\n",colon_num,two_colon);
        for(int k=0;k&lt;8;k++){
              printf("%3d,",ipv6_int[k]);
       }
       #endif
       //获取标准化后的值
        for(int i=0;i&lt;8;i++){
            ret_buff[i*2] = L(ipv6_int[i]);
            ret_buff[i*2+1] = H(ipv6_int[i]);

        }
        return ret_buff;


}

void print_ipv6_buff(const char * ipv6_str, unsigned char *ipv6_std_buf){
        if(ipv6_str==NULL || ipv6_std_buf==NULL)
            return;
        printf("ipv6 string[%s]:\n",ipv6_str);
        for(int i=0;i&lt;15;i++){
           printf("%02d-",i);
        }
        printf("15\n");
        for(int i=0;i&lt;16;i++){
           printf("%02x ",ipv6_std_buf[i]);
        }
        printf("\n\n");
}

int main(int argc,char ** argv)
{
    unsigned char ipv6_long_buf[16]={0};

    if(argc!=2){
     printf("Useage:prog  \"ipv6_addr\"\n");
    /*
    char ipv6_l[] =  "fe80:1:0:0:c05:4fc6:bb33:9d8f";

    char ipv6_s1[] =  "fe80:1::c05:4fc6:bb33:9d8f";
    char ipv6_s2[] =  "::c05:4fc6:bb33:9d8f";
    char ipv6_s3[] =  "f8:1::c05:0:0:9d8f";
    char ipv6_s4[] =  "fe80:1:c05:4fc6:bb33:9d8f::";

    char ipv6_s5[] =  "fe80::1::fc6:bb33:9d8f::";
    char ipv6_s6[] =  "fe80::::fc6:bb33:9d8f::";
    char ipv6_s7[] =  "fe80:fc6:bb33:9d8f:";
    char ipv6_s8[] =  ":fe80:fc6:bb33:9d8f";
   //std
   print_ipv6_buff(ipv6_l,ipv6_to_u (ipv6_l,ipv6_long_buf));
   //abbr
   print_ipv6_buff(ipv6_s1,ipv6_to_u (ipv6_s1,ipv6_long_buf));
   print_ipv6_buff(ipv6_s2,ipv6_to_u (ipv6_s2,ipv6_long_buf));
   print_ipv6_buff(ipv6_s3,ipv6_to_u (ipv6_s3,ipv6_long_buf));
   print_ipv6_buff(ipv6_s4,ipv6_to_u (ipv6_s4,ipv6_long_buf));
   //error
   print_ipv6_buff(ipv6_s5,ipv6_to_u (ipv6_s5,ipv6_long_buf));
   print_ipv6_buff(ipv6_s6,ipv6_to_u (ipv6_s6,ipv6_long_buf));
   print_ipv6_buff(ipv6_s7,ipv6_to_u (ipv6_s7,ipv6_long_buf));
   print_ipv6_buff(ipv6_s8,ipv6_to_u (ipv6_s8,ipv6_long_buf));
*/
    }else{
          print_ipv6_buff(argv[1],ipv6_to_u (argv[1],ipv6_long_buf));
    }
    return 0;
}</pre>
<p>运行截图:</p>
<pre>~/programming/ipv6test$ ./ip "aaa1:aaa2:aaa3:aaa4:aaa5:aaa6:aaa7:aaa8"
ipv6 string[aaa1:aaa2:aaa3:aaa4:aaa5:aaa6:aaa7:aaa8]:
00-01-02-03-04-05-06-07-08-09-10-11-12-13-14-15
aa a1 aa a2 aa a3 aa a4 aa a5 aa a6 aa a7 aa a8</pre>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/151/feed/</wfw:commentRss>
		<slash:comments>291</slash:comments>
		</item>
		<item>
		<title>linux下实现inject&amp;hook</title>
		<link>http://imzc.net/archives/134/</link>
		<comments>http://imzc.net/archives/134/#comments</comments>
		<pubDate>Sun, 14 Aug 2011 02:59:00 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[C/C++]]></category>

		<guid isPermaLink="false">http://imzc.net/?p=134</guid>
		<description><![CDATA[linux调用so的库文件时，搜素路径为当前路径，再是系统lib目录。 因此，我们便可以利用这个技巧，实现li [...]]]></description>
			<content:encoded><![CDATA[<p>linux调用so的库文件时，搜素路径为当前路径，再是系统lib目录。<br />
因此，我们便可以利用这个技巧，实现linux下hook功能。<br />
即当前程序目录生成一个同名so，然后由so中同名函数，实现hook功能后，再调用原始的函数。<br />
关键函数dlopen，dlsym。<br />
step1. sudo -s -H<br />
step2. export LD_LIBRARY_PATH=/pwd_dirname/:$LD_LIBRARY_PATH<br />
将当前目录导入到环境变量，以保证优先搜索本地目录。<br />
step3. make</p>

<div class="wp_syntax"><table><tr><td class="line_numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre class="c" style="font-family:monospace;"><span style="color: #339933;">#include&lt;stdio.h&gt;</span>
<span style="color: #339933;">#include&lt;dlfcn.h&gt;</span>
<span style="color: #993333;">typedef</span> <span style="color: #993333;">int</span> <span style="color: #009900;">&#40;</span><span style="color: #339933;">*</span>f<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#40;</span><span style="color: #993333;">char</span> <span style="color: #339933;">*</span> <span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
<span style="color: #993333;">int</span> o_lib_function <span style="color: #009900;">&#40;</span><span style="color: #993333;">char</span> <span style="color: #339933;">*</span> msg<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>
<span style="color: #993333;">void</span> <span style="color: #339933;">*</span> hl <span style="color: #339933;">=</span> dlopen<span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;/lib/libfunc.so&quot;</span><span style="color: #339933;">,</span>RTLD_NOW<span style="color: #339933;">|</span>RTLD_GLOBAL<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
f old_lib_function <span style="color: #339933;">=</span> <span style="color: #009900;">&#40;</span>f<span style="color: #009900;">&#41;</span> dlsym<span style="color: #009900;">&#40;</span>hl<span style="color: #339933;">,</span> <span style="color: #ff0000;">&quot;o_lib_function&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
<span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;call in injected function. <span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
<span style="color: #b1b100;">return</span> <span style="color: #009900;">&#40;</span><span style="color: #339933;">*</span> old_lib_function<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#40;</span>msg<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
<span style="color: #009900;">&#125;</span></pre></td></tr></table></div>

<p>其余函数见附件。<br />
<a href="http://imzc.net/archives/134/linux_inject_test-tar" rel="attachment wp-att-135">linux_inject_test.tar</a></p>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/134/feed/</wfw:commentRss>
		<slash:comments>356</slash:comments>
		</item>
		<item>
		<title>[转]linux core dump 知识整理</title>
		<link>http://imzc.net/archives/119/</link>
		<comments>http://imzc.net/archives/119/#comments</comments>
		<pubDate>Sat, 29 Jan 2011 12:05:06 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[C/C++]]></category>

		<guid isPermaLink="false">http://imzc.net/?p=119</guid>
		<description><![CDATA[linux core dump 知识整理]]></description>
			<content:encoded><![CDATA[<p>linux core dump 知识整理<br />
<a href="http://hi.baidu.com/donghaozheng/blog/item/1ef1ebdda53a38e376c63898.html">http://hi.baidu.com/donghaozheng/blog/item/1ef1ebdda53a38e376c63898.html</a><br />
core dump及应用</p>
<p>【1】core dump 概念</p>
<p>http://en.wikipedia.org.nyud.net:8080/wiki/Core_dump</p>
<p>A core dump is the recorded state of the working memory of a computer program at a specific time, generally when the program has terminated abnormally (crashed). In practice, other key pieces of program state are usually dumped at the same time, including the processor registers, which may include the program counter and stack pointer, memory management information, and other processor and operating system flags and information. The name comes from the once-standard memory technology core memory. Core dumps are often used to diagnose or debug errors in computer programs.</p>
<p>On many operating systems, a fatal error in a program automatically triggers a core dump, and by extension the phrase &#8220;to dump core&#8221; has come to mean, in many cases, any fatal error, regardless of whether a record of the program memory is created.</p>
<p>【2】示例：在Linux下产生并调试core文件</p>
<p>参考http://www.zedware.org/code/code-coredump.html</p>
<p>先看看我用的是个什么机器：</p>
<p>$ uname -a<br />
Linux dev 2.4.21-9.30AXsmp #1 SMP Wed May 26 23:37:09 EDT 2004 i686 i686 i386 GNU/Linux</p>
<p>再看看默认的一些参数，注意core file size是个0，程序出错时不会产生core文件了。</p>
<p>$ ulimit -a<br />
core file size (blocks, -c) 0<br />
data seg size (kbytes, -d) unlimited<br />
file size (blocks, -f) unlimited<br />
max locked memory (kbytes, -l) 4<br />
max memory size (kbytes, -m) unlimited<br />
open files (-n) 2048<br />
pipe size (512 bytes, -p) 8<br />
stack size (kbytes, -s) 10240<br />
cpu time (seconds, -t) unlimited<br />
max user processes (-u) 7168<br />
virtual memory (kbytes, -v) unlimited</p>
<p>写个简单的程序，看看core文件是不是会被产生。创建foo.c，使内容如下。</p>
<p>$ more foo.c</p>
<p>#include</p>
<p>static void sub(void);</p>
<p>int main(void)<br />
{<br />
sub();<br />
return 0;<br />
}</p>
<p>static void sub(void)<br />
{<br />
int *p = NULL;</p>
<p>/* derefernce a null pointer, expect core dump. */<br />
printf(&#8220;%d&#8221;, *p);<br />
}</p>
<p>$ gcc -Wall -g foo.c   【-Wall :[Warning all] 显示所有常用的编译警告信息。 -g选项，将调试信息加入到目标文件或可执行文件中。】<br />
$ ./a.out<br />
Segmentation fault   【所谓的Segmentation Fault（段错误）就是指访问的内存超出了系统所给这个程序的内存空间】</p>
<p>$ ls -l core*<br />
ls: core*: No such file or directory</p>
<p>没有找到core文件，我们改改ulimit的设置，让它产生，1024是随便取的，也可以使用ulimit -c unlimited不限制大小。</p>
<p>$ ulimit -c 1024</p>
<p>$ ulimit -a<br />
core file size (blocks, -c) 1024<br />
data seg size (kbytes, -d) unlimited<br />
file size (blocks, -f) unlimited<br />
max locked memory (kbytes, -l) 4<br />
max memory size (kbytes, -m) unlimited<br />
open files (-n) 2048<br />
pipe size (512 bytes, -p) 8<br />
stack size (kbytes, -s) 10240<br />
cpu time (seconds, -t) unlimited<br />
max user processes (-u) 7168<br />
virtual memory (kbytes, -v) unlimited</p>
<p>$ ./a.out<br />
Segmentation fault (core dumped)<br />
$ ls -l core*<br />
-rw&#8212;&#8212;- 1 uniware uniware 53248 Jun 30 17:10 core.9128 【此处也可能是名称为core的文件】</p>
<p>注意看上述的输出信息，多了个(core dumped)。确实产生了一个core文件，9128是该进程的PID。我们用GDB来看看这个core。</p>
<p>$ gdb &#8211;core=core.9128<br />
GNU gdb Asianux (6.0post-0.20040223.17.1AX)<br />
Copyright 2004 Free Software Foundation, Inc.<br />
GDB is free software, covered by the GNU General Public License, and you are<br />
welcome to change it and/or distribute copies of it under certain conditions.<br />
Type &#8220;show copying&#8221; to see the conditions.<br />
There is absolutely no warranty for GDB. Type &#8220;show warranty&#8221; for details.<br />
This was configured as &#8220;i386-asianux-linux-gnu&#8221;.<br />
Core was generated by `./a.out&#8217;.<br />
Program terminated with signal 11, Segmentation fault.<br />
#0 0&#215;08048373 in ?? ()<br />
(gdb) bt<br />
#0 0&#215;08048373 in ?? ()<br />
#1 0xbfffd8f8 in ?? ()<br />
#2 0x0804839e in ?? ()<br />
#3 0xb74cc6b3 in ?? ()<br />
#4 0&#215;00000000 in ?? ()</p>
<p>此时用bt看不到backtrace，也就是调用堆栈，原来GDB还不知道符号信息在哪里。我们告诉它一下：</p>
<p>(gdb) file ./a.out<br />
Reading symbols from ./a.out&#8230;done.<br />
Using host libthread_db library &#8220;/lib/tls/libthread_db.so.1&#8243;.<br />
(gdb) bt<br />
#0 0&#215;08048373 in sub () at foo.c:17<br />
#1 0&#215;08048359 in main () at foo.c:8</p>
<p>此时backtrace出来了。</p>
<p>(gdb) l   （此处是“L”的小写，不是数字“1”）<br />
8         sub();<br />
9         return 0;<br />
10     }<br />
11<br />
12      static void sub(void)<br />
13      {<br />
14          int *p = NULL;<br />
15<br />
16          /* derefernce a null pointer, expect core dump. */<br />
17          printf(&#8220;%d&#8221;, *p);<br />
(gdb)</p>
<p>【3】总结</p>
<p>参考http://blog.csdn.net/shaovey/archive/2008/07/31/2744487.aspx</p>
<p>在程序不寻常退出时，内核会在当前工作目录下生成一个core文件（是一个内存映像，同时加上调试信息）。使用gdb来查看core文件，可以指示出导致程序出错的代码所在文件和行数。</p>
<p>1.core文件的生成开关和大小限制<br />
1）使用ulimit -c命令可查看core文件的生成开关。若结果为0，则表示关闭了此功能，不会生成core文件。<br />
2）使用ulimit -c filesize命令，可以限制core文件的大小（filesize的单位为kbyte）。如果生成的信息超过此大小，将会被裁剪，最终生成一个不完整的core文件。在调试此core文件的时候，gdb会提示错误。若ulimit -c unlimited，则表示core文件的大小不受限制。ulimit -c 0关闭该功能。<br />
PS: ulimit使用方法见http://www.ibm.com/developerworks/cn/linux/l-cn-ulimit/</p>
<p>2.core文件的名称和生成路径<br />
core文件生成路径:输入可执行文件运行命令的同一路径下。<br />
若系统生成的core文件不带其它任何扩展名称，则全部命名为core。新的core文件生成将覆盖原来的core文件。</p>
<p>1）/proc/sys/kernel/core_uses_pid可以控制core文件的文件名中是否添加pid作为扩展。文件内容为1，表示添加pid作为扩展名，生成的core文件格式为core.xxxx；为0则表示生成的core文件同一命名为core。<br />
可通过以下命令修改此文件：<br />
echo &#8220;1&#8243; &gt; /proc/sys/kernel/core_uses_pid</p>
<p>2）proc/sys/kernel/core_pattern可以控制core文件保存位置和文件名格式。<br />
可通过以下命令修改此文件：<br />
echo &#8220;/corefile/core-%e-%p-%t&#8221; &gt; core_pattern，可以将core文件统一生成到/corefile目录下，产生的文件名为core-命令名-pid-时间戳<br />
以下是参数列表:<br />
%p &#8211; insert pid into filename 添加pid<br />
%u &#8211; insert current uid into filename 添加当前uid<br />
%g &#8211; insert current gid into filename 添加当前gid<br />
%s &#8211; insert signal that caused the coredump into the filename 添加导致产生core的信号<br />
%t &#8211; insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间<br />
%h &#8211; insert hostname where the coredump happened into filename 添加主机名<br />
%e &#8211; insert coredumping executable name into filename 添加命令名</p>
<p>3.core文件的查看<br />
core文件需要使用gdb来查看。<br />
gdb ./a.out<br />
core-file core.xxxx<br />
使用bt命令即可看到程序出错的地方。<br />
以下两种命令方式具有相同的效果，但是在有些环境下不生效，所以推荐使用上面的命令。<br />
1）gdb -core=core.xxxx<br />
file ./a.out<br />
bt<br />
2）gdb -c core.xxxx<br />
file ./a.out<br />
bt</p>
<p>4.开发板上使用core文件调试<br />
如果开发板的操作系统也是linux，core调试方法依然适用。如果开发板上不支持gdb，可将开发板的环境（依赖库）、可执行文件和core文件拷贝到PC的linux下。<br />
在PC上调试开发板上产生的core文件，需要使用交叉编译器自带的gdb，并且需要在gdb中指定solib-absolute-prefix和solib-search-path两个变量以保证gdb能够找到可执行程序的依赖库路径。有一种建立配置文件的方法，不需要每次启动gdb都配置以上变量，即：在待运行gdb的路径下建立.gdbinit。<br />
配置文件内容：<br />
set solib-absolute-prefix YOUR_CROSS_COMPILE_PATH<br />
set solib-search-path YOUR_CROSS_COMPILE_PATH<br />
set solib-search-path YOUR_DEVELOPER_TOOLS_LIB_PATH<br />
handle SIG32 nostop noprint pass</p>
<p>注意：待调试的可执行文件，在编译的时候需要加-g，core文件才能正常显示出错信息！有时候core信息很大，超出了开发板的空间限制，生成的core信息会残缺不全而无法使用，可以通过挂载到PC的方式来规避这一点。</p>
<p>还有一个,可以通过execinfo.h中相关函数实现,转一个cu上面的例子:</p>

<div class="wp_syntax"><div class="code"><pre class="c" style="font-family:monospace;"><span style="color: #666666; font-style: italic;">//内存越界获取堆栈地方法 </span>
<span style="color: #666666; font-style: italic;">//这个函数打出信息比较详细</span>
&nbsp;
<span style="color: #339933;">#include &lt;stdio.h&gt;</span>
<span style="color: #339933;">#include &lt;signal.h&gt;</span>
<span style="color: #339933;">#include &lt;execinfo.h&gt;</span>
&nbsp;
<span style="color: #993333;">void</span> bt_sighandler<span style="color: #009900;">&#40;</span><span style="color: #993333;">int</span> sig<span style="color: #339933;">,</span> <span style="color: #993333;">struct</span> sigcontext ctx<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
&nbsp;
 <span style="color: #993333;">void</span> <span style="color: #339933;">*</span>trace<span style="color: #009900;">&#91;</span><span style="color: #0000dd;">16</span><span style="color: #009900;">&#93;</span><span style="color: #339933;">;</span>
 <span style="color: #993333;">char</span> <span style="color: #339933;">**</span>messages <span style="color: #339933;">=</span> <span style="color: #009900;">&#40;</span><span style="color: #993333;">char</span> <span style="color: #339933;">**</span><span style="color: #009900;">&#41;</span>NULL<span style="color: #339933;">;</span>
 <span style="color: #993333;">int</span> i<span style="color: #339933;">,</span> trace_size <span style="color: #339933;">=</span> <span style="color: #0000dd;">0</span><span style="color: #339933;">;</span>
&nbsp;
 <span style="color: #b1b100;">if</span> <span style="color: #009900;">&#40;</span>sig <span style="color: #339933;">==</span> SIGSEGV<span style="color: #009900;">&#41;</span>
<span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;Got signal %d, faulty address is %p, &quot;</span>
  <span style="color: #ff0000;">&quot;from %p<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #339933;">,</span> sig<span style="color: #339933;">,</span> ctx.<span style="color: #202020;">cr2</span><span style="color: #339933;">,</span> ctx.<span style="color: #202020;">eip</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #b1b100;">else</span>
<span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;Got signal %d<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #339933;">,</span> sig<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&nbsp;
 trace_size <span style="color: #339933;">=</span> backtrace<span style="color: #009900;">&#40;</span>trace<span style="color: #339933;">,</span> <span style="color: #0000dd;">16</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #808080; font-style: italic;">/* overwrite sigaction with caller's address */</span>
 trace<span style="color: #009900;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #009900;">&#93;</span> <span style="color: #339933;">=</span> <span style="color: #009900;">&#40;</span><span style="color: #993333;">void</span> <span style="color: #339933;">*</span><span style="color: #009900;">&#41;</span>ctx.<span style="color: #202020;">eip</span><span style="color: #339933;">;</span>
 messages <span style="color: #339933;">=</span> backtrace_symbols<span style="color: #009900;">&#40;</span>trace<span style="color: #339933;">,</span> trace_size<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #808080; font-style: italic;">/* skip first stack frame (points here) */</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;[bt] Execution path:<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #b1b100;">for</span> <span style="color: #009900;">&#40;</span>i<span style="color: #339933;">=</span><span style="color: #0000dd;">1</span><span style="color: #339933;">;</span> i<span style="color: #339933;">&lt;</span>trace_size<span style="color: #339933;">;</span> <span style="color: #339933;">++</span>i<span style="color: #009900;">&#41;</span>
<span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;[bt] %s<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #339933;">,</span> messages<span style="color: #009900;">&#91;</span>i<span style="color: #009900;">&#93;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&nbsp;
 exit<span style="color: #009900;">&#40;</span><span style="color: #0000dd;">0</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
<span style="color: #009900;">&#125;</span>
&nbsp;
&nbsp;
<span style="color: #993333;">int</span> func_a<span style="color: #009900;">&#40;</span><span style="color: #993333;">int</span> a<span style="color: #339933;">,</span> <span style="color: #993333;">char</span> b<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
&nbsp;
 <span style="color: #993333;">char</span> <span style="color: #339933;">*</span>p <span style="color: #339933;">=</span> <span style="color: #009900;">&#40;</span><span style="color: #993333;">char</span> <span style="color: #339933;">*</span><span style="color: #009900;">&#41;</span><span style="color: #208080;">0xdeadbeef</span><span style="color: #339933;">;</span>
&nbsp;
 a <span style="color: #339933;">=</span> a <span style="color: #339933;">+</span> b<span style="color: #339933;">;</span>
 <span style="color: #339933;">*</span>p <span style="color: #339933;">=</span> <span style="color: #0000dd;">10</span><span style="color: #339933;">;</span> <span style="color: #808080; font-style: italic;">/* CRASH here!! */</span>
&nbsp;
 <span style="color: #b1b100;">return</span> <span style="color: #0000dd;">2</span><span style="color: #339933;">*</span>a<span style="color: #339933;">;</span>
<span style="color: #009900;">&#125;</span>
&nbsp;
&nbsp;
<span style="color: #993333;">int</span> func_b<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
&nbsp;
 <span style="color: #993333;">int</span> res<span style="color: #339933;">,</span> a <span style="color: #339933;">=</span> <span style="color: #0000dd;">5</span><span style="color: #339933;">;</span>
&nbsp;
 res <span style="color: #339933;">=</span> <span style="color: #0000dd;">5</span> <span style="color: #339933;">+</span> func_a<span style="color: #009900;">&#40;</span>a<span style="color: #339933;">,</span> <span style="color: #ff0000;">'t'</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&nbsp;
 <span style="color: #b1b100;">return</span> res<span style="color: #339933;">;</span>
<span style="color: #009900;">&#125;</span>
&nbsp;
&nbsp;
<span style="color: #993333;">int</span> main<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
&nbsp;
 <span style="color: #808080; font-style: italic;">/* Install our signal handler */</span>
 <span style="color: #993333;">struct</span> sigaction sa<span style="color: #339933;">;</span>
&nbsp;
 sa.<span style="color: #202020;">sa_handler</span> <span style="color: #339933;">=</span> <span style="color: #009900;">&#40;</span><span style="color: #993333;">void</span> <span style="color: #339933;">*</span><span style="color: #009900;">&#41;</span>bt_sighandler<span style="color: #339933;">;</span>
 sigemptyset<span style="color: #009900;">&#40;</span><span style="color: #339933;">&amp;</span>sa.<span style="color: #202020;">sa_mask</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 sa.<span style="color: #202020;">sa_flags</span> <span style="color: #339933;">=</span> SA_RESTART<span style="color: #339933;">;</span>
&nbsp;
 sigaction<span style="color: #009900;">&#40;</span>SIGSEGV<span style="color: #339933;">,</span> <span style="color: #339933;">&amp;</span>sa<span style="color: #339933;">,</span> NULL<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 sigaction<span style="color: #009900;">&#40;</span>SIGUSR1<span style="color: #339933;">,</span> <span style="color: #339933;">&amp;</span>sa<span style="color: #339933;">,</span> NULL<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #808080; font-style: italic;">/* ... add any other signal here */</span>
&nbsp;
 <span style="color: #808080; font-style: italic;">/* Do something */</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;%d<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #339933;">,</span> func_b<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&nbsp;
&nbsp;
<span style="color: #009900;">&#125;</span></pre></div></div>

]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/119/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>分享几个Source Insight 序列号</title>
		<link>http://imzc.net/archives/116/</link>
		<comments>http://imzc.net/archives/116/#comments</comments>
		<pubDate>Sun, 12 Dec 2010 06:46:01 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[C/C++]]></category>

		<guid isPermaLink="false">http://imzc.net/archives/116</guid>
		<description><![CDATA[Source Insight,功能很强大的代码查看分析工具。 官方网站： http://www.sourcei [...]]]></description>
			<content:encoded><![CDATA[<p>Source Insight,功能很强大的代码查看分析工具。</p>
<p>官方网站： <br/><a href="http://www.sourceinsight.com/">http://www.sourceinsight.com/</a></p>
<p>SN： <br/>SI3US-230590-09757 <br/>SI3US-840598-11493 <br/>SI3US-404808-04697 <br/>SI3US-510811-93484 <br/>SI3US-343066-11287</p>
<p>来源网络&#8230;</p>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/116/feed/</wfw:commentRss>
		<slash:comments>271</slash:comments>
		</item>
		<item>
		<title>Windows API 大全</title>
		<link>http://imzc.net/archives/130/</link>
		<comments>http://imzc.net/archives/130/#comments</comments>
		<pubDate>Fri, 29 Oct 2010 16:27:47 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[C/C++]]></category>

		<guid isPermaLink="false">http://imzc.net/?p=130</guid>
		<description><![CDATA[1. API之网络函数 WNetAddConnection 创建同一个网络资源的永久性连接 WNetAddCo [...]]]></description>
			<content:encoded><![CDATA[<p>1. API之网络函数</p>
<p>WNetAddConnection 创建同一个网络资源的永久性连接<br />
WNetAddConnection2 创建同一个网络资源的连接<br />
WNetAddConnection3 创建同一个网络资源的连接<br />
WNetCancelConnection 结束一个网络连接<br />
WNetCancelConnection2 结束一个网络连接<br />
WNetCloseEnum 结束一次枚举操作<br />
WNetConnectionDialog 启动一个标准对话框，以便建立同网络资源的连接<br />
WNetDisconnectDialog 启动一个标准对话框，以便断开同网络资源的连接<br />
WNetEnumResource 枚举网络资源<br />
WNetGetConnection 获取本地或已连接的一个资源的网络名称<br />
WNetGetLastError 获取网络错误的扩展错误信息<br />
WNetGetUniversalName 获取网络中一个文件的远程名称以及/或者UNC（统一命名规范）名称<br />
WNetGetUser 获取一个网络资源用以连接的名字<br />
WNetOpenEnum 启动对网络资源进行枚举的过程</p>
<p>2. API之消息函数</p>
<p>BroadcastSystemMessage 将一条系统消息广播给系统中所有的顶级窗口<br />
GetMessagePos 取得消息队列中上一条消息处理完毕时的鼠标指针屏幕位置<br />
GetMessageTime 取得消息队列中上一条消息处理完毕时的时间<br />
PostMessage 将一条消息投递到指定窗口的消息队列<br />
PostThreadMessage 将一条消息投递给应用程序<br />
RegisterWindowMessage 获取分配给一个字串标识符的消息编号<br />
ReplyMessage 答复一个消息<br />
SendMessage 调用一个窗口的窗口函数，将一条消息发给那个窗口<br />
SendMessageCallback 将一条消息发给窗口<br />
SendMessageTimeout 向窗口发送一条消息<br />
SendNotifyMessage 向窗口发送一条消息</p>
<p>3. API之文件处理函数</p>
<p>CloseHandle 关闭一个内核对象。其中包括文件、文件映射、进程、线程、安全和同步对象等<br />
CompareFileTime 对比两个文件的时间<br />
CopyFile 复制文件<br />
CreateDirectory 创建一个新目录<br />
CreateFile 打开和创建文件、管道、邮槽、通信服务、设备以及控制台<br />
CreateFileMapping 创建一个新的文件映射对象<br />
DeleteFile 删除指定文件</p>
<p>DeviceIoControl 对设备执行指定的操作<br />
DosDateTimeToFileTime 将DOS日期和时间值转换成一个 win32 FILETIME 值<br />
FileTimeToDosDateTime 将一个 win32 FILETIME 值转换成DOS日期和时间值<br />
FileTimeToLocalFileTime 将一个FILETIME结构转换成本地时间<br />
FileTimeToSystemTime 根据一个FILETIME结构的内容，装载一个SYSTEMTIME结构<br />
FindClose 关闭由FindFirstFile函数创建的一个搜索句柄<br />
FindFirstFile 根据文件名查找文件<br />
FindNextFile 根据调用FindFirstFile函数时指定的一个文件名查找下一个文件<br />
FlushFileBuffers 针对指定的文件句柄，刷新内部文件缓冲区<br />
FlushViewOfFile 将写入文件映射缓冲区的所有数据都刷新到磁盘<br />
GetBinaryType 判断文件是否可以执行<br />
GetCompressedFileSize 判断一个压缩文件在磁盘上实际占据的字节数<br />
GetCurrentDirectory 在一个缓冲区中装载当前目录<br />
GetDiskFreeSpace 获取与一个磁盘的组织有关的信息，以及了解剩余空间的容量<br />
GetDiskFreeSpaceEx 获取与一个磁盘的组织以及剩余空间容量有关的信息<br />
GetDriveType 判断一个磁盘驱动器的类型<br />
GetExpandedName 取得一个压缩文件的全名<br />
GetFileAttributes 判断指定文件的属性<br />
GetFileInformationByHandle 这个函数提供了获取文件信息的一种机制<br />
GetFileSize 判断文件长度<br />
GetFileTime 取得指定文件的时间信息<br />
GetFileType 在给出文件句柄的前提下，判断文件类型<br />
GetFileVersionInfo 从支持版本标记的一个模块里获取文件版本信息<br />
GetFileVersionInfoSize 针对包含了版本资源的一个文件，判断容纳文件版本信息需要一个多大的缓冲区<br />
GetFullPathName 获取指定文件的完整路径名<br />
GetLogicalDrives 判断系统中存在哪些逻辑驱动器字母<br />
GetLogicalDriveStrings 获取一个字串，其中包含了当前所有逻辑驱动器的根驱动器路径<br />
GetOverlappedResult 判断一个重叠操作当前的状态<br />
GetPrivateProfileInt 为初始化文件（.ini文件）中指定的条目获取一个整数值<br />
GetPrivateProfileSection 获取指定小节（在.ini文件中）所有项名和值的一个列表<br />
GetPrivateProfileString 为初始化文件中指定的条目取得字串<br />
GetProfileInt 取得win.ini初始化文件中指定条目的一个整数值<br />
GetProfileSection 获取指定小节（在win.ini文件中）所有项名和值的一个列表<br />
GetProfileString 为win.ini初始化文件中指定的条目取得字串<br />
GetShortPathName 获取指定文件的短路径名<br />
GetSystemDirectory 取得Windows系统目录（即System目录）的完整路径名<br />
GetTempFileName 这个函数包含了一个临时文件的名字，它可由应用程序使用<br />
GetTempPath 获取为临时文件指定的路径<br />
GetVolumeInformation 获取与一个磁盘卷有关的信息<br />
GetWindowsDirectory 获取Windows目录的完整路径名<br />
hread 参考lread<br />
hwrite 参考lwrite函数<br />
lclose 关闭指定的文件<br />
lcreat 创建一个文件<br />
llseek 设置文件中进行读写的当前位置<br />
LockFile 锁定文件的某一部分，使其不与其他应用程序共享<br />
LockFileEx 与LockFile相似，只是它提供了更多的功能<br />
lopen 以二进制模式打开指定的文件<br />
lread 将文件中的数据读入内存缓冲区<br />
lwrite 将数据从内存缓冲区写入一个文件<br />
LZClose 关闭由LZOpenFile 或 LZInit函数打开的一个文件<br />
LZCopy 复制一个文件<br />
LZInit 这个函数用于初始化内部缓冲区<br />
LZOpenFile 该函数能执行大量不同的文件处理，而且兼容于压缩文件<br />
LZRead 将数据从文件读入内存缓冲区<br />
LZSeek 设置一个文件中进行读写的当前位置<br />
MapViewOfFile 将一个文件映射对象映射到当前应用程序的地址空间<br />
MoveFile 移动文件<br />
OpenFile 这个函数能执行大量不同的文件操作<br />
OpenFileMapping 打开一个现成的文件映射对象<br />
QueryDosDevice 在Windows NT中，DOS设备名会映射成NT系统设备名。该函数可判断当前的设备映射情况<br />
ReadFile 从文件中读出数据<br />
ReadFileEx 与ReadFile相似，只是它只能用于异步读操作，并包含了一个完整的回调<br />
RegCloseKey 关闭系统注册表中的一个项（或键）<br />
RegConnectRegistry 访问远程系统的部分注册表<br />
RegCreateKey 在指定的项下创建或打开一个项<br />
RegCreateKeyEx 在指定项下创建新项的更复杂的方式。在Win32环境中建议使用这个函数<br />
RegDeleteKey 删除现有项下方一个指定的子项<br />
RegDeleteValue 删除指定项下方的一个值<br />
RegEnumKey 枚举指定项的子项。在Win32环境中应使用RegEnumKeyEx<br />
RegEnumKeyEx 枚举指定项下方的子项<br />
RegEnumValue 枚举指定项的值<br />
RegFlushKey 将对项和它的子项作出的改动实际写入磁盘<br />
RegGetKeySecurity 获取与一个注册表项有关的安全信息<br />
RegLoadKey 从以前用RegSaveKey函数创建的一个文件里装载注册表信息<br />
RegNotifyChangeKeyValue 注册表项或它的任何一个子项发生变化时，用这个函数提供一种通知机制<br />
RegOpenKey 打开一个现有的注册表项<br />
RegOpenKeyEx 打开一个现有的项。在win32下推荐使用这个函数<br />
RegQueryInfoKey 获取与一个项有关的信息<br />
RegQueryValue 取得指定项或子项的默认（未命名）值<br />
RegQueryValueEx 获取一个项的设置值<br />
RegReplaceKey 用一个磁盘文件保存的信息替换注册表信息；并创建一个备份，在其中包含当前注册表信息<br />
RegRestoreKey 从一个磁盘文件恢复注册表信息<br />
RegSaveKey 将一个项以及它的所有子项都保存到一个磁盘文件<br />
RegSetKeySecurity 设置指定项的安全特性<br />
RegSetValue 设置指定项或子项的默认值<br />
RegSetValueEx 设置指定项的值<br />
RegUnLoadKey 卸载指定的项以及它的所有子项<br />
RemoveDirectory 删除指定目录<br />
SearchPath 查找指定文件<br />
SetCurrentDirectory 设置当前目录<br />
SetEndOfFile 针对一个打开的文件，将当前文件位置设为文件末尾<br />
SetFileAttributes 设置文件属性<br />
SetFilePointer 在一个文件中设置当前的读写位置<br />
SetFileTime 设置文件的创建、访问及上次修改时间<br />
SetHandleCount 这个函数不必在win32下使用；即使使用，也不会有任何效果<br />
SetVolumeLabel 设置一个磁盘的卷标（Label）<br />
SystemTimeToFileTime 根据一个FILETIME结构的内容，载入一个SYSTEMTIME结构<br />
UnlockFile 解除对一个文件的锁定<br />
UnlockFileEx 解除对一个文件的锁定<br />
UnmapViewOfFile 在当前应用程序的内存地址空间解除对一个文件映射对象的映射<br />
VerFindFile 用这个函数决定一个文件应安装到哪里<br />
VerInstallFile 用这个函数安装一个文件<br />
VerLanguageName 这个函数能根据16位语言代码获取一种语言的名称<br />
VerQueryValue 这个函数用于从版本资源中获取信息<br />
WriteFile 将数据写入一个文件<br />
WriteFileEx 与WriteFile类似，只是它只能用于异步写操作，并包括了一个完整的回调<br />
WritePrivateProfileSection 为一个初始化文件（.ini）中指定的小节设置所有项名和值<br />
WritePrivateProfileString 在初始化文件指定小节内设置一个字串<br />
WriteProfileSection 为Win.ini初始化文件中一个指定的小节设置所有项名和值<br />
WriteProfileString 在Win.ini初始化文件指定小节内设置一个字串</p>
<p>4. API之打印函数<br />
AbortDoc 取消一份文档的打印<br />
AbortPrinter 删除与一台打印机关联在一起的缓冲文件<br />
AddForm 为打印机的表单列表添加一个新表单<br />
AddJob 用于获取一个有效的路径名，以便用它为作业创建一个后台打印文件。它也会为作业分配一个作业编号<br />
AddMonitor 为系统添加一个打印机监视器<br />
AddPort 启动“添加端口”对话框，允许用户在系统可用端口列表中加入一个新端口<br />
AddPrinter 在系统中添加一台新打印机<br />
AddPrinterConnection 连接指定的打印机<br />
AddPrinterDriver 为指定的系统添加一个打印驱动程序<br />
AddPrintProcessor 为指定的系统添加一个打印处理器<br />
AddPrintProvidor 为系统添加一个打印供应商<br />
AdvancedDocumentProperties 启动打印机文档设置对话框<br />
ClosePrinter 关闭一个打开的打印机对象<br />
ConfigurePort 针对指定的端口，启动一个端口配置对话框<br />
ConnectToPrinterDlg 启动连接打印机对话框，用它同访问网络的打印机连接<br />
DeleteForm 从打印机可用表单列表中删除一个表单<br />
DeleteMonitor 删除指定的打印监视器<br />
DeletePort 启动“删除端口”对话框，允许用户从当前系统删除一个端口<br />
DeletePrinter 将指定的打印机标志为从系统中删除<br />
DeletePrinterConnection 删除与指定打印机的连接<br />
DeletePrinterDriver 从系统删除一个打印机驱动程序<br />
DeletePrintProcessor 从指定系统删除一个打印处理器<br />
DeletePrintProvidor 从系统中删除一个打印供应商<br />
DeviceCapabilities 利用这个函数可获得与一个设备的能力有关的信息<br />
DocumentProperties 打印机配置控制函数<br />
EndDocAPI 结束一个成功的打印作业<br />
EndDocPrinter 在后台打印程序的级别指定一个文档的结束<br />
EndPage 用这个函数完成一个页面的打印，并准备设备场景，以便打印下一个页<br />
EndPagePrinter 指定一个页在打印作业中的结尾<br />
EnumForms 枚举一台打印机可用的表单<br />
EnumJobs 枚举打印队列中的作业<br />
EnumMonitors 枚举可用的打印监视器<br />
EnumPorts 枚举一个系统可用的端口<br />
EnumPrinterDrivers 枚举指定系统中已安装的打印机驱动程序<br />
EnumPrinters 枚举系统中安装的打印机<br />
EnumPrintProcessorDatatypes 枚举由一个打印处理器支持的数据类型<br />
EnumPrintProcessors 枚举系统中可用的打印处理器<br />
Escape 设备控制函数<br />
FindClosePrinterChangeNotification 关闭用FindFirstPrinterChangeNotification函数获取的一个打印机通告对象<br />
FindFirstPrinterChangeNotification 创建一个新的改变通告对象，以便我们注意打印机状态的各种变化<br />
FindNextPrinterChangeNotification 用这个函数判断触发一次打印机改变通告信号的原因<br />
FreePrinterNotifyInfo 释放由FindNextPrinterChangeNotification函数分配的一个缓冲区<br />
GetForm 取得与指定表单有关的信息<br />
GetJob 获取与指定作业有关的信息<br />
GetPrinter 取得与指定打印机有关的信息<br />
GetPrinterData 为打印机设置注册表配置信息<br />
GetPrinterDriver 针对指定的打印机，获取与打印机驱动程序有关的信息<br />
GetPrinterDriverDirectory 判断指定系统中包含了打印机驱动程序的目录是什么<br />
GetPrintProcessorDirectory 判断指定系统中包含了打印机处理器驱动程序及文件的目录<br />
OpenPrinter 打开指定的打印机，并获取打印机的句柄<br />
PrinterMessageBox 在拥有指定打印作业的系统上显示一个打印机出错消息框<br />
PrinterProperties 启动打印机属性对话框，以便对打印机进行配置<br />
ReadPrinter 从打印机读入数据<br />
ResetDC 重设一个设备场景<br />
ResetPrinter 改变指定打印机的默认数据类型及文档设置<br />
ScheduleJob 提交一个要打印的作业<br />
SetAbortProc 为Windows指定取消函数的地址<br />
SetForm 为指定的表单设置信息<br />
SetJob 对一个打印作业的状态进行控制<br />
SetPrinter 对一台打印机的状态进行控制<br />
SetPrinterData 设置打印机的注册表配置信息<br />
StartDoc 开始一个打印作业<br />
StartDocPrinter 在后台打印的级别启动一个新文档<br />
StartPage 打印一个新页前要先调用这个函数<br />
StartPagePrinter 在打印作业中指定一个新页的开始<br />
WritePrinter 将发送目录中的数据写入打印机</p>
<p>5. API之文本和字体函数</p>
<p>AddFontResource 在Windows系统中添加一种字体资源<br />
CreateFont 用指定的属性创建一种逻辑字体<br />
CreateFontIndirect 用指定的属性创建一种逻辑字体<br />
CreateScalableFontResource 为一种TureType字体创建一个资源文件，以便能用API函数AddFontResource将其加入Windows系统<br />
DrawText 将文本描绘到指定的矩形中<br />
DrawTextEx 与DrawText相似，只是加入了更多的功能<br />
EnumFontFamilies 列举指定设备可用的字体<br />
EnumFontFamiliesEx 列举指定设备可用的字体<br />
EnumFonts 列举指定设备可用的字体<br />
ExtTextOut 经过扩展的文本描绘函数。也请参考SetTextAlign函数<br />
GetAspectRatioFilterEx 用SetMapperFlags要求Windows只选择与设备当前纵横比相符的光栅字体时，本函数可判断纵横比大小<br />
GetCharABCWidths 判断TureType字体中一个或多个字符的A-B-C大小<br />
GetCharABCWidthsFloat 查询一种字体中一个或多个字符的A-B-C尺寸<br />
GetCharacterPlacement 该函数用于了解如何用一个给定的字符显示一个字串<br />
GetCharWidth 调查字体中一个或多个字符的宽度<br />
GetFontData 接收一种可缩放字体文件的数据<br />
GetFontLanguageInfo 返回目前选入指定设备场景中的字体的信息<br />
GetGlyphOutline 取得TureType字体中构成一个字符的曲线信息<br />
GetKerningPairs 取得指定字体的字距信息<br />
GetOutlineTextMetrics 接收与TureType字体内部特征有关的详细信息<br />
GetRasterizerCaps 了解系统是否有能力支持可缩放的字体<br />
GetTabbedTextExtent 判断一个字串占据的范围，同时考虑制表站扩充的因素<br />
GetTextAlign 接收一个设备场景当前的文本对齐标志<br />
GetTextCharacterExtra 判断额外字符间距的当前值<br />
GetTextCharset 接收当前选入指定设备场景的字体的字符集标识符<br />
GetTextCharsetInfo 获取与当前选定字体的字符集有关的详细信息<br />
GetTextColor 判断当前字体颜色。通常也称为“前景色”<br />
GetTextExtentExPoint 判断要填入指定区域的字符数量。也用一个数组装载每个字符的范围信息<br />
GetTextExtentPoint 判断一个字串的大小（范围）<br />
GetTextFace 获取一种字体的字样名<br />
GetTextMetrics 获取与选入一种设备场景的物理字体有关的信息<br />
GrayString 描绘一个以灰色显示的字串。通常由Windows用于标识禁止状态<br />
PolyTextOut 描绘一系列字串<br />
RemoveFontResource 从Windows系统中删除一种字体资源<br />
SetMapperFlags Windows对字体进行映射时，可用该函数选择与目标设备的纵横比相符的光栅字体<br />
SetTextAlign 设置文本对齐方式，并指定在文本输出过程中使用设备场景的当前位置<br />
SetTextCharacterExtra 描绘文本的时候，指定要在字符间插入的额外间距<br />
SetTextColor 设置当前文本颜色。这种颜色也称为“前景色”<br />
SetTextJustification 通过指定一个文本行应占据的额外空间，可用这个函数对文本进行两端对齐处理<br />
TabbedTextOut 支持制表站的一个文本描绘函数<br />
TextOut 文本绘图函数</p>
<p>6. API之菜单函数</p>
<p>AppendMenu 在指定的菜单里添加一个菜单项<br />
CheckMenuItem 复选或撤消复选指定的菜单条目<br />
CheckMenuRadioItem 指定一个菜单条目被复选成“单选”项目<br />
CreateMenu 创建新菜单<br />
CreatePopupMenu 创建一个空的弹出式菜单<br />
DeleteMenu 删除指定的菜单条目<br />
DestroyMenu 删除指定的菜单<br />
DrawMenuBar 为指定的窗口重画菜单<br />
EnableMenuItem 允许或禁止指定的菜单条目<br />
GetMenu 取得窗口中一个菜单的句柄<br />
GetMenuCheckMarkDimensions 返回一个菜单复选符的大小<br />
GetMenuContextHelpId 取得一个菜单的帮助场景ID<br />
GetMenuDefaultItem 判断菜单中的哪个条目是默认条目<br />
GetMenuItemCount 返回菜单中条目（菜单项）的数量<br />
GetMenuItemID 返回位于菜单中指定位置处的条目的菜单ID<br />
GetMenuItemInfo 取得（接收）与一个菜单条目有关的特定信息<br />
GetMenuItemRect 在一个矩形中装载指定菜单条目的屏幕坐标信息<br />
GetMenuState 取得与指定菜单条目状态有关的信息<br />
GetMenuString 取得指定菜单条目的字串<br />
GetSubMenu 取得一个弹出式菜单的句柄，它位于菜单中指定的位置<br />
GetSystemMenu 取得指定窗口的系统菜单的句柄<br />
HiliteMenuItem 控制顶级菜单条目的加亮显示状态<br />
InsertMenu 在菜单的指定位置处插入一个菜单条目，并根据需要将其他条目向下移动<br />
InsertMenuItem 插入一个新菜单条目<br />
IsMenu 判断指定的句柄是否为一个菜单的句柄<br />
LoadMenu 从指定的模块或应用程序实例中载入一个菜单<br />
LoadMenuIndirect 载入一个菜单<br />
MenuItemFromPoint 判断哪个菜单条目包含了屏幕上一个指定的点<br />
ModifyMenu 改变菜单条目<br />
RemoveMenu 删除指定的菜单条目<br />
SetMenu 设置窗口菜单<br />
SetMenuContextHelpId 设置一个菜单的帮助场景ID<br />
SetMenuDefaultItem 将一个菜单条目设为默认条目<br />
SetMenuItemBitmaps 设置一幅特定位图，令其在指定的菜单条目中使用，代替标准的复选符号（√）<br />
SetMenuItemInfo 为一个菜单条目设置指定的信息<br />
TrackPopupMenu 在屏幕的任意地方显示一个弹出式菜单<br />
TrackPopupMenuEx 与TrackPopupMenu相似，只是它提供了额外的功能</p>
<p>7. API之位图、图标和光栅运算函数<br />
BitBlt 将一幅位图从一个设备场景复制到另一个<br />
CopyIcon 制作指定图标或鼠标指针的一个副本。这个副本从属于发出调用的应用程序<br />
CopyImage 复制位图、图标或指针，同时在复制过程中进行一些转换工作<br />
CreateBitmap 按照规定的格式创建一幅与设备有关位图<br />
CreateBitmapIndirect 创建一幅与设备有关位图<br />
CreateCompatibleBitmap 创建一幅与设备有关位图，它与指定的设备场景兼容<br />
CreateCursor 创建一个鼠标指针<br />
CreateDIBitmap 根据一幅与设备无关的位图创建一幅与设备有关的位图<br />
CreateDIBSection 创建一个DIBSection<br />
CreateIcon 创建一个图标<br />
CreateIconIndirect 创建一个图标<br />
DestroyCursor 清除指定的鼠标指针，并释放它占用的所有系统资源<br />
DestroyIcon 清除图标<br />
DrawIcon 在指定的位置画一个图标<br />
DrawIconEx 描绘一个图标或鼠标指针。与DrawIcon相比，这个函数提供了更多的功能<br />
ExtractAssociatedIcon 判断一个可执行程序或DLL中是否存在图标，或是否有图标与系统注册表中指定的文件存在关联并提取之<br />
ExtractIcon 判断一个可执行文件或DLL中是否有图标存在，并将其提取出来<br />
GetBitmapBits 将来自位图的二进制位复制到一个缓冲区<br />
GetBitmapDimensionEx 取得一幅位图的宽度和高度<br />
GetDIBColorTable 从选入设备场景的DIBSection中取得颜色表信息<br />
GetDIBits 将来自一幅位图的二进制位复制到一幅与设备无关的位图里<br />
GetIconInfo 取得与图标有关的信息<br />
GetStretchBltMode 判断StretchBlt 和 StretchDIBits函数采用的伸缩模式<br />
LoadBitmap 从指定的模块或应用程序实例中载入一幅位图<br />
LoadCursor 从指定的模块或应用程序实例中载入一个鼠标指针<br />
LoadCursorFromFile 在一个指针文件或一个动画指针文件的基础上创建一个指针<br />
LoadIcon 从指定的模块或应用程序实例中载入一个图标<br />
LoadImage 载入一个位图、图标或指针<br />
MaskBlt 执行复杂的图象传输，同时进行掩模（MASK）处理<br />
PatBlt 在当前选定的刷子的基础上，用一个图案填充指定的设备场景<br />
PlgBlt 复制一幅位图，同时将其转换成一个平行四边形。利用它可对位图进行旋转处理<br />
SetBitmapBits 将来自缓冲区的二进制位复制到一幅位图<br />
SetBitmapDimensionEx 设置一幅位图的宽度。以一毫米的十分之一为单位<br />
SetDIBColorTable 设置选入设备场景的一个DIBSection的颜色表信息<br />
SetDIBits 将来自与设备无关位图的二进制位复制到一幅与设备有关的位图里<br />
SetDIBitsToDevice 将一幅与设备无关位图的全部或部分数据直接复制到一个设备<br />
SetStretchBltMode 指定StretchBlt 和 StretchDIBits函数的伸缩模式<br />
StretchBlt 将一幅位图从一个设备场景复制到另一个<br />
StretchDIBits 将一幅与设备无关位图的全部或部分数据直接复制到指定的设备场景</p>
<p>8. API之绘图函数</p>
<p>AbortPath 抛弃选入指定设备场景中的所有路径。也取消目前正在进行的任何路径的创建工作<br />
AngleArc 用一个连接弧画一条线<br />
Arc 画一个圆弧<br />
BeginPath 启动一个路径分支<br />
CancelDC 取消另一个线程里的长时间绘图操作<br />
Chord 画一个弦<br />
CloseEnhMetaFile 关闭指定的增强型图元文件设备场景，并将新建的图元文件返回一个句柄<br />
CloseFigure 描绘到一个路径时，关闭当前打开的图形<br />
CloseMetaFile 关闭指定的图元文件设备场景，并向新建的图元文件返回一个句柄<br />
CopyEnhMetaFile 制作指定增强型图元文件的一个副本（拷贝）<br />
CopyMetaFile 制作指定（标准）图元文件的一个副本<br />
CreateBrushIndirect 在一个LOGBRUSH数据结构的基础上创建一个刷子</p>
<p>CreateDIBPatternBrush 用一幅与设备无关的位图创建一个刷子，以便指定刷子样式（图案）<br />
CreateEnhMetaFile 创建一个增强型的图元文件设备场景<br />
CreateHatchBrush 创建带有阴影图案的一个刷子<br />
CreateMetaFile 创建一个图元文件设备场景<br />
CreatePatternBrush 用指定了刷子图案的一幅位图创建一个刷子<br />
CreatePen 用指定的样式、宽度和颜色创建一个画笔<br />
CreatePenIndirect 根据指定的LOGPEN结构创建一个画笔<br />
CreateSolidBrush 用纯色创建一个刷子<br />
DeleteEnhMetaFile 删除指定的增强型图元文件<br />
DeleteMetaFile 删除指定的图元文件<br />
DeleteObject 删除GDI对象，对象使用的所有系统资源都会被释放<br />
DrawEdge 用指定的样式描绘一个矩形的边框<br />
DrawEscape 换码（Escape）函数将数据直接发至显示设备驱动程序<br />
DrawFocusRect 画一个焦点矩形<br />
DrawFrameControl 描绘一个标准控件<br />
DrawState 为一幅图象或绘图操作应用各式各样的效果<br />
Ellipse 描绘一个椭圆，由指定的矩形围绕<br />
EndPath 停止定义一个路径<br />
EnumEnhMetaFile 针对一个增强型图元文件，列举其中单独的图元文件记录<br />
EnumMetaFile 为一个标准的windows图元文件枚举单独的图元文件记录<br />
EnumObjects 枚举可随同指定设备场景使用的画笔和刷子<br />
ExtCreatePen 创建一个扩展画笔（装饰或几何）<br />
ExtFloodFill 在指定的设备场景里，用当前选择的刷子填充一个区域<br />
FillPath 关闭路径中任何打开的图形，并用当前刷子填充<br />
FillRect 用指定的刷子填充一个矩形<br />
FlattenPath 将一个路径中的所有曲线都转换成线段<br />
FloodFill 用当前选定的刷子在指定的设备场景中填充一个区域<br />
FrameRect 用指定的刷子围绕一个矩形画一个边框<br />
GdiComment 为指定的增强型图元文件设备场景添加一条注释信息<br />
GdiFlush 执行任何未决的绘图操作<br />
GdiGetBatchLimit 判断有多少个GDI绘图命令位于队列中<br />
GdiSetBatchLimit 指定有多少个GDI绘图命令能够进入队列<br />
GetArcDirection 画圆弧的时候，判断当前采用的绘图方向<br />
GetBkColor 取得指定设备场景当前的背景颜色<br />
GetBkMode 针对指定的设备场景，取得当前的背景填充模式<br />
GetBrushOrgEx 判断指定设备场景中当前选定刷子起点<br />
GetCurrentObject 获得指定类型的当前选定对象<br />
GetCurrentPositionEx 在指定的设备场景中取得当前的画笔位置<br />
GetEnhMetaFile 取得磁盘文件中包含的一个增强型图元文件的图元文件句柄<br />
GetEnhMetaFileBits 将指定的增强型图元文件复制到一个内存缓冲区里<br />
GetEnhMetaFileDescription 返回对一个增强型图元文件的说明<br />
GetEnhMetaFileHeader 取得增强型图元文件的图元文件头<br />
GetEnhMetaFilePaletteEntries 取得增强型图元文件的全部或部分调色板<br />
GetMetaFile 取得包含在一个磁盘文件中的图元文件的图元文件句柄<br />
GetMetaFileBitsEx 将指定的图元文件复制到一个内存缓冲区<br />
GetMiterLimit 取得设备场景的斜率限制（Miter）设置<br />
GetNearestColor 根据设备的显示能力，取得与指定颜色最接近的一种纯色<br />
GetObjectAPI 取得对指定对象进行说明的一个结构<br />
GetObjectType 判断由指定句柄引用的GDI对象的类型<br />
GetPath 取得对当前路径进行定义的一系列数据<br />
GetPixel 在指定的设备场景中取得一个像素的RGB值<br />
GetPolyFillMode 针对指定的设备场景，获得多边形填充模式<br />
GetROP2 针对指定的设备场景，取得当前的绘图模式<br />
GetStockObject 取得一个固有对象（Stock）<br />
GetSysColorBrush 为任何一种标准系统颜色取得一个刷子<br />
GetWinMetaFileBits 通过在一个缓冲区中填充用于标准图元文件的数据，将一个增强型图元文件转换成标准windows图元文件<br />
InvertRect 通过反转每个像素的值，从而反转一个设备场景中指定的矩形<br />
LineDDA 枚举指定线段中的所有点<br />
LineTo 用当前画笔画一条线，从当前位置连到一个指定的点<br />
MoveToEx 为指定的设备场景指定一个新的当前画笔位置<br />
PaintDesk 在指定的设备场景中描绘桌面墙纸图案<br />
PathToRegion 将当前选定的路径转换到一个区域里<br />
Pie 画一个饼图<br />
PlayEnhMetaFile 在指定的设备场景中画一个增强型图元文件<br />
PlayEnhMetaFileRecord 回放单独一条增强型图元文件记录<br />
PlayMetaFile 在指定的设备场景中回放一个图元文件<br />
PlayMetaFileRecord 回放来自图元文件的单条记录<br />
PolyBezier 描绘一条或多条贝塞尔（Bezier）曲线<br />
PolyDraw 描绘一条复杂的曲线，由线段及贝塞尔曲线组成<br />
Polygon 描绘一个多边形<br />
Polyline 用当前画笔描绘一系列线段<br />
PolyPolygon 用当前选定画笔描绘两个或多个多边形<br />
PolyPolyline 用当前选定画笔描绘两个或多个多边形<br />
Rectangle 用当前选定的画笔描绘矩形，并用当前选定的刷子填充<br />
RoundRect 用当前选定的画笔画一个圆角矩形，并用当前选定的刷子在其中填充<br />
SelectClipPath 将设备场景当前的路径合并到剪切区域里<br />
SelectObject 为当前设备场景选择图形对象<br />
SetArcDirection 设置圆弧的描绘方向<br />
SetBkColor 为指定的设备场景设置背景颜色<br />
SetBkMode 指定阴影刷子、虚线画笔以及字符中的空隙的填充方式<br />
SetBrushOrgEx 为指定的设备场景设置当前选定刷子的起点<br />
SetEnhMetaFileBits 用指定内存缓冲区内包含的数据创建一个增强型图元文件<br />
SetMetaFileBitsEx 用包含在指定内存缓冲区内的数据结构创建一个图元文件<br />
SetMiterLimit 设置设备场景当前的斜率限制<br />
SetPixel 在指定的设备场景中设置一个像素的RGB值<br />
SetPixelV 在指定的设备场景中设置一个像素的RGB值<br />
SetPolyFillMode 设置多边形的填充模式<br />
SetROP2 设置指定设备场景的绘图模式。与vb的DrawMode属性完全一致<br />
SetWinMetaFileBits 将一个标准Windows图元文件转换成增强型图元文件<br />
StrokeAndFillPath 针对指定的设备场景，关闭路径上打开的所有区域<br />
StrokePath 用当前画笔描绘一个路径的轮廓。打开的图形不会被这个函数关闭<br />
UnrealizeObject 将一个刷子对象选入设备场景之前，如刷子的起点准备用SetBrushOrgEx修改，则必须先调用本函数<br />
WidenPath 根据选定画笔的宽度，重新定义当前选定的路径</p>
<p>9. API之设备场景函数</p>
<p>CombineRgn 将两个区域组合为一个新区域<br />
CombineTransform 驱动世界转换。它相当于依顺序进行两次转换<br />
CreateCompatibleDC 创建一个与特定设备场景一致的内存设备场景<br />
CreateDC 为专门设备创建设备场景<br />
CreateEllipticRgn 创建一个椭圆<br />
CreateEllipticRgnIndirect 创建一个内切于特定矩形的椭圆区域<br />
CreateIC 为专用设备创建一个信息场景<br />
CreatePolygonRgn 创建一个由一系列点围成的区域<br />
CreatePolyPolygonRgn 创建由多个多边形构成的区域。每个多边形都应是封闭的<br />
CreateRectRgn 创建一个矩形区域<br />
CreateRectRgnIndirect 创建一个矩形区域<br />
CreateRoundRectRgn 创建一个圆角矩形<br />
DeleteDC 删除专用设备场景或信息场景，释放所有相关窗口资源<br />
DPtoLP 将点阵从设备坐标转换到专用设备场景逻辑坐标<br />
EqualRgn 确定两个区域是否相等<br />
ExcludeClipRect 从专用设备场景的剪裁区中去掉一个矩形区。矩形内不能进行绘图<br />
ExcludeUpdateRgn 从专用设备场景剪裁区去掉指定窗口的刷新区域<br />
ExtCreateRegion 根据世界转换修改区域<br />
ExtSelectClipRgn 将指定区域组合到设备场景的当前剪裁区<br />
FillRgn 用指定刷子填充指定区域<br />
FrameRgn 用指定刷子围绕指定区域画一个外框<br />
GetBoundsRect 获取指定设备场景的边界矩形<br />
GetClipBox 获取完全包含指定设备场景剪裁区的最小矩形<br />
GetClipRgn 获取设备场景当前剪裁区<br />
GetDC 获取指定窗口的设备场景<br />
GetDCEx 为指定窗口获取设备场景。相比GetDC，本函数提供了更多的选项<br />
GetDCOrgEx 获取指定设备场景起点位置（以屏幕坐标表示）<br />
GetDeviceCaps 根据指定设备场景代表的设备的功能返回信息<br />
GetGraphicsMode 确定是否允许增强图形模式（世界转换）<br />
GetMapMode 为特定设备场景调入映象模式<br />
GetRegionData 装入描述一个区域信息的RgnData结构或缓冲区<br />
GetRgnBox 获取完全包含指定区域的最小矩形<br />
GetUpdateRgn 确定指定窗口的刷新区域。该区域当前无效，需要刷新<br />
GetViewportExtEx 获取设备场景视口（viewport）范围<br />
GetViewportOrgEx 获取设备场景视口起点<br />
GetWindowDC 获取整个窗口（包括边框、滚动条、标题栏、菜单等）的设备场景<br />
GetWindowExtEx 获取指定设备场景的窗口范围<br />
GetWindowOrgEx 获取指定设备场景的逻辑窗口的起点<br />
GetWindowRgn 获取窗口区域<br />
GetWorldTransform 如果有世界转换，为设备场景获取当前世界转换<br />
IntersectClipRect 为指定设备定义一个新的剪裁区<br />
InvalidateRgn 使窗口指定区域不活动，并将它加入窗口刷新区，使之可随后被重画<br />
InvertRgn 通过颠倒每个像素值反转设备场景指定区域<br />
LPtoDP 将点阵从指定设备场景逻辑坐标转换为设备坐标<br />
ModifyWorldTransform 根据指定的模式修改世界转换<br />
OffsetClipRgn 按指定量平移设备场景剪裁区<br />
OffsetRgn 按指定偏移量平移指定区域<br />
OffsetViewportOrgEx 平移设备场景视口区域<br />
OffsetWindowOrgEx 平移指定设备场景窗口起点<br />
PaintRgn 用当前刷子背景色填充指定区域<br />
PtInRegion 确定点是否在指定区域内<br />
PtVisible 确定指定点是否可见（即，点是否在设备场景剪裁区内）<br />
RectInRegion 确定矩形是否有部分在指定区域内<br />
RectVisible 确定指定矩形是否有部分可见（是否在设备场景剪裁区内）<br />
ReleaseDC 释放由调用GetDC或GetWindowDC函数获取的指定设备场景<br />
RestoreDC 从设备场景堆栈恢复一个原先保存的设备场景<br />
SaveDC 将指定设备场景状态保存到Windows设备场景堆栈<br />
ScaleViewportExtEx 缩放设备场景视口的范围<br />
ScaleWindowExtEx 缩放指定设备场景窗口范围<br />
ScrollDC 在窗口（由设备场景代表）中水平和（或）垂直滚动矩形<br />
SelectClipRgn 为指定设备场景选择新的剪裁区<br />
SetBoundsRect 设置指定设备场景的边界矩形<br />
SetGraphicsMode 允许或禁止增强图形模式，以提供某些支持（包括世界转换）<br />
SetMapMode 设置指定设备场景的映射模式<br />
SetRectRgn 设置区域为指定的矩形<br />
SetViewportExtEx 设置设备场景视口范围<br />
SetViewportOrgEx 设置设备场景视口起点<br />
SetWindowExtEx 设置指定设备场景窗口范围<br />
SetWindowOrgEx 设置指定设备场景窗口起点<br />
SetWindowRgn 设置窗口区域<br />
SetWorldTransform 设置世界转换<br />
ValidateRgn 激活窗口中指定区域，把它从刷新区移走<br />
WindowFromDC 取回与某一设备场景相关的窗口的句柄</p>
<p>10. API之硬件与系统函数<br />
ActivateKeyboardLayout 激活一个新的键盘布局。键盘布局定义了按键在一种物理性键盘上的位置与含义<br />
Beep 用于生成简单的声音<br />
CharToOem 将一个字串从ANSI字符集转换到OEM字符集<br />
ClipCursor 将指针限制到指定区域<br />
ConvertDefaultLocale 将一个特殊的地方标识符转换成真实的地方ID<br />
CreateCaret 根据指定的信息创建一个插入符（光标），并将它选定为指定窗口的默认插入符<br />
DestroyCaret 清除（破坏）一个插入符<br />
EnumCalendarInfo 枚举在指定“地方”环境中可用的日历信息<br />
EnumDateFormats 列举指定的“当地”设置中可用的长、短日期格式<br />
EnumSystemCodePages 枚举系统中已安装或支持的代码页<br />
EnumSystemLocales 枚举系统已经安装或提供支持的“地方”设置<br />
EnumTimeFormats 枚举一个指定的地方适用的时间格式<br />
ExitWindowsEx 退出windows，并用特定的选项重新启动<br />
ExpandEnvironmentStrings 扩充环境字串<br />
FreeEnvironmentStrings 翻译指定的环境字串块<br />
GetACP 判断目前正在生效的ANSI代码页<br />
GetAsyncKeyState 判断函数调用时指定虚拟键的状态<br />
GetCaretBlinkTime 判断插入符光标的闪烁频率<br />
GetCaretPos 判断插入符的当前位置<br />
GetClipCursor 取得一个矩形，用于描述目前为鼠标指针规定的剪切区域<br />
GetCommandLine 获得指向当前命令行缓冲区的一个指针<br />
GetComputerName 取得这台计算机的名称<br />
GetCPInfo 取得与指定代码页有关的信息<br />
GetCurrencyFormat 针对指定的“地方”设置，根据货币格式格式化一个数字<br />
GetCursor 获取目前选择的鼠标指针的句柄<br />
GetCursorPos 获取鼠标指针的当前位置<br />
GetDateFormat 针对指定的“当地”格式，对一个系统日期进行格式化<br />
GetDoubleClickTime 判断连续两次鼠标单击之间会被处理成双击事件的间隔时间<br />
GetEnvironmentStrings 为包含了当前环境字串设置的一个内存块分配和返回一个句柄<br />
GetEnvironmentVariable 取得一个环境变量的值<br />
GetInputState 判断是否存在任何待决（等待处理）的鼠标或键盘事件<br />
GetKBCodePage 由GetOEMCP取代，两者功能完全相同<br />
GetKeyboardLayout 取得一个句柄，描述指定应用程序的键盘布局<br />
GetKeyboardLayoutList 获得系统适用的所有键盘布局的一个列表<br />
GetKeyboardLayoutName 取得当前活动键盘布局的名称<br />
GetKeyboardState 取得键盘上每个虚拟键当前的状态<br />
GetKeyboardType 了解与正在使用的键盘有关的信息<br />
GetKeyNameText 在给出扫描码的前提下，判断键名<br />
GetKeyState 针对已处理过的按键，在最近一次输入信息时，判断指定虚拟键的状态<br />
GetLastError 针对之前调用的api函数，用这个函数取得扩展错误信息<br />
GetLocaleInfo 取得与指定“地方”有关的信息<br />
GetLocalTime 取得本地日期和时间<br />
GetNumberFormat 针对指定的“地方”，按特定的格式格式化一个数字<br />
GetOEMCP 判断在OEM和ANSI字符集间转换的windows代码页<br />
GetQueueStatus 判断应用程序消息队列中待决（等待处理）的消息类型<br />
GetSysColor 判断指定windows显示对象的颜色<br />
GetSystemDefaultLangID 取得系统的默认语言ID<br />
GetSystemDefaultLCID 取得当前的默认系统“地方”<br />
GetSystemInfo 取得与底层硬件平台有关的信息<br />
GetSystemMetrics 返回与windows环境有关的信息<br />
GetSystemPowerStatus 获得与当前系统电源状态有关的信息<br />
GetSystemTime 取得当前系统时间，这个时间采用的是“协同世界时间”（即UTC，也叫做GMT）格式<br />
GetSystemTimeAdjustment 使内部系统时钟与一个外部的时钟信号源同步<br />
GetThreadLocale 取得当前线程的地方ID<br />
GetTickCount 用于获取自windows启动以来经历的时间长度（毫秒）<br />
GetTimeFormat 针对当前指定的“地方”，按特定的格式格式化一个系统时间<br />
GetTimeZoneInformation 取得与系统时区设置有关的信息<br />
GetUserDefaultLangID 为当前用户取得默认语言ID<br />
GetUserDefaultLCID 取得当前用户的默认“地方”设置<br />
GetUserName 取得当前用户的名字<br />
GetVersion 判断当前运行的Windows和DOS版本<br />
GetVersionEx 取得与平台和操作系统有关的版本信息<br />
HideCaret 在指定的窗口隐藏插入符（光标）<br />
IsValidCodePage 判断一个代码页是否有效<br />
IsValidLocale 判断地方标识符是否有效<br />
keybd_event 这个函数模拟了键盘行动<br />
LoadKeyboardLayout 载入一个键盘布局<br />
MapVirtualKey 根据指定的映射类型，执行不同的扫描码和字符转换<br />
MapVirtualKeyEx 根据指定的映射类型，执行不同的扫描码和字符转换<br />
MessageBeep 播放一个系统声音。系统声音的分配方案是在控制面板里决定的<br />
mouse_event 模拟一次鼠标事件<br />
OemKeyScan 判断OEM字符集中的一个ASCII字符的扫描码和Shift键状态<br />
OemToChar 将OEM字符集的一个字串转换到ANSI字符集<br />
SetCaretBlinkTime 指定插入符（光标）的闪烁频率<br />
SetCaretPos 指定插入符的位置<br />
SetComputerName 设置新的计算机名<br />
SetCursor 将指定的鼠标指针设为当前指针<br />
SetCursorPos 设置指针的位置<br />
SetDoubleClickTime 设置连续两次鼠标单击之间能使系统认为是双击事件的间隔时间<br />
SetEnvironmentVariable 将一个环境变量设为指定的值<br />
SetKeyboardState 设置每个虚拟键当前在键盘上的状态<br />
SetLocaleInfo 改变用户“地方”设置信息<br />
SetLocalTime 设置当前地方时间<br />
SetSysColors 设置指定窗口显示对象的颜色<br />
SetSystemCursor 改变任何一个标准系统指针<br />
SetSystemTime 设置当前系统时间<br />
SetSystemTimeAdjustment 定时添加一个校准值使内部系统时钟与一个外部的时钟信号源同步<br />
SetThreadLocale 为当前线程设置地方<br />
SetTimeZoneInformation 设置系统时区信息<br />
ShowCaret 在指定的窗口里显示插入符（光标）<br />
ShowCursor 控制鼠标指针的可视性<br />
SwapMouseButton 决定是否互换鼠标左右键的功能<br />
SystemParametersInfo 获取和设置数量众多的windows系统参数<br />
SystemTimeToTzSpecificLocalTime 将系统时间转换成地方时间<br />
ToAscii 根据当前的扫描码和键盘信息，将一个虚拟键转换成ASCII字符<br />
ToUnicode 根据当前的扫描码和键盘信息，将一个虚拟键转换成Unicode字符<br />
UnloadKeyboardLayout 卸载指定的键盘布局<br />
VkKeyScan 针对Windows字符集中一个ASCII字符，判断虚拟键码和Shift键的状态</p>
<p>11. API之进程和线程函数</p>
<p>CancelWaitableTimer 这个函数用于取消一个可以等待下去的计时器操作<br />
CallNamedPipe 这个函数由一个希望通过管道通信的一个客户进程调用<br />
ConnectNamedPipe 指示一台服务器等待下去，直至客户机同一个命名管道连接<br />
CreateEvent 创建一个事件对象<br />
CreateMailslot 创建一个邮路。返回的句柄由邮路服务器使用（收件人）<br />
CreateMutex 创建一个互斥体（MUTEX）<br />
CreateNamedPipe 创建一个命名管道。返回的句柄由管道的服务器端使用<br />
CreatePipe 创建一个匿名管道<br />
CreateProcess 创建一个新进程（比如执行一个程序）<br />
CreateSemaphore 创建一个新的信号机<br />
CreateWaitableTimer 创建一个可等待的计时器对象<br />
DisconnectNamedPipe 断开一个客户与一个命名管道的连接<br />
DuplicateHandle 在指出一个现有系统对象当前句柄的情况下，为那个对象创建一个新句柄<br />
ExitProcess 中止一个进程<br />
FindCloseChangeNotification 关闭一个改动通知对象<br />
FindExecutable 查找与一个指定文件关联在一起的程序的文件名<br />
FindFirstChangeNotification 创建一个文件通知对象。该对象用于监视文件系统发生的变化<br />
FindNextChangeNotification 重设一个文件改变通知对象，令其继续监视下一次变化<br />
FreeLibrary 释放指定的动态链接库<br />
GetCurrentProcess 获取当前进程的一个伪句柄<br />
GetCurrentProcessId 获取当前进程一个唯一的标识符<br />
GetCurrentThread 获取当前线程的一个伪句柄<br />
GetCurrentThreadId 获取当前线程一个唯一的线程标识符<br />
GetExitCodeProces 获取一个已中断进程的退出代码<br />
GetExitCodeThread 获取一个已中止线程的退出代码<br />
GetHandleInformation 获取与一个系统对象句柄有关的信息<br />
GetMailslotInfo 获取与一个邮路有关的信息<br />
GetModuleFileName 获取一个已装载模板的完整路径名称<br />
GetModuleHandle 获取一个应用程序或动态链接库的模块句柄<br />
GetPriorityClass 获取特定进程的优先级别<br />
GetProcessShutdownParameters 调查系统关闭时一个指定的进程相对于其它进程的关闭早迟情况<br />
GetProcessTimes 获取与一个进程的经过时间有关的信息<br />
GetProcessWorkingSetSize 了解一个应用程序在运行过程中实际向它交付了多大容量的内存<br />
GetSartupInfo 获取一个进程的启动信息<br />
GetThreadPriority 获取特定线程的优先级别<br />
GetTheardTimes 获取与一个线程的经过时间有关的信息<br />
GetWindowThreadProcessId 获取与指定窗口关联在一起的一个进程和线程标识符<br />
LoadLibrary 载入指定的动态链接库，并将它映射到当前进程使用的地址空间<br />
LoadLibraryEx 装载指定的动态链接库，并为当前进程把它映射到地址空间<br />
LoadModule 载入一个Windows应用程序，并在指定的环境中运行<br />
MsgWaitForMultipleObjects 等侯单个对象或一系列对象发出信号。如返回条件已经满足，则立即返回<br />
SetPriorityClass 设置一个进程的优先级别<br />
SetProcessShutdownParameters 在系统关闭期间，为指定进程设置他相对于其它程序的关闭顺序<br />
SetProcessWorkingSetSize 设置操作系统实际划分给进程使用的内存容量<br />
SetThreadPriority 设定线程的优先级别<br />
ShellExecute 查找与指定文件关联在一起的程序的文件名<br />
TerminateProcess 结束一个进程<br />
WinExec 运行指定的程序</p>
<p>12. API之控件与消息函数</p>
<p>AdjustWindowRect 给定一种窗口样式，计算获得目标客户区矩形所需的窗口大小<br />
AnyPopup 判断屏幕上是否存在任何弹出式窗口<br />
ArrangeIconicWindows 排列一个父窗口的最小化子窗口<br />
AttachThreadInput 连接线程输入函数<br />
BeginDeferWindowPos 启动构建一系列新窗口位置的过程<br />
BringWindowToTop 将指定的窗口带至窗口列表顶部<br />
CascadeWindows 以层叠方式排列窗口<br />
ChildWindowFromPoint 返回父窗口中包含了指定点的第一个子窗口的句柄<br />
ClientToScreen 判断窗口内以客户区坐标表示的一个点的屏幕坐标<br />
CloseWindow 最小化指定的窗口<br />
CopyRect 矩形内容复制<br />
DeferWindowPos 该函数为特定的窗口指定一个新窗口位置<br />
DestroyWindow 清除指定的窗口以及它的所有子窗口<br />
DrawAnimatedRects 描绘一系列动态矩形<br />
EnableWindow 指定的窗口里允许或禁止所有鼠标及键盘输入<br />
EndDeferWindowPos 同时更新DeferWindowPos调用时指定的所有窗口的位置及状态<br />
EnumChildWindows 为指定的父窗口枚举子窗口<br />
EnumThreadWindows 枚举与指定任务相关的窗口<br />
EnumWindows 枚举窗口列表中的所有父窗口<br />
EqualRect 判断两个矩形结构是否相同<br />
FindWindow 寻找窗口列表中第一个符合指定条件的顶级窗口<br />
FindWindowEx 在窗口列表中寻找与指定条件相符的第一个子窗口<br />
FlashWindow 闪烁显示指定窗口<br />
GetActiveWindow 获得活动窗口的句柄<br />
GetCapture 获得一个窗口的句柄，这个窗口位于当前输入线程，且拥有鼠标捕获（鼠标活动由它接收）<br />
GetClassInfo 取得WNDCLASS结构（或WNDCLASSEX结构）的一个副本，结构中包含了与指定类有关的信息<br />
GetClassLong 取得窗口类的一个Long变量条目<br />
GetClassName 为指定的窗口取得类名<br />
GetClassWord 为窗口类取得一个整数变量<br />
GetClientRect 返回指定窗口客户区矩形的大小<br />
GetDesktopWindow 获得代表整个屏幕的一个窗口（桌面窗口）句柄<br />
GetFocus 获得拥有输入焦点的窗口的句柄<br />
GetForegroundWindow 获得前台窗口的句柄<br />
GetLastActivePopup 获得在一个给定父窗口中最近激活过的弹出式窗口的句柄<br />
GetParent 判断指定窗口的父窗口<br />
GetTopWindow 搜索内部窗口列表，寻找隶属于指定窗口的头一个窗口的句柄<br />
GetUpdateRect 获得一个矩形，它描叙了指定窗口中需要更新的那一部分<br />
GetWindow 获得一个窗口的句柄，该窗口与某源窗口有特定的关系<br />
GetWindowContextHelpId 取得与窗口关联在一起的帮助场景ID<br />
GetWindowLong 从指定窗口的结构中取得信息<br />
GetWindowPlacement 获得指定窗口的状态及位置信息<br />
GetWindowRect 获得整个窗口的范围矩形，窗口的边框、标题栏、滚动条及菜单等都在这个矩形内<br />
GetWindowText 取得一个窗体的标题（caption）文字，或者一个控件的内容<br />
GetWindowTextLength 调查窗口标题文字或控件内容的长短<br />
GetWindowWord 获得指定窗口结构的信息<br />
InflateRect 增大或减小一个矩形的大小<br />
IntersectRect 这个函数在lpDestRect里载入一个矩形，它是lpSrc1Rect与lpSrc2Rect两个矩形的交集<br />
InvalidateRect 屏蔽一个窗口客户区的全部或部分区域<br />
IsChild 判断一个窗口是否为另一窗口的子或隶属窗口<br />
IsIconic 判断窗口是否已最小化<br />
IsRectEmpty 判断一个矩形是否为空<br />
IsWindow 判断一个窗口句柄是否有效<br />
IsWindowEnabled 判断窗口是否处于活动状态<br />
IsWindowUnicode 判断一个窗口是否为Unicode窗口。这意味着窗口为所有基于文本的消息都接收Unicode文字<br />
IsWindowVisible 判断窗口是否可见<br />
IsZoomed 判断窗口是否最大化<br />
LockWindowUpdate 锁定指定窗口，禁止它更新<br />
MapWindowPoints 将一个窗口客户区坐标的点转换到另一窗口的客户区坐标系统<br />
MoveWindow 改变指定窗口的位置和大小<br />
OffsetRect 通过应用一个指定的偏移，从而让矩形移动起来<br />
OpenIcon 恢复一个最小化的程序，并将其激活<br />
PtInRect 判断指定的点是否位于矩形内部<br />
RedrawWindow 重画全部或部分窗口<br />
ReleaseCapture 为当前的应用程序释放鼠标捕获<br />
ScreenToClient 判断屏幕上一个指定点的客户区坐标<br />
ScrollWindow 滚动窗口客户区的全部或一部分<br />
ScrollWindowEx 根据附加的选项，滚动窗口客户区的全部或部分<br />
SetActiveWindow 激活指定的窗口<br />
SetCapture 将鼠标捕获设置到指定的窗口<br />
SetClassLong 为窗口类设置一个Long变量条目<br />
SetClassWord 为窗口类设置一个条目<br />
SetFocusAPI 将输入焦点设到指定的窗口。如有必要，会激活窗口<br />
SetForegroundWindow 将窗口设为系统的前台窗口<br />
SetParent 指定一个窗口的新父<br />
SetRect 设置指定矩形的内容<br />
SetRectEmpty 将矩形设为一个空矩形<br />
SetWindowContextHelpId 为指定的窗口设置帮助场景（上下文）ID<br />
SetWindowLong 在窗口结构中为指定的窗口设置信息<br />
SetWindowPlacement 设置窗口状态和位置信息<br />
SetWindowPos 为窗口指定一个新位置和状态<br />
SetWindowText 设置窗口的标题文字或控件的内容<br />
SetWindowWord 在窗口结构中为指定的窗口设置信息<br />
ShowOwnedPopups 显示或隐藏由指定窗口所有的全部弹出式窗口<br />
ShowWindow 控制窗口的可见性<br />
ShowWindowAsync 与ShowWindow相似<br />
SubtractRect 装载矩形lprcDst，它是在矩形lprcSrc1中减去lprcSrc2得到的结果<br />
TileWindows 以平铺顺序排列窗口<br />
UnionRect 装载一个lpDestRect目标矩形，它是lpSrc1Rect和lpSrc2Rect联合起来的结果<br />
UpdateWindow 强制立即更新窗口<br />
ValidateRect 校验窗口的全部或部分客户区<br />
WindowFromPoint 返回包含了指定点的窗口的句柄。忽略屏蔽、隐藏以及透明窗口</p>
<p>&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/130/feed/</wfw:commentRss>
		<slash:comments>358</slash:comments>
		</item>
		<item>
		<title>[转]Linux slab 分配器剖析</title>
		<link>http://imzc.net/archives/109/</link>
		<comments>http://imzc.net/archives/109/#comments</comments>
		<pubDate>Mon, 25 Oct 2010 08:23:02 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[C/C++]]></category>
		<category><![CDATA[slab]]></category>

		<guid isPermaLink="false">http://imzc.net/?p=109</guid>
		<description><![CDATA[了解 Linux 内存管理的方式
M. Tim Jones, 顾问工程师, Emulex
M. Tim Jones
M. Tim Jones 是一名嵌入式软件工程师，他是 GNU/Linux Application Programming、AI Application Programming 以及 BSD Sockets Programming from a Multilanguage Perspective 等书的作者。他的工程背景非常广泛，从同步宇宙飞船的内核开发到嵌入式架构设计，再到网络协议的开发。Tim 是位于科罗拉多州 Longmont 的 Emulex Corp. 的一名顾问工程师。
转自: https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/

简介： 良好的操作系统性能部分依赖于操作系统有效管理资源的能力。在过去，堆内存管理器是实际的规范，但是其性能会受到内存碎片和内存回收需求的影响。现在，Linux® 内核使用了源自于 Solaris 的一种方法，但是这种方法在嵌入式系统中已经使用了很长时间了，它是将内存作为对象按照大小进行分配。本文将探索 slab 分配器背后所采用的思想，并介绍这种方法提供的接口和用法。]]></description>
			<content:encoded><![CDATA[<p><a name="N1006B">动态内存管理</a></p>
<p>内存管理的目标是提供一种方法，为实现各种目的而在各个用户之间实现内存共享。内存管理方法应该实现以下两个功能：</p>
<ul>
<li>最小化管理内存所需的时间</li>
<li>最大化用于一般应用的可用内存（最小化管理开销）</li>
</ul>
<p>内存管理实际上是一种关于权衡的零和游戏。您可以开发一种使用少量内存进行管理的算法，但是要花费更多时间来管理可用内存。也可以开发一个算法来有效地管理内存，但却要使用更多的内存。最终，特定应用程序的需求将促使对这种权衡作出选择。</p>
<p>每个内存管理器都使用了一种基于堆的分配策略。在这种方法中，大块内存（称为 <strong>堆</strong>）用来为用户定义的目的提供内存。当用户需要一块内存时，就请求给自己分配一定大小的内存。堆管理器会查看可用内存的情况（使用特定算法）并返回一块内存。搜索过程中使用的一些算法有 <strong>first-fit</strong>（在堆中搜索到的第一个满足请求的内存块 ）和 <strong>best-fit</strong>（使用堆中满足请求的最合适的内存块）。当用户使用完内存后，就将内存返回给堆。</p>
<p>这种基于堆的分配策略的根本问题是<em>碎片（fragmentation）</em>。当内存块被分配后，它们会以不同的顺序在不同的时间返回。这样会在堆中留下一些洞，需要花一些时间才能有效地管理空闲内存。这种算法通常具有较高的内存使用效率（分配需要的内存），但是却需要花费更多时间来对堆进行管理。</p>
<p>另外一种方法称为 <strong>buddy memory allocation</strong>，是一种更快的内存分配技术，它将内 存划分为 2 的幂次方个分区，并使用 best-fit 方法来分配内存请求。当用户释放内存时，就会检查 buddy  块，查看其相邻的内存块是否也已经被释放。如果是的话，将合并内存块以最小化内存碎片。这个算法的时间效率更高，但是由于使用 best-fit  方法的缘故，会产生内存浪费。</p>
<p>本文将着重介绍 Linux 内核的内存管理，尤其是 <strong>slab 分配</strong>提供的机制。</p>
<p><a name="N1009E">slab 缓存</a></p>
<p>Linux 所使用的 slab 分配器的基础是 Jeff Bonwick 为 SunOS 操作系统首次引入的一种算法。Jeff   的分配器是围绕对象缓存进行的。在内核中，会为有限的对象集（例如文件描述符和其他常见结构）分配大量内存。Jeff  发现对内核中普通对象进行初始化所需的时间超过了对其进行分配和释放所需的时间。因此他的结论是不应该将内存释放回一个全局的内存池，而是将内存保持为针 对特定目而初始化的状态。例如，如果内存被分配给了一个互斥锁，那么只需在为互斥锁首次分配内存时执行一次互斥锁初始化函数（<code>mutex_init</code>）即可。后续的内存分配不需要执行这个初始化函数，因为从上次释放和调用析构之后，它已经处于所需的状态中了。</p>
<p>Linux slab 分配器使用了这种思想和其他一些思想来构建一个在空间和时间上都具有高效性的内存分配器。</p>
<p>图 1 给出了 slab 结构的高层组织结构。在最高层是 <code>cache_chain</code>，这是一个 slab 缓存的链接列表。这对于 best-fit 算法非常有用，可以用来查找最适合所需要的分配大小的缓存（遍历列表）。<code>cache_chain</code> 的每个元素都是一个         <code>kmem_cache</code> 结构的引用（称为一个 <strong>cache</strong>）。它定义了一个要管理的给定大小的对象池。<br />
<a name="figure1"><strong> 图  1. slab 分配器的主要结构</strong></a></p>
<p><a href="http://imzc.net/wp-content/uploads/2010/10/figure1.gif"><img class="alignleft size-medium wp-image-110" title="figure1" src="http://imzc.net/wp-content/uploads/2010/10/figure1-300x161.gif" alt="" width="300" height="179" /></a></p>
<p>每个缓存都包含了一个 <strong>slabs</strong> 列表，这是一段连续的内存块（通常都是页面）。存在 3 种 slab：</p>
<dl>
<dt><strong> <code>slabs_full</code> </strong></dt>
<dd>完全分配的 slab </dd>
<dt><strong> <code>slabs_partial</code> </strong></dt>
<dd>部分分配的 slab</dd>
<dt><strong> <code>slabs_empty</code> </strong></dt>
<dd>空 slab，或者没有对象被分配</dd>
</dl>
<p>注意 <code>slabs_empty</code> 列表中的 slab 是进行<strong>回收（reaping）</strong>的主要备选对象。正是通过此过程，slab 所使用的内存被返回给操作系统供其他用户使用。</p>
<p>slab 列表中的每个 slab  都是一个连续的内存块（一个或多个连续页），它们被划分成一个个对象。这些对象是从特定缓存中进行分配和释放的基本元素。注意 slab 是 slab  分配器进行操作的最小分配单位，因此如果需要对 slab 进行扩展，这也就是所扩展的最小值。通常来说，每个 slab 被分配为多个对象。</p>
<p>由于对象是从 slab 中进行分配和释放的，因此单个 slab 可以在 slab 列表之间进行移动。例如，当一个 slab 中的所有对象都被使用完时，就从 <code>slabs_partial</code> 列表中移动到          <code>slabs_full</code> 列表中。当一个 slab 完全被分配并且有对象被释放后，就从 <code>slabs_full</code> 列表中移动到          <code>slabs_partial</code> 列表中。当所有对象都被释放之后，就从 <code>slabs_partial</code> 列表移动到          <code>slabs_empty</code> 列表中。</p>
<p><a name="N1011E">slab 背后的动机</a></p>
<p>与传统的内存管理模式相比， slab  缓存分配器提供了很多优点。首先，内核通常依赖于对小对象的分配，它们会在系统生命周期内进行无数次分配。slab  缓存分配器通过对类似大小的对象进行缓存而提供这种功能，从而避免了常见的碎片问题。slab  分配器还支持通用对象的初始化，从而避免了为同一目而对一个对象重复进行初始化。最后，slab  分配器还可以支持硬件缓存对齐和着色，这允许不同缓存中的对象占用相同的缓存行，从而提高缓存的利用率并获得更好的性能。</p>
<div>
<hr /></div>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/#ibm-pcon">回页首</a></p>
<p><a name="N10127">API 函数</a></p>
<p>现在来看一下能够创建新 slab 缓存、向缓存中增加内存、销毁缓存的应用程序接口（API）以及 slab 中对对象进行分配和释放操作的函数。</p>
<p>第一个步骤是创建 slab 缓存结构，您可以将其静态创建为：</p>
<table border="0" cellspacing="0" cellpadding="0" width="65%">
<tbody>
<tr>
<td>
<pre>struct struct <strong>kmem_cache</strong> *my_cachep;</pre>
</td>
</tr>
</tbody>
</table>
<p>然后其他 slab 缓存函数将使用该引用进行创建、删除、分配等操作。<code>kmem_cache</code> 结构包含了每个中央处理器单元（CPU）的数据、一组可调整的（可以通过 proc 文件系统访问）参数、统计信息和管理 slab 缓存所必须的元素。</p>
<p><a name="N10144">kmem_cache_create</a></p>
<p>内核函数 <code>kmem_cache_create</code> 用来创建一个新缓存。这通常是在内核初始化时执行的，或者在首次加载内核模块时执行。其原型定义如下：</p>
<table border="0" cellspacing="0" cellpadding="0" width="65%">
<tbody>
<tr>
<td>
<pre>struct kmem_cache *
<strong>kmem_cache_create</strong>( const char *name, size_t size, size_t align,
                       unsigned long flags;
                       void (*ctor)(void*, struct kmem_cache *, unsigned long),
                       void (*dtor)(void*, struct kmem_cache *, unsigned long));</pre>
</td>
</tr>
</tbody>
</table>
<p><code>name</code> 参数定义了缓存名称，proc 文件系统（在 /proc/slabinfo 中）使用它标识这个缓存。         <code>size</code> 参数指定了为这个缓存创建的对象的大小， <code>align</code> 参数定义了每个对象必需的对齐。         <code>flags</code> 参数指定了为缓存启用的选项。这些标志如表 1 所示。<br />
<a name="table1"><strong>表 1.           kmem_cache_create 的部分选项（在 flags 参数中指定）</strong></a></p>
<table border="0" cellspacing="0" cellpadding="0" width="80%" summary="表 1.           kmem_cache_create 的部分选项（在 flags 参数中指定）">
<tbody>
<tr>
<th scope="col">选项</th>
<th scope="col">说明</th>
</tr>
<tr>
<th scope="row">SLAB_RED_ZONE</th>
<td>在对象头、尾插入标志，用来支持对缓冲区溢出的检查。</td>
</tr>
<tr>
<th scope="row">SLAB_POISON</th>
<td>使用一种己知模式填充 slab，允许对缓存中的对象进行监视（对象属对象所有，不过可以在外部进行修改）。</td>
</tr>
<tr>
<th scope="row">SLAB_HWCACHE_ALIGN</th>
<td>指定缓存对象必须与硬件缓存行对齐。</td>
</tr>
</tbody>
</table>
<p><code>ctor</code> 和 <code>dtor</code> 参数定义了一个可选的对象构造器和析构器。构造器和析构器是用户提供的回调函数。当从缓存中分配新对象时，可以通过构造器进行初始化。</p>
<p>在创建缓存之后，          <code>kmem_cache_create</code> 函数会返回对它的引用。注意这个函数并没有向缓存分配任何内存。相反，在试图从缓存（最初为空）分配对象时，<strong>refill</strong> 操作将内存分配给它。当所有对象都被使用掉时，也可以通过相同的操作向缓存添加内存。</p>
<p><a name="N101BE">kmem_cache_destroy</a></p>
<p>内核函数 <code>kmem_cache_destroy</code> 用来销毁缓存。这个调用是由内核模块在被卸载时执行的。在调用这个函数时，缓存必须为空。</p>
<table border="0" cellspacing="0" cellpadding="0" width="65%">
<tbody>
<tr>
<td>
<pre>void <strong>kmem_cache_destroy</strong>( struct kmem_cache *cachep );</pre>
</td>
</tr>
</tbody>
</table>
<p><a name="N101D3">kmem_cache_alloc</a></p>
<p>要从一个命名的缓存中分配一个对象，可以使用         <code>kmem_cache_alloc</code> 函数。调用者提供了从中分配对象的缓存以及一组标志：</p>
<table border="0" cellspacing="0" cellpadding="0" width="65%">
<tbody>
<tr>
<td>
<pre>void <strong>kmem_cache_alloc</strong>( struct kmem_cache *cachep, gfp_t flags );</pre>
</td>
</tr>
</tbody>
</table>
<p>这个函数从缓存中返回一个对象。注意如果缓存目前为空，那么这个函数就会调用         <code>cache_alloc_refill</code> 向缓存中增加内存。 <code>kmem_cache_alloc</code> 的 flags 选项与          <code>kmalloc</code> 的 flags 选项相同。表 2 给出了标志选项的部分列表。<br />
<a name="table2"><strong>表 2.          kmem_cache_alloc 和 kmalloc 内核函数的标志选项</strong></a></p>
<table border="0" cellspacing="0" cellpadding="0" width="80%" summary="表 2.          kmem_cache_alloc 和 kmalloc 内核函数的标志选项">
<tbody>
<tr>
<th scope="col">标志</th>
<th scope="col">说明</th>
</tr>
<tr>
<th scope="row">GFP_USER</th>
<td>为用户分配内存（这个调用可能会睡眠）。</td>
</tr>
<tr>
<th scope="row">GFP_KERNEL</th>
<td>从内核 RAM 中分配内存（这个调用可能会睡眠）。</td>
</tr>
<tr>
<th scope="row">GFP_ATOMIC</th>
<td>使该调用强制处于非睡眠状态（对中断处理程序非常有用）。</td>
</tr>
<tr>
<th scope="row">GFP_HIGHUSER</th>
<td>从高端内存中分配内存。</td>
</tr>
</tbody>
</table>
<p><a name="N10241">kmem_cache_zalloc</a></p>
<p>内核函数 <code>kmem_cache_zalloc</code> 与         <code>kmem_cache_alloc</code> 类似，只不过它对对象执行          <code>memset</code> 操作，用来在将对象返回调用者之前对其进行清除操作。</p>
<p><a name="N10256">kmem_cache_free</a></p>
<p>要将一个对象释放回 slab，可以使用          <code>kmem_cache_free</code>。调用者提供了缓存引用和要释放的对象。</p>
<table border="0" cellspacing="0" cellpadding="0" width="65%">
<tbody>
<tr>
<td>
<pre>void <strong>kmem_cache_free</strong>( struct kmem_cache *cachep, void *objp );</pre>
</td>
</tr>
</tbody>
</table>
<p><a name="N1026B">kmalloc 和 kfree</a></p>
<p>内核中最常用的内存管理函数是          <code>kmalloc</code> 和 <code>kfree</code> 函数。这两个函数的原型如下：</p>
<table border="0" cellspacing="0" cellpadding="0" width="65%">
<tbody>
<tr>
<td>
<pre>void *<strong>kmalloc</strong>( size_t size, int flags );
void <strong>kfree</strong>( const void *objp );</pre>
</td>
</tr>
</tbody>
</table>
<p>注意在 <code>kmalloc</code> 中，惟一两个参数是要分配的对象的大小和一组标志（请参看 <a href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/#table2">表 2</a> 中的部分列表）。但是 <code>kmalloc</code> 和         <code>kfree</code> 使用了类似于前面定义的函数的 slab 缓存。<code>kmalloc</code> 没有为要从中分配对象的某个 slab 缓存命名，而是循环遍历可用缓存来查找可以满足大小限制的缓存。找到之后，就（使用         <code> __kmem_cache_alloc</code>）分配一个对象。要使用          <code>kfree</code> 释放对象，从中分配对象的缓存可以通过调用 <code>virt_to_cache</code> 确定。这个函数会返回一个缓存引用，然后在          <code>__cache_free</code> 调用中使用该引用释放对象。</p>
<p><a name="N102B0">其他函数</a></p>
<p>slab 缓存 API 还提供了其他一些非常有用的函数。         <code>kmem_cache_size</code> 函数会返回这个缓存所管理的对象的大小。您也可以通过调用 <code>kmem_cache_name</code> 来检索给定缓存的名称（在创建缓存时定义）。缓存可以通过释放其中的空闲 slab 进行收缩。这可以通过调用          <code>kmem_cache_shrink</code> 实现。注意这个操作（称为回收）是由内核定期自动执行的（通过         <code>kswapd</code>）。</p>
<table border="0" cellspacing="0" cellpadding="0" width="65%">
<tbody>
<tr>
<td>
<pre>unsigned int <strong>kmem_cache_size</strong>( struct kmem_cache *cachep );
const char *<strong>kmem_cache_name</strong>( struct kmem_cache *cachep );
int <strong>kmem_cache_shrink</strong>( struct kmem_cache *cachep );</pre>
</td>
</tr>
</tbody>
</table>
<div>
<hr /></div>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/#ibm-pcon">回页首</a></p>
<p><a name="N102D7">slab 缓存的示例用法</a></p>
<p>下面的代码片断展示了创建新 slab 缓存、从缓存中分配和释放对象然后销毁缓存的过程。首先，必须要定义一个 <code>kmem_cache</code> 对象，然后对其进行初始化（请参看清单 1）。这个特定的缓存包含 32 字节的对象，并且是硬件缓存对齐的（由标志参数 <code>SLAB_HWCACHE_ALIGN</code> 定义）。<br />
<a name="listing1"><strong>清单 1. 创建新 slab 缓存</strong></a></p>
<table border="0" cellspacing="0" cellpadding="0" width="80%">
<tbody>
<tr>
<td>
<pre>static struct kmem_cache *my_cachep;

static void init_my_cache( void )
{

   my_cachep = <strong>kmem_cache_create</strong>(
                  "my_cache",            /* Name */
                  32,                    /* Object Size */
                  0,                     /* Alignment */
                  SLAB_HWCACHE_ALIGN,    /* Flags */
                  NULL, NULL );          /* Constructor/Deconstructor */

   return;
}</pre>
</td>
</tr>
</tbody>
</table>
<p>使用所分配的 slab  缓存，您现在可以从中分配一个对象了。清单 2 给出了一个从缓存中分配和释放对象的例子。它还展示了两个其他函数的用法。<br />
<a name="listing2"><strong>清单 2. 分配和释放对象</strong></a></p>
<table border="0" cellspacing="0" cellpadding="0" width="80%">
<tbody>
<tr>
<td>
<pre>int slab_test( void )
{
  void *object;

  printk( "Cache name is %s\n", <strong>kmem_cache_name</strong>( my_cachep ) );
  printk( "Cache object size is %d\n", <strong>kmem_cache_size</strong>( my_cachep ) );

  object = <strong>kmem_cache_alloc</strong>( my_cachep, GFP_KERNEL );

  if (object) {

    <strong>kmem_cache_free</strong>( my_cachep, object );

  }

  return 0;
}</pre>
</td>
</tr>
</tbody>
</table>
<p>最后，清单 3 演示了 slab 缓存的销毁。调用者必须确保在执行销毁操作过程中，不要从缓存中分配对象。<br />
<a name="listing3"><strong>清单 3. 销毁 slab 缓存</strong></a></p>
<table border="0" cellspacing="0" cellpadding="0" width="80%">
<tbody>
<tr>
<td>
<pre>static void remove_my_cache( void )
{

  if (my_cachep) <strong>kmem_cache_destroy</strong>( my_cachep );

  return;
}</pre>
</td>
</tr>
</tbody>
</table>
<div>
<hr /></div>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/#ibm-pcon">回页首</a></p>
<p><a name="N1031E">slab 的 proc 接口</a></p>
<p>proc 文件系统提供了一种简单的方法来监视系统中所有活动的 slab 缓存。这个文件称为  /proc/slabinfo，它除了提供一些可以从用户空间访问的可调整参数之外，还提供了有关所有 slab 缓存的详细信息。当前版本的  slabinfo 提供了一个标题，这样输出结果就更具可读性。对于系统中的每个 slab  缓存来说，这个文件提供了对象数量、活动对象数量以及对象大小的信息（除了每个 slab 的对象和页面之外）。另外还提供了一组可调整的参数和  slab 数据。</p>
<p>要调优特定的 slab 缓存，可以简单地向  /proc/slabinfo 文件中以字符串的形式回转 slab 缓存名称和 3 个可调整的参数。下面的例子展示了如何增加 limit 和 batchcount 的值，而保留 shared         factor 不变（格式为 “cache name limit batchcount shared factor”）：</p>
<table border="0" cellspacing="0" cellpadding="0" width="65%">
<tbody>
<tr>
<td>
<pre># <strong>echo "my_cache 128 64 8" &gt; /proc/slabinfo</strong></pre>
</td>
</tr>
</tbody>
</table>
<p><code>limit</code> 字段表示每个 CPU 可以缓存的对象的最大数量。         <code>batchcount</code> 字段是当缓存为空时转换到每个 CPU 缓存中全局缓存对象的最大数量。         <code>shared</code> 参数说明了对称多处理器（Symmetric MultiProcessing，SMP）系统的共享行为。</p>
<p>注意您必须具有超级用户的特权才能在 proc 文件系统中为 slab 缓存调优参数。</p>
<div>
<hr /></div>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/#ibm-pcon">回页首</a></p>
<p><a name="N10344"> SLOB 分配器</a></p>
<p>对于小型的嵌入式系统来说，存在一个 slab 模拟层，名为 SLOB。这个 slab 的替代品在小型嵌入式 Linux 系统中具有优势，但是即使它保存了 512KB 内存，依然存在碎片和难于扩展的问题。在禁用 <code>CONFIG_SLAB</code> 时，内核会回到这个 SLOB 分配器中。更多信息请参看 <a href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/#resources">参考资料</a> 一节。</p>
<div>
<hr /></div>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/#ibm-pcon">回页首</a></p>
<p><a name="N10355">结束语</a></p>
<p>slab 缓存分配器的源代码实际上是 Linux 内核中可读性较好的一部分。除了函数调用的间接性之外，源代码也非常直观，总的来说，具有很好的注释。如果您希望了解更多有关 slab 缓存分配器的内容，建议您从源代码开始，因为它是有关这种机制的最新文档。         下面的 <a href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/#resources">参考资料</a> 一节提供了介绍 slab 缓存分配器的参考资料，但是不幸的是就目前的 2.6 实现来说，这些文档都已经过时了。</p>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/109/feed/</wfw:commentRss>
		<slash:comments>274</slash:comments>
		</item>
	</channel>
</rss>
