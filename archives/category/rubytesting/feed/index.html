<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Only For Sunshine~ &#187; Ruby&amp;Testing</title>
	<atom:link href="http://imzc.net/archives/category/rubytesting/feed/" rel="self" type="application/rss+xml" />
	<link>http://imzc.net</link>
	<description>-More Thinking,And Then Just do it~~~</description>
	<lastBuildDate>Thu, 20 Sep 2012 16:40:36 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=3.4.2</generator>
		<item>
		<title>安装ruby1.8.6后，gem错误的解决</title>
		<link>http://imzc.net/archives/283/</link>
		<comments>http://imzc.net/archives/283/#comments</comments>
		<pubDate>Thu, 02 Aug 2012 05:25:14 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[Ruby&Testing]]></category>

		<guid isPermaLink="false">http://imzc.net/?p=283</guid>
		<description><![CDATA[在一台干净环境中安装了ruby1.8.6之后，直接输入gem sources -l等操作，都提示： *** C [...]]]></description>
			<content:encoded><![CDATA[<p>在一台干净环境中安装了ruby1.8.6之后，直接输入gem sources -l等操作，都提示：</p>
<blockquote><p>
*** CURRENT SOURCES ***</p>
<p>ERROR:  While executing gem &#8230; (Gem::RemoteSourceException)<br />
    HTTP Response 302
</p></blockquote>
<p>解决的方法：<br />
1.下载 rubygems-update-1.3.7.gem：</p>
<p>http://rubyforge.org/frs/download.php/70695/rubygems-update-1.3.7.gem</p>
<p>2.CMD运行： gem install &#8211;local rubygems-update-1.3.7.gem<br />
C:\share>gem install rubygems-update-1.3.7.gem<br />
Successfully installed rubygems-update, version 1.3.7<br />
Installing ri documentation for rubygems-update-1.3.7&#8230;<br />
Installing RDoc documentation for rubygems-update-1.3.7&#8230;</p>
<p>3.CMD运行： gem install rubygems-update<br />
C:\share>gem install rubygems-update<br />
Successfully installed rubygems-update, version 1.3.7<br />
Installing ri documentation for rubygems-update-1.3.7&#8230;<br />
Installing RDoc documentation for rubygems-update-1.3.7&#8230;</p>
<p>4.CMD运行： update_rubygems<br />
C:\share>update_rubygems<br />
RubyGems 1.3.7 installed</p>
<p>通过以上步骤，升级本地的gem程序，之后就可以进行常见操作了。当然了，gem source服务器推荐用淘宝的。</p>
<blockquote><p>
$ gem sources &#8211;remove http://rubygems.org/<br />
$ gem sources -a http://ruby.taobao.org/<br />
$ gem sources -l<br />
*** CURRENT SOURCES ***</p>
<p>http://ruby.taobao.org</p>
</blockquote>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/283/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>配置vim rails集成开发环境</title>
		<link>http://imzc.net/archives/280/</link>
		<comments>http://imzc.net/archives/280/#comments</comments>
		<pubDate>Wed, 01 Aug 2012 05:10:22 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[Ruby&Testing]]></category>

		<guid isPermaLink="false">http://imzc.net/?p=280</guid>
		<description><![CDATA[rails开发,好用点的IDE有netbeans,eclipse等.但是netbeans等基于Java编写的客 [...]]]></description>
			<content:encoded><![CDATA[<blockquote><p>
rails开发,好用点的IDE有netbeans,eclipse等.但是netbeans等基于Java编写的客户端,在工程小的时候,还可以.<br />
而工程大了,就比较卡了.一般来说,公司配备的电脑配置都很差,所以估计用vim是最快捷的了;<br />
而且,可以在远程的虚拟机里面搭好环境,远程通过xshell连入,很方便快捷.<br />
入手难度初期可能稍微高一点,但是呢,用顺手之后,你会发觉vim非常nice~ 不用不知道,一用吓一跳~~~O(∩_∩)O~<br />
配置vim ide环境,简单点的就是直接使用janus一体包,然后自定义一点配置,还是比较简单的.
</p></blockquote>
<p>以ubuntu 11.04为例,步骤如下:<br />
1.ubunt安装好ruby+rails环境(开发和vim插件安装都会用到ruby,先提前安装吧)<br />
这部分的步骤直接见ruby-china的wiki:<a href="http://ruby-china.org/wiki/install_ruby_guide" target="_blank">如何快速正确的安装 Ruby, Rails 运行环境</a></p>
<p>2.ubuntu安装好git和curl(一般都已经安装好了)</p><pre class="crayon-plain-tag">sudo apt-get install git-core curl</pre><p>3.安装janus(集成vim插件和常见配置)<br />
主页在: https://github.com/carlhuda/janus<br />
使用以下命令安装即可:</p><pre class="crayon-plain-tag">curl -Lo- https://bit.ly/janus-bootstrap | bash</pre><p>待命令结束运行,无意外的话,就全部安装成功了.</p>
<p>4.在janus的基础上面自定义下快捷键:</p><pre class="crayon-plain-tag">#vim ~/.vimrc.after
color desert
&quot;map to switch tabs
map &lt;F3&gt; &lt;Esc&gt;:tabn&lt;CR&gt;
&quot;map to open NERDTree
map &lt;F8&gt; &lt;Esc&gt;\n
&quot;map to switch NERDTree Window
map &lt;F2&gt; &lt;Esc&gt;&lt;C-w&gt;&lt;C-w&gt;
map &lt;F9&gt; &lt;Esc&gt;&lt;C-w&gt;&lt;Left&gt;
map &lt;F10&gt; &lt;Esc&gt;&lt;C-w&gt;&lt;Right&gt;
&quot;map to switch function list
map &lt;F6&gt; &lt;Esc&gt;\rt
&quot;open syntax fold function.
set fdm=syntax
set foldlevel=2

&quot; mac
color desert
&quot;map to switch tabs
map &lt;F3&gt; &lt;Esc&gt;:tabn&lt;CR&gt;
map &lt;D-1&gt; &lt;Esc&gt;:tabn&lt;CR&gt;
&quot;map to open NERDTree
map &lt;F8&gt; &lt;Esc&gt;\n
map &lt;D-t&gt; &lt;Esc&gt;\n
&quot;map to switch NERDTree Window
map &lt;F2&gt; &lt;Esc&gt;&lt;C-w&gt;&lt;C-w&gt;
map &lt;F9&gt; &lt;Esc&gt;&lt;C-w&gt;&lt;Left&gt;
map &lt;D-j&gt;  &lt;Esc&gt;&lt;C-w&gt;&lt;Left&gt;
map &lt;F10&gt; &lt;Esc&gt;&lt;C-w&gt;&lt;Right&gt;
map &lt;D-k&gt; &lt;Esc&gt;&lt;C-w&gt;&lt;Right&gt;
&quot;map to switch function list
map &lt;F6&gt; &lt;Esc&gt;\rt
map &lt;D-f&gt; &lt;Esc&gt;\rt</pre><p>解释下上面自定义的快捷键:<br />
使用配色方案为desert;<br />
F3 在有多个tab窗口时,从前往后依次循环跳转;<br />
F8 打开目录树;在目录树种,可以使用: i (打开当前文件到split窗口) t (打开当前文件到另一个tab页)<br />
F2 在当前tab窗口,依次进入split窗口<br />
F9 在当前tab窗口,进入左边的split窗口<br />
F10 在当前tab窗口,进入右边的split窗口<br />
F6 打开函数列表<br />
修改vimrc后,不重启vim的情况下,重新加载配置: &#8220;:so ~/.vimrc &#8221;</p>
<p><strong>常用的技巧</strong>:<br />
:! file % 执行命令,%代表当前打开文件的全路径.<br />
ctrl+6 在同一个tab中多次打开文件后,切换上一个和当前打开的文件.<br />
gf 跳转到控制器对应的model定义(rails) 结合ctrl+6往返.</p>
<p><strong>可视模式</strong>:<br />
命令模式下,直接按小写v或者大写V进入,直接进行多个字符或者多行操作;如:<br />
v -> 选择多行-> \cc 注释 \c空格 取消注释<br />
v->选择多行->y 复制->p 粘贴(yny,p)</p>
<p><strong>编辑操作</strong>:<br />
u undo<br />
ctrl+r redo<br />
yny 复制n行<br />
dnd 删除n行(有复制到缓冲区)<br />
p 粘贴</p>
<p><strong>搜索</strong>:<br />
命令行模式下,使用 * 键可以向后搜索光标所在位置的单词。反之，使用 # 键可以向前搜索光标所在位置的单词。<br />
第一次使用 * 或者 # 进行搜索之后，则可以使用 N 或 Shift-N 继续进行搜索。<br />
另外，如果设置了hlsearch选项（:set hlsearch）的话，那么使用 * Shift-N 则可以标记当前的单词为高亮显示。</p>
<p><strong>翻页</strong>(在没有PageUp PageDown的情况下比较好用):<br />
下翻页 Ctrl-f<br />
上翻页 Ctrl-b<br />
下翻行 Ctrl-e<br />
上翻行 Ctrl-y<br />
<strong>行尾</strong>:<br />
命令模式下, ^ 行首; $ 行尾</p>
<p><strong>退出</strong>:<br />
:qall （退出所有窗口）<br />
:wall （保存所有窗口的修改）<br />
:wqall （保存并退出所有窗口）<br />
:qall! （强制退出所有窗口）</p>
<p><strong>Rails专用命令R</strong> (命令行模式下):<br />
:Rcontroller xxx 打开xxx的控制器<br />
:Rmodel xxx 打开xxx的模型<br />
:Rjavascript xxx 打开xxx的js文件<br />
:Rview xxx 打开xxx的视图(erb)</p>
<p>5.上述是介绍的快捷键操作,下面在介绍下怎样保存当前的vim环境:<br />
在命令模式,输入&#8221;:mks!&#8221; 即保存当前状态到:当前目录的 Session.vim 文件中<br />
退出所有vim窗口后,恢复之前的环境: vim -S Session.vim 即可 (如果vim已经打开,则命令模式下运行&#8221;:source Session.vim&#8221;)</p>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/280/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>筛选法得到N以内的素数表</title>
		<link>http://imzc.net/archives/279/</link>
		<comments>http://imzc.net/archives/279/#comments</comments>
		<pubDate>Thu, 26 Jul 2012 05:13:20 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[Ruby&Testing]]></category>

		<guid isPermaLink="false">http://imzc.net/?p=279</guid>
		<description><![CDATA[今天有需要用到的时候,突然发现怎样迅速求出素数表一下给忘记了,看来基本的一些算法需要时时练习下; 再一次对算法 [...]]]></description>
			<content:encoded><![CDATA[<p>今天有需要用到的时候,突然发现怎样迅速求出素数表一下给忘记了,看来基本的一些算法需要时时练习下;<br />
再一次对算法的问题郁闷了,挺悲剧的&#8230;<br />
说回求素数表的问题,依稀记得有通过筛选方法得出的,重新看看了相关资料,用ruby实现了下:</p><pre class="crayon-plain-tag"># encoding: utf-8
#!/usr/bin/ruby

def prime_find(n)
  #1既不是素数也不是合数
  if n&lt;=1
    return []
  end

  init = Array.new(n-1) {|i| i+2} #from 2 to n
  prime =[]
  t = 2
  sqrt = Math.sqrt(n).to_i
  while t&lt;= sqrt
    init.each_index{|i|
      init[i]=0  if init[i]!=t and init[i] % t == 0 #剔除本身
    }
    t+=1
  end

  init.each{|x|  prime.push(x) if x!=0 }
  prime
end

n=1000
primes =  prime_find(n)
print &quot;#{n}以内的素数共有(#{primes.length})个:&quot;
primes.each_index{|i|
  print(&quot;\n&quot;) if i%16 ==0
  print primes[i],&quot; &quot;
}</pre><p>&nbsp;</p>
<blockquote><p>
结果:<br />
1000以内的素数共有(168)个:<br />
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53<br />
59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131<br />
137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223<br />
227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311<br />
313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409<br />
419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503<br />
509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613<br />
617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719<br />
727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827<br />
829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941<br />
947 953 967 971 977 983 991 997<br />
请按 ENTER 或其它命令继续
</p></blockquote>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/279/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>linux下STAF执行失败时的处理</title>
		<link>http://imzc.net/archives/268/</link>
		<comments>http://imzc.net/archives/268/#comments</comments>
		<pubDate>Mon, 09 Jul 2012 03:09:37 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[Ruby&Testing]]></category>

		<guid isPermaLink="false">http://imzc.net/?p=268</guid>
		<description><![CDATA[最近使用staf时,老是提示xxx.so找不到,按照网上的解决方案设置了,都不行,结果发现问题出现在命令上面: [...]]]></description>
			<content:encoded><![CDATA[<p>最近使用staf时,老是提示xxx.so找不到,按照网上的解决方案设置了,都不行,结果发现问题出现在命令上面:</p>
<p>使用screen防止ssh突然断链,而screen和普通直接登录ssh时不一样.执行命令时,我直接使用了:screen xxx,</p>
<p>猜想:screen command时,在未执行 /etc/profile.从而导致使用xshell登录ssh的环境变量和command通过screen运行时的环境变量不一致.</p>
<p>修复错误: screen -t &#8220;windows name&#8221;后,先执行一下/etc/profile,然后再执行自己的命令.</p>
<p>&nbsp;</p>
<blockquote><p>附上找不到libSTAF.so时,<a href="http://katrina-lxd.i.sohu.com/blog/view/184589263.htm" target="_blank">网上的</a>一般解决方案:</p>
<p>1、启动时：error while loading shared libraries: libSTAF.so: cannot open shared object file: No such file or directory</p>
<p>&nbsp;</p>
<p>解决思路：</p>
<p>（1）、staf默认安装在/usr/local/staf下，如果当前用户不是root用户，确认登录用户有操作该文件夹的权限。</p>
<p>（2）、LD_LIBRARY_PATH未配置staf的库</p>
<p>export LD_LIBRARY_PATH=/usr/local/staf/lib</p>
<p>（3）、LD_LIBRARY_PATH配置成功后运行STAFProc有如下提示：</p>
<p>STAF bin directory not found in PATH, STAF RC: 48, OS RC: 0</p>
<p>配置PATH：PATH=/usr/local/staf/bin:$PATH<br />
export PATH</p>
<p>&nbsp;</p>
<p>2、linux下安装staf之前，</p>
<p>cd /usr/lib</p>
<p>ll libstdc*</p>
<p>如果有C库，不用安装了。</p>
<p>&nbsp;</p>
<p>3、若安装stax，需先安装jvm或者带jvm的staf</p>
<p>&nbsp;</p>
<p>4、配置好stax启动staf时，</p>
<p>Error constructing service, JSTAF, Result: Unable to connect to JVM</p>
<p>并且/usr/local/staf/data/STAF/lang/java/jvm/STAFJVM1中的日志为</p>
<p>Caused by: java.lang.ClassNotFoundException: com.ibm.staf.service.STAFServiceHelper</p>
<p>解决：</p>
<p>（1）确认的位置JSTAF.jar：windows默认在C:\STAF\bin\JSTAF.jar，linux默认在/usr/local/staf/lib/JSTAF.jar。<tt></tt></p>
<p>（2）将JSTAF.jar添加到CLASSPATH中。</p></blockquote>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/268/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>ruby Rspec测试框架cheetsheet</title>
		<link>http://imzc.net/archives/267/</link>
		<comments>http://imzc.net/archives/267/#comments</comments>
		<pubDate>Wed, 04 Jul 2012 16:57:39 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[Ruby&Testing]]></category>

		<guid isPermaLink="false">http://imzc.net/?p=267</guid>
		<description><![CDATA[项目使用Rspec测试框架,一堆should等等方法容易忘记,这里收集了下: INSTALL =======  [...]]]></description>
			<content:encoded><![CDATA[<p>项目使用Rspec测试框架,一堆should等等方法容易忘记,这里收集了下:<br />
INSTALL<br />
=======</p>
<p>$ gem install rspec</p>
<p>RSPEC-RAILS<br />
===========</p>
<p>  RAILS-3<br />
  =======</p>
<p>    CONFIGURE THE GEMFILE<br />
    ======================<br />
    group :development, :test do<br />
      gem &#8220;rspec-rails&#8221;, &#8220;~> 2.0&#8243;<br />
    end</p>
<p>    INSTALL THE BUNDLE<br />
    ===============================<br />
    $ bundle install</p>
<p>    BOOTSTRAP THE APP<br />
    =================<br />
    $ ./script/rails generate rspec:install<br />
          create  .rspec<br />
          create  spec<br />
          create  spec/spec_helper.rb<br />
          create  autotest<br />
          create  autotest/discover.rb</p>
<p>  RAILS-2<br />
  =======</p>
<p>    INSTALL<br />
    =======<br />
    $ gem install rspec-rails -v 1.3.3</p>
<p>    BOOTSTRAP THE APP<br />
    =================<br />
    $ ./script/generate rspec<br />
        create  spec<br />
        create  spec/spec_helper.rb<br />
        create  spec/spec.opts<br />
        create  previous_failures.txt<br />
        create  script/spec_server<br />
        create  script/spec</p>
<p>HOW TO USE<br />
==========</p>
<p>  COMMAND LINE<br />
  =============<br />
rspec &#8211;color &#8211;format doc spec/widget_spec.rb</p>
<p>  RAILS 3 (RSPEC 2)<br />
  =============<br />
./rails/generate model User<br />
rake -T spec # lists all rspec rake tasks<br />
rake spec # run all specs<br />
rake spec/models/mymodel_spec.rb # run a single spec file<br />
rake spec/models/mymodel_spec.rb:27 # run a single example or group on line 27</p>
<p>  RAILS 2 (RSPEC 1)<br />
  =============<br />
./script/generate rspec_model User<br />
rake -T spec # lists all rspec rake tasks<br />
rake spec # run all specs<br />
rake spec SPEC=spec/models/mymodel_spec.rb SPEC_OPTS=&#8221;-e \&#8221;should do<br />
something\&#8221;" #run a single spec</p>
<p></p><pre class="crayon-plain-tag">module UserSpecHelper
  def valid_user_attributes
    { :email =&gt; &quot;joe@bloggs.com&quot;,
      :username =&gt; &quot;joebloggs&quot;,
      :password =&gt; &quot;abcdefg&quot;}
  end
end


describe &quot;A User (in general)&quot; do
  include UserSpecHelper

  before(:each) do
    @user = User.new
  end

  it &quot;should be invalid without a username&quot; do
    pending &quot;some other thing we depend on&quot;
    @user.attributes = valid_user_attributes.except(:username)
    @user.should_not be_valid
    @user.should have(1).error_on(:username)
    @user.errors.on(:username).should == &quot;is required&quot;
    @user.username = &quot;someusername&quot;
    @user.should be_valid
  end
end</pre><p>EXPECTATIONS<br />
=====================</p><pre class="crayon-plain-tag">target.should satisfy {|arg| ...}
target.should_not satisfy {|arg| ...}

target.should equal &lt;value&gt;
target.should_not equal &lt;value&gt;

target.should be_close &lt;value&gt;, &lt;tolerance&gt;
target.should_not be_close &lt;value&gt;, &lt;tolerance&gt;

target.should be &lt;value&gt;
target.should_not be &lt;value&gt;

target.should predicate [optional args]
target.should be_predicate [optional args]
target.should_not predicate [optional args]
target.should_not be_predicate [optional args]

target.should be &lt; 6
target.should == 5
target.should be_between(1, 10)
target.should_not == 'Samantha'

target.should match &lt;regex&gt;
target.should_not match &lt;regex&gt;

target.should be_an_instance_of &lt;class&gt;
target.should_not be_an_instance_of &lt;class&gt;

target.should be_a_kind_of &lt;class&gt;
target.should_not be_a_kind_of &lt;class&gt;

target.should respond_to &lt;symbol&gt;
target.should_not respond_to &lt;symbol&gt;

lambda {a_call}.should raise_error
lambda {a_call}.should raise_error(&lt;exception&gt; [, message])
lambda {a_call}.should_not raise_error
lambda {a_call}.should_not raise_error(&lt;exception&gt; [, message])
lambda {a_call}.should change(instance, method).from(number).to(number)

proc.should throw &lt;symbol&gt;
proc.should_not throw &lt;symbol&gt;

target.should include &lt;object&gt;
target.should_not include &lt;object&gt;

target.should have(&lt;number&gt;).things
target.should have_at_least(&lt;number&gt;).things
target.should have_at_most(&lt;number&gt;).things

target.should have(&lt;number&gt;).errors_on(:field)

expect { thing.approve! }.to change(thing, :status).
    from(Status::AWAITING_APPROVAL).
    to(Status::APPROVED)

expect { thing.destroy }.to change(Thing, :count).by(-1)</pre><p>Mocks and Stubs(打桩)<br />
===============</p><pre class="crayon-plain-tag">user_mock = mock &quot;User&quot;
user_mock.should_receive(:authenticate).with(&quot;password&quot;).and_return(true)
user_mock.should_receive(:coffee).exactly(3).times.and_return(:americano)
user_mock.should_receive(:coffee).exactly(5).times.and_raise(NotEnoughCoffeeExcep
ion)

people_stub = mock &quot;people&quot;
people_stub.stub!(:each).and_yield(mock_user)
people_stub.stub!(:bad_method).and_raise(RuntimeError)

user_stub = mock_model(&quot;User&quot;, :id =&gt; 23, :username =&gt; &quot;pat&quot;, :email =&gt;
&quot;pat@example.com&quot;)

my_instance.stub!(:msg).and_return(value)
MyClass.stub!(:msg).and_return(value)</pre><p>Examples (in the real world)</p>
<p>============================</p>
<p>http://madhatted.com/2008/7/10/rspec-real-world-testing</p>
<p>presentation: http://kerryb.github.com/iprug-rspec-presentation/#31<br />
&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/267/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>使用windows api实现屏幕截图并复制到剪贴板</title>
		<link>http://imzc.net/archives/253/</link>
		<comments>http://imzc.net/archives/253/#comments</comments>
		<pubDate>Mon, 23 Apr 2012 11:10:43 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[C/C++]]></category>
		<category><![CDATA[Ruby&Testing]]></category>

		<guid isPermaLink="false">http://imzc.net/?p=253</guid>
		<description><![CDATA[最新自动化项目需要使用屏幕截图功能,本来通过autoit发送printscreen键,然后从剪贴板copy出来 [...]]]></description>
			<content:encoded><![CDATA[<p>最新自动化项目需要使用屏幕截图功能,本来通过autoit发送printscreen键,然后从剪贴板copy出来即可.</p><pre class="crayon-plain-tag">require &quot;win32ole&quot;
    t = WIN32OLE.new(&quot;AutoItX3.Control&quot;)
    t.Send(&quot;{PRINTSCREEN}&quot;)   
	sleep 1
	picture=Win32::Clipboard.data(Win32::Clipboard::DIB) 
	ATT::KeyLog.info &quot;pictrue:#{picture.slice(0..10)}&quot; 
	File.open(&quot;xxx.bmp&quot;,&quot;wb&quot;)do |f|
    f.write(picture)
	end</pre><p></p>
<p>&nbsp;</p>
<p>但是此方法有一定风险,比如在远程桌面连入时,很容易和外部PC的剪贴板混乱.<br />
 因此有了使用原始API截图保存的需求.<br />
使用vs2005创建win32控制台程序,勾选ATL即可.注意工程选项,直接静态编译,使程序能适应各个PC.<br />
下面是源码:<br />
带参数时,保存到对应路径,同时复制到剪贴板.<br />
不带参数时,仅复制到剪贴板.</p>
<p></p><pre class="crayon-plain-tag">&amp;nbsp;
// cap.cpp : 定义控制台应用程序的入口点。
//

#include &quot;stdafx.h&quot;  

#include &lt;windows.h&gt;  
#include &lt;atlimage.h&gt;  
 

CString GetSuffix(CString strFileName) 
{ 
	return strFileName.Right(strFileName.GetLength()-strFileName.ReverseFind('.')-1); 
}


int _tmain(int argc, _TCHAR* argv[])
{
  
		wprintf(_T(&quot;Useage:\n\
1.capture.exe  jpg_path (Save bmp and copy  to clipboard.)\n\
2.capture.exe (Only copy bmp to your current clipboard.)\n\
@zc,2012.4.21.&quot;));
		
 
 

		HWND hwnd = ::GetDesktopWindow();  
		HDC hDC = ::GetDC(hwnd); //根据窗口来确定截图的大概位置

		RECT rect;  
		::GetClientRect(hwnd, &amp;rect);  
		HDC hDCMem = ::CreateCompatibleDC(hDC);   

		HBITMAP hBitMap = ::CreateCompatibleBitmap(hDC, rect.right, rect.bottom);  
		HBITMAP hOldMap = (HBITMAP)::SelectObject(hDCMem, hBitMap);  

		::BitBlt(hDCMem, 0, 0, rect.right, rect.bottom, hDC, 0, 0, SRCCOPY); //红色部分确定图片的大小位置

		CImage image;  
		image.Attach(hBitMap);  

		if (argc==2){
			GUID imageFormat = Gdiplus::ImageFormatBMP;
			CString suffix = GetSuffix(argv[1]).MakeLower();
			if (suffix.Compare(_T(&quot;jpg&quot;))==0)
			{
				imageFormat= Gdiplus::ImageFormatJPEG; 
				wprintf(_T(&quot;img type:jpg&quot;)); 
			}else if (suffix.Compare(_T(&quot;png&quot;))==0)
			{
				imageFormat= Gdiplus::ImageFormatPNG;
				wprintf(_T(&quot;img type:png&quot;)); 
			}else  
			{
				imageFormat= Gdiplus::ImageFormatBMP;
				wprintf(_T(&quot;img type:bmp&quot;)); 
			}

			image.Save(argv[1],imageFormat);  
		}
		 
		if (OpenClipboard(NULL)) 
		{ 
			EmptyClipboard(); 
			SetClipboardData(CF_BITMAP, image); 
			CloseClipboard(); 
		} 
		//::PostMessage(hwnd, WM_KEYDOWN,44 , 0L); //发送 VK_PRINTSCREEN按下的键盘消息   
 
		image.Detach();   
		::SelectObject(hDCMem, hOldMap);  
		::DeleteObject(hBitMap);  
		::DeleteDC(hDCMem);  
		::DeleteDC(hDC);  
 
	return 0;
}</pre><p>&nbsp;<br />
附件下载:<a href='http://imzc.net/wp-content/uploads/2012/04/cap_src_vs2005.rar'>cap_src_vs2005</a></p>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/253/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>ruby调用OLE实现word输出(支持嵌入图片)</title>
		<link>http://imzc.net/archives/238/</link>
		<comments>http://imzc.net/archives/238/#comments</comments>
		<pubDate>Sun, 01 Apr 2012 09:48:44 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[Ruby&Testing]]></category>

		<guid isPermaLink="false">http://imzc.net/?p=238</guid>
		<description><![CDATA[由于项目的需要，要实现ruby生成word报告。而且，要求能嵌入图片。 RTF和PDF，ruby都已经有开源的 [...]]]></description>
			<content:encoded><![CDATA[<p>由于项目的需要，要实现ruby生成word报告。而且，要求能嵌入图片。<br />
RTF和PDF，ruby都已经有开源的实现了，但是在github上面找到的都是要求ruby版本在1.8.7之上，<br />
而我们的自动化框架还在1.8.6，所以，都不能使用。<br />
word OLE在哪里去搜索参数列表啊。。。貌似网上都找不到详细的。这个挺悲剧的。<br />
有知道的朋友可以PM我一下，多谢。。。<br />
嵌入图片有两种函数，后来使用了第二种：<br />
ad.Shapes.AddPicture(picture_360.to_s,false,true,left,top,width,height)<br />
sel.InlineShapes.AddPicture(picture_360.to_s,false,true,nil)<br />
经过网上搜索加以整理，最终实现了，代码如下：</p><pre class="crayon-plain-tag"># coding: utf-8
require 'win32ole'  
 
root =  File.expand_path(File.dirname(__FILE__) )
pic_root = root + &quot;/pics&quot;
start = Time.now  
filename = root+&quot;/virus_scan_reports_&quot;+start.to_i().to_s()+&quot;.doc&quot; 

puts(root+&quot;,time:&quot;+start.to_i().to_s())

def word_report(report_filename,pic_hash,scantitle=&quot;&quot;)
word=WIN32OLE.new 'word.Application'
word.visible=false 
doc=word.Documents
d=doc.add
sel=word.Selection
ad=word.ActiveDocument

ad.Styles.Add('Name'=&gt;'title')
font=ad.Styles(&quot;title&quot;).Font
font.Size=20
font.Bold=true
font.Name=&quot;宋体&quot;

ad.Styles.Add('Name'=&gt;'content')
font=ad.Styles(&quot;content&quot;).Font
font.Size=12
font.Bold=false
font.Name=&quot;宋体&quot;
 
sel.Style=ad.Styles(&quot;title&quot;)  
sel.typeText(&quot;杀毒报告:#{scantitle}&quot;) 

sel.TypeParagraph;
sel.Style=ad.Styles(&quot;content&quot;) 
 
picture_360 = pic_hash[:picture_360]   
picture_macaffee = pic_hash[:picture_macaffee]  
picture_trend = pic_hash[:picture_trend]
picture_duba = pic_hash[:picture_duba] 
picture_rsing = pic_hash[:picture_rsing] 

sel.TypeText(&quot;360杀毒&quot;);
sel.TypeParagraph;
#argvs:$file;msoFalse # link to file ; msoTrue # save with document ;$left, $top, $width, $height
#ad.Shapes.AddPicture(picture_360.to_s,false,true,left,top,width,height)
sel.InlineShapes.AddPicture(picture_360.to_s,false,true,nil)
 
sel.TypeParagraph;
sel.TypeText(&quot;MCaffee杀毒&quot;);
sel.TypeParagraph; 
sel.InlineShapes.AddPicture(picture_macaffee.to_s,false,true,nil)

sel.TypeParagraph;
sel.TypeText(&quot;Trend Pc-cilin杀毒&quot;);
sel.TypeParagraph; 
sel.InlineShapes.AddPicture(picture_trend.to_s,false,true,nil)

sel.TypeParagraph;
sel.TypeText(&quot;金山毒霸杀毒&quot;);
sel.TypeParagraph; 
sel.InlineShapes.AddPicture(picture_duba.to_s,false,true,nil)

sel.TypeParagraph;
sel.TypeText(&quot;瑞星杀毒&quot;);
sel.TypeParagraph; 
sel.InlineShapes.AddPicture(picture_rsing.to_s,false,true,nil)
    
# word.ActiveDocument.Save 
word.DefaultSaveFormat 
d.saveas(report_filename);
# word.ActiveDocument.Close
# word.Documents.close() 
word.quit()    

end


pic_hash = {}
pic_hash[:picture_360] = pic_root+&quot;/360_2012_03_31__20_54_27.bmp&quot;      
pic_hash[:picture_macaffee] = pic_root+&quot;/macaffee_2012_04_01__21_18_36.bmp&quot;  
pic_hash[:picture_trend] = pic_root+&quot;/trend_pccilin_2012_03_31__20_53_20.bmp&quot;
pic_hash[:picture_duba] = pic_root+&quot;/kingsoft_duba_2012_03_31__20_55_37.bmp&quot;  
pic_hash[:picture_rsing] = pic_root+&quot;/rsing_2012_03_31__20_53_58.bmp&quot;

word_report(filename,pic_hash,&quot;att test&quot;)</pre><p>&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/238/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>autoit3实现命令行调用杀毒软件</title>
		<link>http://imzc.net/archives/234/</link>
		<comments>http://imzc.net/archives/234/#comments</comments>
		<pubDate>Fri, 30 Mar 2012 04:31:53 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[Ruby&Testing]]></category>

		<guid isPermaLink="false">http://imzc.net/?p=234</guid>
		<description><![CDATA[自动化项目需要调用杀毒软件对特定文件夹进行病毒扫描，但是大部分杀毒软件都没有提供命令行支持。因此只能从图形界面 [...]]]></description>
			<content:encoded><![CDATA[<p>自动化项目需要调用杀毒软件对特定文件夹进行病毒扫描，但是大部分杀毒软件都没有提供命令行支持。因此只能从图形界面操作搞定。<br />
sikuli可以实现截图方式点击，但是不太稳定，而且，对于趋势杀毒软件，只能选择到某个盘符，不能选择到具体的文件夹，故存在一定的弱点。<br />
考虑到杀毒软件都有提供一个右键菜单，查询注册表发现是一个shellext.dll扩展，不能通过rundll32方式调用。因此可以考虑使用autoit进行操作了。重要知识点：<br />
1.使用windows资源管理器打开特定的文件夹，且处于选中状态，explorer支持多种参数，其中select是实现本功能的参数：<br />
RunWait(@ComSpec &amp; &#8216; /c &#8216; &amp; &#8216;explorer /select,&#8217; &amp; $DirName,&#8221;, @SW_HIDE)</p>
<p> 2.有些时候对应的文件夹已经处于打开状态，且可能选中到其他文件夹，因此需要使用autoit3的函数，将所有文件夹取消选中。<br />
 而特定的文件夹再设置为selected。<br />
 3.直接通过_GUICtrlMenu_GetMenu($hWnd)函数总是失败，因此只有采取变通的手段，通过发送windows消息来获取响应的菜单句柄。<br />
 $hMenu = _SendMessage($hWnd, 0x01E1) ;0x01E1 MN_GETHMENU<br />
 4.由于autoit3的GuiMenu.au3还未提供click对应item的功能，因此只能通过发送快捷键： {DOWN}，{ENTER}来实现选择菜单。<br />
 5.右键菜单曾经打算使用发送WM_CONTEXTMENU消息获得，但是发现在某些机子上面又不行，<br />
 ;007B WM_CONTEXTMENU<br />
 ;_WinAPI_PostMessage($hWnd, 0x007B, 0, 0)<br />
 所以只得采取另外的方法：SHIFT+F10，快捷键很爽啊。。。<br />
 6._GUICtrlMenu_GetItemText($hMenu, $iItem[, $fByPos = True])函数有些时候获取不到菜单的名称（可能是程序内部处理了，如360杀毒），因此需要提供通过索引的方式点击。。。<br />
 7.autoit3编译为exe文件，需要选取“console”（默认是GUI的），以便查看程序输出情况。<br />
使用参数： scan &#8220;E:\待扫描文件&#8221; &#8220;使用|扫描|查杀&#8221;<br />
           scan &#8220;E:\待扫描文件&#8221; &#8220;使用|扫描|查杀&#8221;  15 （最后一个参数是在获取不到对应菜单时，直接点击菜单项目序号，排除空白的）<br />
 具体源码见下：</p>
<p></p><pre class="crayon-plain-tag">#Include &lt;GuiListView.au3&gt; 
#include &lt;WinAPI.au3&gt;  
#include &lt;GuiMenu.au3&gt;
 
 
 
;scan.exe &quot;E:\att_proj\360scan&quot; &quot;使用 ESET NOD32 Antivirus 扫描&quot;

$DirName = &quot;E:\待扫描文件&quot;
$AntiVirusSoftName =  &quot;扫描&quot;

$itemToClick = -1

If 1=1 Then


If $cmdline[0] = 2 or $cmdline[0] = 3 Then
    $DirName = $cmdline[1]
  $AntiVirusSoftName = $cmdline[2] 
  If $cmdline[0] = 3 Then $itemToClick =  $cmdline[3]
Else     
  ConsoleWrite('Please use this program with two/three argvs, 目录名称 and 右键菜单.'&amp; @CRLF)
  ConsoleWrite('Such as programName &quot;D:\appserv&quot; &quot;使用 ESET NOD32 Antivirus 扫描&quot;.' &amp; @CRLF)
  ConsoleWrite('Such as programName &quot;D:\appserv&quot; &quot;使用 ESET NOD32 Antivirus 扫描&quot; itermnum(begin at zero) .' &amp; @CRLF)
  exit
EndIf 

If FileExists($DirName)=0 Then
    ConsoleWrite('DirName:'&amp;$DirName&amp;' is not exists.' &amp; @CRLF)
  exit
EndIf

EndIf

ConsoleWrite('$DirName:'&amp;$DirName&amp;',$AntiVirusSoftName:'&amp;$AntiVirusSoftName &amp; @CRLF)

$array = StringSplit($DirName, '\', 1)
$ItemName = $array[UBound($array)-1]
ConsoleWrite('$ItemName:'&amp;$ItemName&amp; @CRLF)
 
;close all window





;While 1 ;use infinite loop since ExitLoop will get called
;   $TITLE = WinGetTitle(&quot;[CLASS:CabinetWClass]&quot;,&quot;&quot;)
;  ConsoleWrite(&quot;Try to Close one control: [CLASS:CabinetWClass],title:&quot;&amp;$TITLE&amp; @CRLF)
;  $hanlde = WinGetHandle($TITLE) 
 ;   $ans = WinClose($hanlde)  
 ;   If $ans = 0 Then ExitLoop
;WEnd 
 
RunWait(@ComSpec &amp; ' /c ' &amp; 'explorer /select,' &amp; $DirName,'', @SW_HIDE)
 
Opt(&quot;WinTitleMatchMode&quot;, 1)     ;1=start, 2=subStr, 3=exact, 4=advanced, -1 to -4=Nocase

WinSetState(&quot;[CLASS:CabinetWClass]&quot;, &quot;&quot;, @SW_SHOW)
;WinActivate(&quot;[CLASS:CabinetWClass]&quot;, &quot;&quot;)

;$hWnd = ControlGetHandle(&quot;&quot;,&quot;FolderView&quot;,&quot;[CLASS:SysListView32]&quot;)
$hWnd = ControlGetHandle(&quot;&quot;,&quot;FolderView&quot;,&quot;[CLASS:SysListView32; INSTANCE:1]&quot;)

;$pos = ControlGetPos(&quot;&quot;,&quot;FolderView&quot;,&quot;[CLASS:SysListView32]&quot;)
;MsgBox(0, &quot;Window Stats:&quot;, &quot;POS: &quot; &amp; $pos[0] &amp; &quot;,&quot; &amp; $pos[1] &amp; &quot; SIZE: &quot; &amp; $pos[2] &amp; &quot;,&quot; &amp; $pos[3] )

 
 
$items  = _GUICtrlListView_GetItemCount($hWnd)
 

;ConsoleWrite(&quot;Item Count: &quot; &amp; $items &amp; @CRLF)
   
;ConsoleWrite(&quot;Item  Focused: &quot; &amp; _GUICtrlListView_GetItemFocused($hWnd, 1))
 

For $i = 0 To $items -1
 $ItemText = _GUICtrlListView_GetItemText($hWnd, $i)
 ;ConsoleWrite($ItemText&amp; @CRLF)
 _GUICtrlListView_SetItemSelected($hWnd,$i,False)
 Sleep(10)
 If $ItemText = $ItemName Then
  $aRect = _GUICtrlListView_GetItemRect($hWnd,$i)
  ConsoleWrite(StringFormat(&quot;Item 2 Rectangle : [%d, %d, %d, %d]&quot;, $aRect[0], $aRect[1], $aRect[2], $aRect[3])&amp; @CRLF)

  $aPos = _GUICtrlListView_GetItemPosition($hWnd, $i)
  ConsoleWrite(StringFormat(&quot;Item Position : [%d, %d]&quot;, $aPos[0], $aPos[1])&amp; @CRLF)
  
  ;MouseMove ($aRect[2], $aRect[3])
  ;Sleep(2000)
  ;ControlClick(&quot;&quot;,&quot;FolderView&quot;,&quot;[CLASS:SysListView32]&quot;,&quot;right&quot;,1,$aPos[0]+20,$aPos[1]+20)
  
    $centerX = ($aRect[0] + $aRect[2])/2
  $centerY = ($aRect[1] + $aRect[3])/2
  $aPos = _GUICtrlListView_GetItemPosition($hWnd, $i)
  ConsoleWrite(StringFormat(&quot;Item Position : [%d, %d]&quot;, $aPos[0], $aPos[1])&amp; @CRLF)
  
  _GUICtrlListView_SetItemSelected($hWnd,$i)
  
  ;MouseMove ($aRect[2], $aRect[3])
  ;Sleep(2000)
  ;ControlClick(&quot;&quot;,&quot;FolderView&quot;,&quot;[CLASS:SysListView32]&quot;,&quot;right&quot;,1,$centerX,$centerY)
  
  ;ExitLoop 
 EndIf

Next



;MsgBox(0, &quot;HWnd:t,c&quot;, $hWndf &amp;&quot;,&quot;&amp;$hWnd)
;007B WM_CONTEXTMENU
;0x001611DA
;_WinAPI_PostMessage($hWnd, 0x007B, 0x001611da,0x00d30342)

;_WinAPI_PostMessage($hWnd, 0x007B, 0, 0);100,100)
  
Opt('WinSearchChildren', 1)
 
HotKeySet('{ESC}', '_EXIT')
OnAutoItExitRegister('OnAutoItExit')

Global Const $MN_GETHMENU = 0x01E1
Global Const $EVENT_SYSTEM_MENUPOPUPSTART = 0x0006
Global Const $EVENT_SYSTEM_MENUPOPUPEND = 0x0007  
Global $hFunc, $pFunc
Global $hWinHook
 
$hFunc = DllCallbackRegister('_WinEventProc', 'none', 'ptr;uint;hwnd;int;int;uint;uint')
$pFunc = DllCallbackGetPtr($hFunc)
$hWinHook = _SetWinEventHook(0x00000001, 0x7FFFFFFF, 0, $pFunc, 0, 0,BitOR(0x0002, 0x0000))
 
 
 Send(&quot;+{F10}&quot;) ;弹出右键菜单
 


While 1
        Sleep(20)
WEnd
 
Func _EXIT()
        Exit
EndFunc   ;==&gt;_EXIT
 
Func OnAutoItExit()
        _UnhookWinEvent($hWinHook)
        DllCallbackFree($hFunc)
EndFunc   ;==&gt;OnAutoItExit
 
Func _WinEventProc($hHook, $iEvent, $hWnd, $iObjectID, $iChildID, $iEventThread, $imsEventTime)
        Local $hMenu
         
      If $iEvent = $EVENT_SYSTEM_MENUPOPUPSTART  Then
                $hMenu = _SendMessage($hWnd, 0x01E1) ;0x01E1 MN_GETHMENU 
                If _GUICtrlMenu_IsMenu($hMenu) Then
                      
            If $itemToClick &lt;&gt; -1 Then
              
              ConsoleWrite(&quot;Click menu item direct.&quot;&amp; @CRLF); 
               For $i = 0 To _GUICtrlMenu_GetItemCount($hMenu) - 1
                Send (&quot;{DOWN}&quot;) 
                If $itemToClick = $i Then
                  ConsoleWrite(&quot;Click menu item :&quot; &amp;$itemToClick&amp; @CRLF);  
                  Sleep(1000)
                  Send (&quot;{ENTER}&quot;) 
                  ExitLoop
                  EndIf
                  
              Next 
              Exit(0)
            Else 
              $i=0
              For $i = 0 To _GUICtrlMenu_GetItemCount($hMenu) - 1
                 
                  Sleep(10)  
                  Local $sItemText = _GUICtrlMenu_GetItemText($hMenu, $i)
                  
                  ConsoleWrite($sItemText&amp;&quot;,item index:&quot;&amp;$i &amp; @CRLF); 
                  
                  If $sItemText = '' Then ContinueLoop    
                  
                  Send (&quot;{DOWN}&quot;)
                  ;If StringInStr($sItemText,$AntiVirusSoftName) &lt;&gt; 0 Then
                  If StringRegExp ($sItemText,$AntiVirusSoftName,0) =1 Then
                    ConsoleWrite(&quot;StringRegExp match,item index:&quot;&amp;$i &amp; @CRLF); 
                    ;MsgBox(0, &quot;HWnd&quot;, &quot;nod32&quot;)
                    ;$subviewid = _GUICtrlMenu_GetItemID($hMenu, $i)
                    ;_GUICtrlMenu_SetItemState($hMenu, $i, $MFS_CHECKED,True)
                    ;_GUICtrlMenu_SetItemDisabled($hMenu, $i)
                    ;Send (&quot;{ENTER}&quot;) 
                    Sleep(1000)
                    Send (&quot;{ENTER}&quot;)
                    ;ControlClick(&quot;&quot;, &quot;&quot;,$subviewid ,&quot;left&quot;) 
                    ExitLoop
                  EndIf
                    
              Next 
               If $i = (_GUICtrlMenu_GetItemCount($hMenu) - 1) Then ConsoleWrite(&quot;Not found,then click the first null menu.&quot; &amp; @CRLF) 
            EndIf
          Exit(0)
          EndIf
            
                ConsoleWrite(&quot;Not Menu hwnd.&quot;@CRLF)
      EndIf
      
     
      

EndFunc   ;==&gt;_WinEventProc
 
Func _SetWinEventHook($ieventMin, $ieventMax, $hMod, $pCallback, $iProcID, $iThreadID, $iFlags)
        Local $aRet
        
        $aRet = DllCall('user32.dll', 'ptr', 'SetWinEventHook', 'uint', $ieventMin, 'uint', $ieventMax, _
                        'hwnd', $hMod, 'ptr', $pCallback, 'dword', $iProcID, 'dword', $iThreadID, 'uint', $iFlags)
        
        If @error Or $aRet[0] = 0 Then Return SetError(1, 0, 0)
        Return $aRet[0]
EndFunc   ;==&gt;_SetWinEventHook
 
Func _UnhookWinEvent($hWinEventHook)
        Local $aRet
        
        $aRet = DllCall('user32.dll', 'int', 'UnhookWinEvent', 'ptr', $hWinEventHook)
        If @error Or $aRet[0] = 0 Then Return SetError(1, 0, 0)
        Return $aRet[0]
EndFunc   ;==&gt;_UnhookWinEvent</pre><p>附件下载：<a href='http://imzc.net/wp-content/uploads/2012/03/scan_menu.rar'>scan_menu</a></p>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/234/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Ruby多线程与同时使用autoit和watir处理popup弹框时的关系</title>
		<link>http://imzc.net/archives/231/</link>
		<comments>http://imzc.net/archives/231/#comments</comments>
		<pubDate>Mon, 26 Mar 2012 10:02:02 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[Ruby&Testing]]></category>

		<guid isPermaLink="false">http://imzc.net/?p=231</guid>
		<description><![CDATA[首先强调两个东西： 1.Ruby为用户线程，当任何一个线程被阻塞了，则其他所有的都会被阻塞。 2.watir在 [...]]]></description>
			<content:encoded><![CDATA[<p>首先强调两个东西：<br />
1.Ruby为用户线程，当任何一个线程被阻塞了，则其他所有的都会被阻塞。<br />
2.watir在遇到一个弹出框时（如IE6的证书错误警告框），当前程序就被阻塞了。<br />
因此，在使用watir时，遇到弹出框后，使用autoit ole处理时，就必须注意处理弹出框的先后顺序。<br />
实例： IE6,7,8在访问证书有问题的https网站时，弹出框的处理。</p><pre class="crayon-plain-tag">#coding: utf-8
#popupclicker.rb
require &quot;win32ole&quot;   
require &quot;win32/registry&quot; 
 
def get_ie_version
  wsh = WIN32OLE.new(&quot;WScript.Shell&quot;)
  value = wsh.RegRead &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Internet Explorer\\version&quot; 
  #wsh.RegWrite &quot;HKCR\foofile\shell\open\command\&quot;, &quot;REG_SZ&quot;, &quot;&quot;C:\...&quot; &quot;%1&quot;&quot;
  return  value[0].chr 
end
 
autoit=WIN32OLE.new(&quot;AutoItX3.Control&quot;); 
autoit.AutoItSetOption(&quot;WinTitleMatchMode&quot;, 2) 
WIN32OLE.codepage = WIN32OLE::CP_UTF8
#1=start, 2=subStr, 3=exact, 4=advanced, -1 to -4=Nocase
global_title = &quot;Internet Explorer&quot;
puts &quot;in process_cert_for_ie&quot;
if get_ie_version == &quot;6&quot; 
  puts &quot;ie6&quot;
  ie6title = &quot;安全警报&quot; 
  
  global_title = ie6title
  waitresult=autoit.WinWait(global_title, &quot;&quot;, 60) 
   
  if waitresult == 1
   autoit.WinActivate(global_title) 
   # autoit.ControlClick(global_title,&quot;&quot;,&quot;[CLASS:#32770]&quot;)
   puts &quot;find ok&quot;
   sleep 0.2
   autoit.Send(&quot;Y&quot;)
   sleep 0.1
   autoit.Send(&quot;Y&quot;) if autoit.WinWait(global_title, &quot;&quot;, 1) == 1 
   autoit.WinSetState(global_title, &quot;&quot;, 3) #@SW_MAXIMIZE  3
  end
  
 else
 puts &quot;ie 7 8&quot; 
  waitresult=autoit.WinWait(global_title, &quot;&quot;, 60) 
  sleep 1;
  if waitresult == 1
   autoit.WinActivate(global_title)
   puts &quot;find ok&quot; 
   #include(&quot;IE.au3&quot;)
   # _IELinkClickByText ( 对象变量, &quot;链接文字&quot; [, 索引 = 0], 等待 = 1]] )
 
   autoit.WinSetState(global_title, &quot;&quot;, 3) #@SW_MAXIMIZE  3
   autoit.ControlClick(global_title,&quot;&quot;,&quot;[CLASS:Internet Explorer_Server; INSTANCE:1]&quot;)
   sleep 1
   autoit.Send(&quot;{TAB}&quot;)
   sleep 1
   autoit.Send(&quot;{TAB}&quot;)
   sleep 1
   autoit.Send(&quot;{ENTER}&quot;) 
  end
end</pre><p>&nbsp;</p><pre class="crayon-plain-tag">#coding: utf-8
require 'rubygems'
gem 'watir','1.8.1'
require 'win32ole';  
require 'win32/registry'
require 'watir'

 
      
def process_cert_for_ie 
puts &quot;process_cert_for_ie system:&quot;
file=File.expand_path(File.join(File.dirname(__FILE__),&quot;popupclicker.rb&quot;))
   
begin
          thread_id = Thread.new do 
            system(&quot;ruby -Ku #{file}&quot;) 
           end
          thread_id.join(5)
rescue
          raise  Exception, &quot;Problem confirm&quot;
 end
        
      
end
 
webui_url = &quot;https://libzc.com&quot;
ie = Watir::Browser.new 
ie.bring_to_front 
ie.maximize
process_cert_for_ie
ie.goto(webui_url)

#when comfirmed cert error alert ,it wastes time to load web page completely
10.times do
# ie = Watir::IE.attach(:url,webui_url) 
 break if ie.link(:text,/Ruby\&amp;Testing/).exists?
 sleep 5
 end
 ie.link(:text,/Ruby\&amp;Testing/).click</pre><p></p>
<p></p><pre class="crayon-plain-tag">#popupclicker.rb Optimization
  waitresult=0
  10.times do
 # waitresult=autoit.WinWait(global_title, &quot;&quot;, 60) 
  waitresult=autoit.WinExists(global_title)
  break if waitresult==1 
  sleep 5
  #Recommended to use WinExists to prevent blocked.
  end</pre><p></p>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/231/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Ruby使用C/C++扩展(包括windows和linux)</title>
		<link>http://imzc.net/archives/229/</link>
		<comments>http://imzc.net/archives/229/#comments</comments>
		<pubDate>Sat, 24 Mar 2012 03:00:49 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[Ruby&Testing]]></category>

		<guid isPermaLink="false">http://imzc.net/?p=229</guid>
		<description><![CDATA[Ruby使用C/C++扩展，可以让ruby变得很强大。 本文根据http://raylinn.iteye.co [...]]]></description>
			<content:encoded><![CDATA[<p>Ruby使用C/C++扩展，可以让ruby变得很强大。<br />
本文根据<a href="http://raylinn.iteye.com/blog/629329" target="_blank">http://raylinn.iteye.com/blog/629329</a>学习而来。<br />
先说说流程，ruby C/C++扩展，先由mkmf生成Makefile,之后再用make(linux),nmake(windows vc++)生成动态链接库。<br />
放到ruby对应目录后，直接require即可。<br />
步骤：<br />
1.编写C++文件（建议C/C++都用.cpp吧）<br />
HelloTest.cpp</p><pre class="crayon-plain-tag">#include&lt;stdio.h&gt;   
#include&lt;ruby.h&gt;   

class TestClass  
{  
public:  
    TestClass(void){};  
    ~TestClass(void){};  

    void SayHello(char* msg)  
    {  
               printf(&quot;Ruby C/C++ extention Example cdlz.\n&quot;);  
               printf(&quot;Your Name is: %s\n&quot;,msg);  
    }  
};  

//VALUE self这个是不变的。指向自己。 第二个： VALUE name则是我们这个函数需要的参数。   
VALUE method_sayhello(VALUE self,VALUE name){  
    long length=0;  
    char* yourname = rb_str2cstr(name, &amp;amp;length);  //rb_str2cstr，转换到C语言的字符串
    TestClass* test=new TestClass();  
    test-&amp;gt;SayHello(yourname);  
    delete test;  
	return rb_str_new2(yourname); //rb_str_new2，由C语言的字符串转换为Ruby的String。
};  

VALUE method_cfunction(VALUE self, VALUE va, VALUE vb)
{
	int a = NUM2INT(va);
	int b = NUM2INT(vb);

	return INT2NUM(a+b);
}

VALUE hellotest = Qnil; //Qnil 即为 NULL 
/*
如果全部都是C的，则需要加上extern &quot;C&quot; void Init_HelloTest()
*/
void Init_HelloTest(){  
  hellotest = rb_define_module(&quot;HelloTest&quot;);  
  //定义一个ruby方法，在ruby中调用。最后一个参数为 ruby方法的参数个数 
  rb_define_method(hellotest, &quot;sayhello&quot;, RUBY_METHOD_FUNC(method_sayhello), 1);  
  rb_define_method(hellotest, &quot;cfunction_plus&quot;, RUBY_METHOD_FUNC(method_cfunction), 2);   
};</pre><p>上述代码，实现了两个ruby方法：sayhello和cfunction_plus<br />
像返回值，参数值必须要注意类型，C和ruby之间的转换，可以参见Programming Ruby一书第280页。同时也有说到其他的方法。</p>
<p>2. extconf.rb</p><pre class="crayon-plain-tag">require 'mkmf'  

extension_name = &quot;HelloTest&quot; 
dirbase=&quot;D:/ruby/vc&quot;
ruby_lib_base= dirbase+&quot;/lib&quot;
ruby_include_base= dirbase+&quot;/include&quot;

dir_config(extension_name)  
#如果是windows则取消下面注释，注意，目录名称不能有空格
#dir_config(extension_name,ruby_include_base,ruby_lib_base)

create_makefile(extension_name)</pre><p>之后运行 ruby extconf.rb,以便生成Makefile文件。</p>
<p>linux下，一般直接运行make即可生成so，然后make install 即可。<br />
windows下，必须装有visual studio，然后使用nmake即可。<br />
visual studio要注意版本问题，直接去掉ruby的头文件判断吧:<br />
ruby安装目录下： D:\ruby\ruby186\lib\ruby\1.8\i386-mswin32<br />
config.h第二行注释掉即可：<br />
#if _MSC_VER != 1200<br />
//#error MSC version unmatch<br />
#endif<br />
然后使用nmake编译。<br />
关于VC++ 7.0以上版本有一些特殊情况，就是manifest文件，这是发布一个.exe的可执行文件或者一个.dll的动态库所需要的，默认情况下，.manifest文件需要内嵌到你的类库中去。可使用下述批处理脚本：</p><pre class="crayon-plain-tag">ruby extconf.rb  
nmake  clean
nmake  
mt -manifest %1.so.manifest -outputresource:%1.so;2  
nmake install</pre><p>如果没有错误，编译通过，windows下可以使用如下命令查看dll导出函数情况：<br />
dumpbin -exports HelloTest.so<br />
。。。<br />
1 0 00001120 Init_HelloTest = ?Init_HelloTest@@YAXXZ (void __cdecl Init_HelloTest(void))<br />
。。。<br />
linux下： nm -g HelloTest.so<br />
最后附上ruby测试脚本：</p><pre class="crayon-plain-tag">require &quot;HelloTest&quot;

include HelloTest  

puts HelloTest.sayhello(&quot;aaa&quot;)
puts HelloTest.cfunction_plus(111,222)

puts HelloTest.methods - Object.methods</pre><p>注意：如果是在扩展中有输出，则只有在ruby的输出全部打印完毕后，才会有扩展中的输出(直接使用ruby test.rb，顺序有正常。。。暂时无解。。。)。<br />
本例的打印结果：</p>
<blockquote><p>
aaa<br />
333<br />
Ruby C/C++ extention Example cdlz.<br />
Your Name is: aaa</p></blockquote>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/229/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>
