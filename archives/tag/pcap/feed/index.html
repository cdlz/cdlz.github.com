<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Only For Sunshine~ &#187; pcap</title>
	<atom:link href="http://imzc.net/archives/tag/pcap/feed/" rel="self" type="application/rss+xml" />
	<link>http://imzc.net</link>
	<description>-More Thinking,And Then Just do it~~~</description>
	<lastBuildDate>Thu, 20 Sep 2012 16:40:36 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=3.4.2</generator>
		<item>
		<title>解析pcap文件及读取实现源码</title>
		<link>http://imzc.net/archives/181/</link>
		<comments>http://imzc.net/archives/181/#comments</comments>
		<pubDate>Tue, 24 Jan 2012 16:55:40 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[C/C++]]></category>
		<category><![CDATA[pcap]]></category>

		<guid isPermaLink="false">http://imzc.net/?p=181</guid>
		<description><![CDATA[下面pcap文件格式介绍是在网上转的,根据理解，写了个程序来进行解析pcap文件，后续再实现合并pcap功能( [...]]]></description>
			<content:encoded><![CDATA[<p>下面pcap文件格式介绍是在<a href="http://blog.csdn.net/in7deforever/article/details/6460595" target="_blank">网上转的</a>,根据理解，写了个程序来进行解析pcap文件，后续再实现合并pcap功能(wireshark已经自带命令行合并pcap文件工具，在这里只是为了分析pcap文件和学习)。<br />
==========================<br />
默认的*.pcap文件保存格式。</p>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/ALEKS86/1%29%20Pcap%E6%96%87%E4%BB%B6%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E5%92%8CPcap%E6%96%87%E4%BB%B6%E5%A4%B4%E7%BB%93%E6%9E%84.gif" alt="" align="textTop" data-ke-src="http://p.blog.csdn.net/images/p_blog_csdn_net/ALEKS86/1%29%20Pcap%E6%96%87%E4%BB%B6%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E5%92%8CPcap%E6%96%87%E4%BB%B6%E5%A4%B4%E7%BB%93%E6%9E%84.gif" /></p>
<p>Pcap文件头24B各字段说明：</p>
<div>Magic：4B：0x1A 2B 3C 4D:用来标示文件的开始</div>
<div>Major：2B，0&#215;02 00:当前文件主要的版本号</div>
<div>Minor：2B，0&#215;04 00当前文件次要的版本号</div>
<div>ThisZone：4B当地的标准时间；全零</div>
<div>SigFigs：4B时间戳的精度；全零</div>
<div>SnapLen：4B最大的存储长度</div>
<div>LinkType：4B链路类型</div>
<div>常用类型：</div>
<div>0            BSD loopback devices, except for later OpenBSD<br />
1            Ethernet, and Linux loopback devices<br />
6            802.5 Token Ring<br />
7            ARCnet<br />
8            SLIP<br />
9            PPP<br />
10           FDDI<br />
100         LLC/SNAP-encapsulated ATM<br />
101         &#8220;raw IP&#8221;, with no link<br />
102         BSD/OS SLIP<br />
103         BSD/OS PPP<br />
104         Cisco HDLC<br />
105         802.11<br />
108         later OpenBSD loopback devices (with the AF_value in network byte order)<br />
113         special Linux &#8220;cooked&#8221; capture<br />
114         LocalTalk</div>
<div></div>
<div><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/ALEKS86/2%EF%BC%89Packet%20%E5%8C%85%E5%A4%B4%EF%BC%8816B%EF%BC%89%E5%92%8CPacket%E6%95%B0%E6%8D%AE%E7%BB%84%E6%88%90.gif" alt="" align="textTop" data-ke-src="http://p.blog.csdn.net/images/p_blog_csdn_net/ALEKS86/2%EF%BC%89Packet%20%E5%8C%85%E5%A4%B4%EF%BC%8816B%EF%BC%89%E5%92%8CPacket%E6%95%B0%E6%8D%AE%E7%BB%84%E6%88%90.gif" /></div>
<div><strong>Packet </strong><strong>包头和Packet</strong><strong>数据组成</strong></div>
<div>字段说明：</div>
<div>Timestamp：时间戳高位，精确到seconds</div>
<div>Timestamp：时间戳低位，精确到microseconds</div>
<div>Caplen：当前数据区的长度，即抓取到的数据帧长度，由此可以得到下一个数据帧的位置。</div>
<div>Len：离线数据长度<strong>：</strong>网络中实际数据帧的长度，一般不大于caplen，多数情况下和Caplen数值相等。</div>
<div><strong>Packet </strong><strong>数据</strong>： 即 Packet（通常就是链路层的数据帧）具体内容，长度就是Caplen，这个长度的后面，就是当前PCAP文件中存放的下一个Packet数据包，也就 是说：PCAP文件里面并没有规定捕获的Packet数据包之间有什么间隔字符串，下一组数据在文件中的起始位置。我们需要靠第一个Packet包确定。 最后，Packet数据部分的格式其实就是标准的网路协议格式了可以任何网络教材上找得到。</div>
<div>===========================</div>
<div>我的实现：</div>
<div>
<pre class="crayon-plain-tag">//
//  pcap.h
//  pcaptest
//
//  Created by zc on 12-1-24.
//  Copyright 2012年 __MyCompanyName__. All rights reserved.
//

#ifndef pcaptest_pcap_h
#define pcaptest_pcap_h

typedef unsigned int  bpf_u_int32;
typedef unsigned short  u_short;
typedef int bpf_int32;

/*
 Pcap文件头24B各字段说明：
 Magic：4B：0x1A 2B 3C 4D:用来标示文件的开始
 Major：2B，0x02 00:当前文件主要的版本号     
 Minor：2B，0x04 00当前文件次要的版本号
 ThisZone：4B当地的标准时间；全零
 SigFigs：4B时间戳的精度；全零
 SnapLen：4B最大的存储长度    
 LinkType：4B链路类型
 常用类型：
 　0            BSD loopback devices, except for later OpenBSD
 1            Ethernet, and Linux loopback devices
 6            802.5 Token Ring
 7            ARCnet
 8            SLIP
 9            PPP
 */
typedef struct pcap_file_header {
	bpf_u_int32 magic;
	u_short version_major;
	u_short version_minor;
	bpf_int32 thiszone;    
	bpf_u_int32 sigfigs;   
	bpf_u_int32 snaplen;   
	bpf_u_int32 linktype;  
}pcap_file_header;

/*
 Packet 包头和Packet数据组成
 字段说明：
 Timestamp：时间戳高位，精确到seconds     
 Timestamp：时间戳低位，精确到microseconds
 Caplen：当前数据区的长度，即抓取到的数据帧长度，由此可以得到下一个数据帧的位置。
 Len：离线数据长度：网络中实际数据帧的长度，一般不大于caplen，多数情况下和Caplen数值相等。
 Packet 数据：即 Packet（通常就是链路层的数据帧）具体内容，长度就是Caplen，这个长度的后面，就是当前PCAP文件中存放的下一个Packet数据包，也就 是说：PCAP文件里面并没有规定捕获的Packet数据包之间有什么间隔字符串，下一组数据在文件中的起始位置。我们需要靠第一个Packet包确定。
 */

typedef struct  timestamp{
	bpf_u_int32 timestamp_s;
	bpf_u_int32 timestamp_ms;
}timestamp;

typedef struct pcap_header{
	timestamp ts;
	bpf_u_int32 capture_len;
	bpf_u_int32 len;
	
}pcap_header;


void prinfPcapFileHeader(pcap_file_header *pfh);
void printfPcapHeader(pcap_header *ph);
void printPcap(void * data,size_t size);

#endif</pre><br />
<pre class="crayon-plain-tag">//
//  pcap.c
//  pcaptest
//
//  Created by zc on 12-1-24.
//  Copyright 2012年 __MyCompanyName__. All rights reserved.
//

#include &lt;stdio.h&gt;
#include &quot;pcap.h&quot;

void prinfPcapFileHeader(pcap_file_header *pfh){
	if (pfh==NULL) {
		return;
	}
	printf(&quot;=====================\n&quot;
		   &quot;magic:0x%0x\n&quot;
		   &quot;version_major:%u\n&quot;
		   &quot;version_minor:%u\n&quot;
		   &quot;thiszone:%d\n&quot;
		   &quot;sigfigs:%u\n&quot;
		   &quot;snaplen:%u\n&quot;
		   &quot;linktype:%u\n&quot;
		   &quot;=====================\n&quot;,
		   pfh-&gt;magic,
		   pfh-&gt;version_major,
		   pfh-&gt;version_minor,
		   pfh-&gt;thiszone,
		   pfh-&gt;sigfigs,
		   pfh-&gt;snaplen,
		   pfh-&gt;linktype);
}

void printfPcapHeader(pcap_header *ph){
	if (ph==NULL) {
		return;
	}
	printf(&quot;=====================\n&quot;
		   &quot;ts.timestamp_s:%u\n&quot;
		   &quot;ts.timestamp_ms:%u\n&quot;
		   &quot;capture_len:%u\n&quot;
		   &quot;len:%d\n&quot;
		   &quot;=====================\n&quot;,
		   ph-&gt;ts.timestamp_s,
		   ph-&gt;ts.timestamp_ms,
		   ph-&gt;capture_len,
		   ph-&gt;len);
	
	
}

void printPcap(void * data,size_t size){
	unsigned  short iPos = 0;
	//int * p = (int *)data;
	//unsigned short* p = (unsigned short *)data;
	if (data==NULL) {
		return;
	}
	
	printf(&quot;\n==data:0x%x,len:%lu=========&quot;,data,size);
	
	for (iPos=0; iPos &lt; size/sizeof(unsigned short); iPos++) {
		//printf(&quot; %x &quot;,(int)( * (p+iPos) ));
		//unsigned short a = ntohs(p[iPos]);
		 		
		unsigned short a = ntohs( *((unsigned short *)data + iPos ) );
		if (iPos%8==0) printf(&quot;\n&quot;);
		if (iPos%4==0) printf(&quot; &quot;);
		
		printf(&quot;%04x&quot;,a);
		
		
	}
	/*
	 for (iPos=0; iPos &lt;= size/sizeof(int); iPos++) {
		//printf(&quot; %x &quot;,(int)( * (p+iPos) ));
		int a = ntohl(p[iPos]);
		
		//int a = ntohl( *((int *)data + iPos ) );
		if (iPos %4==0) printf(&quot;\n&quot;);
	 
		printf(&quot;%08x &quot;,a);
		
		
	}
	 */
	printf(&quot;\n============\n&quot;);
}</pre><br />
<pre class="crayon-plain-tag">//
//  main.c
//  pcaptest
//
//  Created by zc on 12-1-24.
//  Copyright 2012年 __MyCompanyName__. All rights reserved.
//

#include &lt;stdio.h&gt;
#include &lt;arpa/inet.h&gt;
#include &quot;pcap.h&quot;

#define PCAP_FILE &quot;ping.pcap&quot;
#define MAX_ETH_FRAME 1514
#define ERROR_FILE_OPEN_FAILED -1
#define ERROR_MEM_ALLOC_FAILED -2
#define ERROR_PCAP_PARSE_FAILED -3


int main (int argc, const char * argv[])
{
 
	printf(&quot;sizeof:int %lu,unsigned int %lu,char %lu,unsigned char %lu,short:%lu,unsigned short:%lu\n&quot;,
		    sizeof(int),sizeof(unsigned int),sizeof(char),sizeof(unsigned char),sizeof(short),sizeof(unsigned short));
	
	pcap_file_header  pfh;
	pcap_header  ph;
	int count=0;
	void * buff = NULL;
	int readSize=0;
	int ret = 0;
	
	FILE *fp = fopen(PCAP_FILE, &quot;rw&quot;);
	
	if (fp==NULL) {
		fprintf(stderr, &quot;Open file %s error.&quot;,PCAP_FILE);
		ret = ERROR_FILE_OPEN_FAILED;
		goto ERROR;
	}
	
	fread(&amp;pfh, sizeof(pcap_file_header), 1, fp);	
	prinfPcapFileHeader(&amp;pfh);
	//fseek(fp, 0, sizeof(pcap_file_header));
	
	buff = (void *)malloc(MAX_ETH_FRAME);
	for (count=1; ; count++) {
		memset(buff,0,MAX_ETH_FRAME);
		//read pcap header to get a packet
		//get only a pcap head count .
		readSize=fread(&amp;ph, sizeof(pcap_header), 1, fp);
		if (readSize&lt;=0) {
			break;
		}
		printfPcapHeader(&amp;ph);
				
		
		if (buff==NULL) {
			fprintf(stderr, &quot;malloc memory failed.\n&quot;);
			ret = ERROR_MEM_ALLOC_FAILED;
			goto ERROR;
		}
		
		//get a packet contents.
		//read ph.capture_len bytes.
		readSize=fread(buff,1,ph.capture_len, fp);
		if (readSize != ph.capture_len) {
			free(buff);
			fprintf(stderr, &quot;pcap file parse error.\n&quot;);
			ret = ERROR_PCAP_PARSE_FAILED;
			goto ERROR;
		}
		printPcap(buff, ph.capture_len);
		
		
		printf(&quot;===count:%d,readSize:%d===\n&quot;,count,readSize);
		
		if (feof(fp) || readSize &lt;=0 ) { 
			break;
		}
	}
	
ERROR:
	//free
	if (buff) {
		free(buff);
		buff=NULL;
	} 
	if (fp) {
		fclose(fp);
		fp=NULL;
	}	
	
    return ret;
}</pre><br />
Makefile:<br />
<pre class="crayon-plain-tag">objects = main.o pcap.o

pcaptest : $(objects)
	gcc -o pcaptest  $(objects)

main.o:pcap.h
pcap.o:pcap.h

.PHONY : clean
clean :
	rm pcaptest  $(objects)</pre>
</div>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/181/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
	</channel>
</rss>
