<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Only For Sunshine~ &#187; ls</title>
	<atom:link href="http://imzc.net/archives/tag/ls/feed/" rel="self" type="application/rss+xml" />
	<link>http://imzc.net</link>
	<description>-More Thinking,And Then Just do it~~~</description>
	<lastBuildDate>Thu, 20 Sep 2012 16:40:36 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=3.4.2</generator>
		<item>
		<title>递归列出目录下文件的全路径</title>
		<link>http://imzc.net/archives/20/</link>
		<comments>http://imzc.net/archives/20/#comments</comments>
		<pubDate>Fri, 27 Aug 2010 01:57:00 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[C/C++]]></category>
		<category><![CDATA[c]]></category>
		<category><![CDATA[ls]]></category>

		<guid isPermaLink="false">http://imzc.net/?action=show&#038;id=123</guid>
		<description><![CDATA[由于ls -R,递归目录列出的信息格式在需要全路径时不好处理,因此专门写这一程序.
 linux下编译:  gcc lsdir.c -o lsdir -O
 windows下编译:使用codeblocks即可.
 Useage: lsdir
 list the full path of a dir's subdirs or files,not same as  "ls -R".
 -h,    print this message.
 -d dirname,    recursely print full path of files.
 -D,    print dirs only.
 -F,    print files only.
 -A,    print files and dirs(defult).
 -R,    print dir recurse(defult).
 -r,    only print current dir.
 none argvs,    print current path.]]></description>
			<content:encoded><![CDATA[<p>本程序是在网络搜索到的目录遍历用法加以修改,增加功能实现的.所以欢迎转载使用.</p><pre class="crayon-plain-tag">/*
 由于ls -R,递归目录列出的信息格式在需要全路径时不好处理,因此专门写这一程序.
 linux下编译:&nbsp; gcc lsdir.c -o lsdir -O
 windows下编译:使用codeblocks即可.
 Useage: lsdir
 list the full path of a dir's subdirs or files,not same as&nbsp; &quot;ls -R&quot;.
 -h,&nbsp;&nbsp;&nbsp; print this message.
 -d dirname,&nbsp;&nbsp;&nbsp; recursely print full path of files.
 -D,&nbsp;&nbsp;&nbsp; print dirs only.
 -F,&nbsp;&nbsp;&nbsp; print files only.
 -A,&nbsp;&nbsp;&nbsp; print files and dirs(defult).
 -R,&nbsp;&nbsp;&nbsp; print dir recurse(defult).
 -r,&nbsp;&nbsp;&nbsp; only print current dir.
 none argvs,&nbsp;&nbsp;&nbsp; print current path.
 ---zhouchuan,2010.8.27.
*/
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

#ifdef __WIN32__&nbsp; // OS_COMPAT
//__WINDOWS__
 char path_sep = '\\';
#else
 char path_sep = '/';
#endif&nbsp;&nbsp; // !__WINDOWS__

#define DIR_MAX_LEN 1000
#define PRINT_DIR_ONLY 0
#define PRINT_FILE_ONLY 1
#define PRINT_FILE_AND_DIR 2

#define DIR_RECURSE_NO 0
#define DIR_RECURSE_YES&nbsp; 1

int g_PRINT_TYPE = PRINT_FILE_AND_DIR; //默认列出所有目录及文件
int g_DIR_RECURSE = DIR_RECURSE_YES;//默认递归

void printdir(char *dir, int depth)
{
 DIR *dp;
 struct dirent *entry;
 struct stat statbuf;
 char&nbsp; buff[DIR_MAX_LEN];


 if((dp = opendir(dir)) == NULL) {
 fprintf(stderr, &quot;cannot open directory: %s\n &quot;, dir);
 return;
 }
 chdir(dir);
 getcwd(buff,DIR_MAX_LEN);
 while((entry = readdir(dp)) != NULL) {
 //lstat(entry-&amp;gt; d_name,&amp;amp;statbuf);
 stat(entry-&amp;gt; d_name,&amp;amp;statbuf);
 if(S_ISDIR(statbuf.st_mode)) {
 /* Found a directory, but ignore . and .. */
 if(strcmp( &quot;.&quot;,entry-&amp;gt; d_name) == 0 ||strcmp( &quot;..&quot;,entry-&amp;gt; d_name) == 0)
 continue;
 // printf( &quot;%*s%s/\n &quot;,depth, &quot; &quot;,entry-&amp;gt; d_name);
 if(g_PRINT_TYPE != PRINT_FILE_ONLY)
 printf( &quot;%s%c%s%c\n &quot;,buff,path_sep,entry-&amp;gt; d_name,path_sep);

 /* Recurse at a new indent level */
 if(g_DIR_RECURSE==DIR_RECURSE_YES)
 printdir(entry-&amp;gt; d_name,depth+4);
 }else{
 //is a file
 if(g_PRINT_TYPE !=PRINT_DIR_ONLY){
 printf( &quot;%s%c%s\n &quot;,buff,path_sep,entry-&amp;gt; d_name);
 }
 }
 }
 chdir( &quot;..&quot;);
 closedir(dp);
}

void useage(){
 printf(&quot;====================================================================\n&quot;);
 printf(&quot;Useage: lsdir\n&quot;);
 printf(&quot; list the full path of a dir's subdirs or files,not same as&nbsp; \&quot;ls -R\&quot;. \n&quot;);
 printf(&quot; -h,\tprint this message.\n&quot;);
 printf(&quot; -d dirname,\trecursely print full path of files. \n&quot;);
 printf(&quot; -D,\tprint dirs only. \n&quot;);
 printf(&quot; -F,\tprint files only. \n&quot;);
 printf(&quot; -A,\tprint files and dirs(defult). \n&quot;);
 printf(&quot; -R,\tprint dir recurse(defult). \n&quot;);
 printf(&quot; -r,\tonly print current dir. \n&quot;);
 printf(&quot; none argvs,\tprint current path.\n&quot;);
 printf(&quot;\t\t\t\t---zhouchuan,2010.8.27.\n&quot;);
 printf(&quot;====================================================================\n&quot;);
}

int main(int argc, char* argv[])
{
 int oc;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*选项字符 */
 char *b_opt_arg;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*选项参数字串 */
 char *topdir=NULL, pwd[2]= &quot;.&quot;;

 while((oc = getopt(argc, argv, &quot;hd:DFARr&quot;)) != -1)
 {
 switch(oc)
 {
 case 'h':
 //-h,则打印使用方法
 useage();
 return 0;
 break;
 case 'D':
 g_PRINT_TYPE =PRINT_DIR_ONLY ;
 break ;
 case 'F':
 g_PRINT_TYPE =PRINT_FILE_ONLY ;
 break ;
 case 'A':
 g_PRINT_TYPE =PRINT_FILE_AND_DIR ;
 break ;
 case 'R':
 g_DIR_RECURSE = DIR_RECURSE_YES;
 //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot; DIR_RECURSE_YES&quot;);
 break;
 case 'r':
 g_DIR_RECURSE = DIR_RECURSE_NO;
 //&nbsp;&nbsp;&nbsp; printf(&quot; DIR_RECURSE_NO&quot;);
 break;
 case 'd':
 b_opt_arg = optarg;
 //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;dir %s\n&quot;, optarg);
 topdir=optarg;
 break;
 }
 }
 if(topdir==NULL)
 {
 //&nbsp;&nbsp; printf(&quot;dir current&quot;);
 topdir=pwd;
 }
 printf(&quot;Directory scan of \&quot;%s\&quot;:\n &quot;,topdir);
 printdir(topdir,0);
 printf(&quot;===Done.\n &quot;);

 return 0;
}</pre><p>在很多时候,我们可能需要得到一个目录下所有文件的全路径,以供后续计算.<br />
如要计算当前目录所有文件的md5值:</p>
<div>
<p>./lsdir -F|grep &#8221;/&#8221;|while read LINE;do md5sum $LINE;done;</p>
<p>源码: <a href="http://imzc.net/wp-content/uploads/2010/08/lsdir.zip">lsdir</a></p>
</div>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/20/feed/</wfw:commentRss>
		<slash:comments>296</slash:comments>
		</item>
	</channel>
</rss>
