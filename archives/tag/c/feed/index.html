<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Only For Sunshine~ &#187; c</title>
	<atom:link href="http://imzc.net/archives/tag/c/feed/" rel="self" type="application/rss+xml" />
	<link>http://imzc.net</link>
	<description>-More Thinking,And Then Just do it~~~</description>
	<lastBuildDate>Mon, 09 Jul 2012 03:09:37 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=3.4.1</generator>
		<item>
		<title>递归列出目录下文件的全路径</title>
		<link>http://imzc.net/archives/20/</link>
		<comments>http://imzc.net/archives/20/#comments</comments>
		<pubDate>Fri, 27 Aug 2010 01:57:00 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[C/C++]]></category>
		<category><![CDATA[c]]></category>
		<category><![CDATA[ls]]></category>

		<guid isPermaLink="false">http://imzc.net/?action=show&#038;id=123</guid>
		<description><![CDATA[由于ls -R,递归目录列出的信息格式在需要全路径时不好处理,因此专门写这一程序.
 linux下编译:  gcc lsdir.c -o lsdir -O
 windows下编译:使用codeblocks即可.
 Useage: lsdir
 list the full path of a dir's subdirs or files,not same as  "ls -R".
 -h,    print this message.
 -d dirname,    recursely print full path of files.
 -D,    print dirs only.
 -F,    print files only.
 -A,    print files and dirs(defult).
 -R,    print dir recurse(defult).
 -r,    only print current dir.
 none argvs,    print current path.]]></description>
			<content:encoded><![CDATA[<p>本程序是在网络搜索到的目录遍历用法加以修改,增加功能实现的.所以欢迎转载使用.</p>

<div class="wp_syntax"><table><tr><td class="line_numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
</pre></td><td class="code"><pre class="c" style="font-family:monospace;"><span style="color: #808080; font-style: italic;">/*
 由于ls -R,递归目录列出的信息格式在需要全路径时不好处理,因此专门写这一程序.
 linux下编译:  gcc lsdir.c -o lsdir -O
 windows下编译:使用codeblocks即可.
 Useage: lsdir
 list the full path of a dir's subdirs or files,not same as  &quot;ls -R&quot;.
 -h,    print this message.
 -d dirname,    recursely print full path of files.
 -D,    print dirs only.
 -F,    print files only.
 -A,    print files and dirs(defult).
 -R,    print dir recurse(defult).
 -r,    only print current dir.
 none argvs,    print current path.
 ---zhouchuan,2010.8.27.
*/</span>
<span style="color: #339933;">#include &amp;lt;stdio.h&amp;gt;</span>
<span style="color: #339933;">#include &amp;lt;dirent.h&amp;gt;</span>
<span style="color: #339933;">#include &amp;lt;string.h&amp;gt;</span>
<span style="color: #339933;">#include &amp;lt;sys/stat.h&amp;gt;</span>
<span style="color: #339933;">#include &amp;lt;sys/types.h&amp;gt;</span>
<span style="color: #339933;">#include &amp;lt;unistd.h&amp;gt;</span>
&nbsp;
<span style="color: #339933;">#ifdef __WIN32__  // OS_COMPAT</span>
<span style="color: #666666; font-style: italic;">//__WINDOWS__</span>
 <span style="color: #993333;">char</span> path_sep <span style="color: #339933;">=</span> <span style="color: #ff0000;">'<span style="color: #000099; font-weight: bold;">\\</span>'</span><span style="color: #339933;">;</span>
<span style="color: #339933;">#else</span>
 <span style="color: #993333;">char</span> path_sep <span style="color: #339933;">=</span> <span style="color: #ff0000;">'/'</span><span style="color: #339933;">;</span>
<span style="color: #339933;">#endif   // !__WINDOWS__</span>
&nbsp;
<span style="color: #339933;">#define DIR_MAX_LEN 1000</span>
<span style="color: #339933;">#define PRINT_DIR_ONLY 0</span>
<span style="color: #339933;">#define PRINT_FILE_ONLY 1</span>
<span style="color: #339933;">#define PRINT_FILE_AND_DIR 2</span>
&nbsp;
<span style="color: #339933;">#define DIR_RECURSE_NO 0</span>
<span style="color: #339933;">#define DIR_RECURSE_YES  1</span>
&nbsp;
<span style="color: #993333;">int</span> g_PRINT_TYPE <span style="color: #339933;">=</span> PRINT_FILE_AND_DIR<span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">//默认列出所有目录及文件</span>
<span style="color: #993333;">int</span> g_DIR_RECURSE <span style="color: #339933;">=</span> DIR_RECURSE_YES<span style="color: #339933;">;</span><span style="color: #666666; font-style: italic;">//默认递归</span>
&nbsp;
<span style="color: #993333;">void</span> printdir<span style="color: #009900;">&#40;</span><span style="color: #993333;">char</span> <span style="color: #339933;">*</span>dir<span style="color: #339933;">,</span> <span style="color: #993333;">int</span> depth<span style="color: #009900;">&#41;</span>
<span style="color: #009900;">&#123;</span>
 DIR <span style="color: #339933;">*</span>dp<span style="color: #339933;">;</span>
 <span style="color: #993333;">struct</span> dirent <span style="color: #339933;">*</span>entry<span style="color: #339933;">;</span>
 <span style="color: #993333;">struct</span> stat statbuf<span style="color: #339933;">;</span>
 <span style="color: #993333;">char</span>  buff<span style="color: #009900;">&#91;</span>DIR_MAX_LEN<span style="color: #009900;">&#93;</span><span style="color: #339933;">;</span>
&nbsp;
&nbsp;
 <span style="color: #b1b100;">if</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#40;</span>dp <span style="color: #339933;">=</span> opendir<span style="color: #009900;">&#40;</span>dir<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span> <span style="color: #339933;">==</span> NULL<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
 fprintf<span style="color: #009900;">&#40;</span>stderr<span style="color: #339933;">,</span> <span style="color: #ff0000;">&quot;cannot open directory: %s<span style="color: #000099; font-weight: bold;">\n</span> &quot;</span><span style="color: #339933;">,</span> dir<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #b1b100;">return</span><span style="color: #339933;">;</span>
 <span style="color: #009900;">&#125;</span>
 chdir<span style="color: #009900;">&#40;</span>dir<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 getcwd<span style="color: #009900;">&#40;</span>buff<span style="color: #339933;">,</span>DIR_MAX_LEN<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #b1b100;">while</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#40;</span>entry <span style="color: #339933;">=</span> readdir<span style="color: #009900;">&#40;</span>dp<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span> <span style="color: #339933;">!=</span> NULL<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
 <span style="color: #666666; font-style: italic;">//lstat(entry-&amp;gt; d_name,&amp;amp;statbuf);</span>
 stat<span style="color: #009900;">&#40;</span>entry<span style="color: #339933;">-&amp;</span>gt<span style="color: #339933;">;</span> d_name<span style="color: #339933;">,&amp;</span>amp<span style="color: #339933;">;</span>statbuf<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #b1b100;">if</span><span style="color: #009900;">&#40;</span>S_ISDIR<span style="color: #009900;">&#40;</span>statbuf.<span style="color: #202020;">st_mode</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
 <span style="color: #808080; font-style: italic;">/* Found a directory, but ignore . and .. */</span>
 <span style="color: #b1b100;">if</span><span style="color: #009900;">&#40;</span>strcmp<span style="color: #009900;">&#40;</span> <span style="color: #ff0000;">&quot;.&quot;</span><span style="color: #339933;">,</span>entry<span style="color: #339933;">-&amp;</span>gt<span style="color: #339933;">;</span> d_name<span style="color: #009900;">&#41;</span> <span style="color: #339933;">==</span> <span style="color: #0000dd;">0</span> <span style="color: #339933;">||</span>strcmp<span style="color: #009900;">&#40;</span> <span style="color: #ff0000;">&quot;..&quot;</span><span style="color: #339933;">,</span>entry<span style="color: #339933;">-&amp;</span>gt<span style="color: #339933;">;</span> d_name<span style="color: #009900;">&#41;</span> <span style="color: #339933;">==</span> <span style="color: #0000dd;">0</span><span style="color: #009900;">&#41;</span>
 <span style="color: #b1b100;">continue</span><span style="color: #339933;">;</span>
 <span style="color: #666666; font-style: italic;">// printf( &quot;%*s%s/\n &quot;,depth, &quot; &quot;,entry-&amp;gt; d_name);</span>
 <span style="color: #b1b100;">if</span><span style="color: #009900;">&#40;</span>g_PRINT_TYPE <span style="color: #339933;">!=</span> PRINT_FILE_ONLY<span style="color: #009900;">&#41;</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span> <span style="color: #ff0000;">&quot;%s%c%s%c<span style="color: #000099; font-weight: bold;">\n</span> &quot;</span><span style="color: #339933;">,</span>buff<span style="color: #339933;">,</span>path_sep<span style="color: #339933;">,</span>entry<span style="color: #339933;">-&amp;</span>gt<span style="color: #339933;">;</span> d_name<span style="color: #339933;">,</span>path_sep<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&nbsp;
 <span style="color: #808080; font-style: italic;">/* Recurse at a new indent level */</span>
 <span style="color: #b1b100;">if</span><span style="color: #009900;">&#40;</span>g_DIR_RECURSE<span style="color: #339933;">==</span>DIR_RECURSE_YES<span style="color: #009900;">&#41;</span>
 printdir<span style="color: #009900;">&#40;</span>entry<span style="color: #339933;">-&amp;</span>gt<span style="color: #339933;">;</span> d_name<span style="color: #339933;">,</span>depth<span style="color: #339933;">+</span><span style="color: #0000dd;">4</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #009900;">&#125;</span><span style="color: #b1b100;">else</span><span style="color: #009900;">&#123;</span>
 <span style="color: #666666; font-style: italic;">//is a file</span>
 <span style="color: #b1b100;">if</span><span style="color: #009900;">&#40;</span>g_PRINT_TYPE <span style="color: #339933;">!=</span>PRINT_DIR_ONLY<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span> <span style="color: #ff0000;">&quot;%s%c%s<span style="color: #000099; font-weight: bold;">\n</span> &quot;</span><span style="color: #339933;">,</span>buff<span style="color: #339933;">,</span>path_sep<span style="color: #339933;">,</span>entry<span style="color: #339933;">-&amp;</span>gt<span style="color: #339933;">;</span> d_name<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #009900;">&#125;</span>
 <span style="color: #009900;">&#125;</span>
 <span style="color: #009900;">&#125;</span>
 chdir<span style="color: #009900;">&#40;</span> <span style="color: #ff0000;">&quot;..&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 closedir<span style="color: #009900;">&#40;</span>dp<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
<span style="color: #009900;">&#125;</span>
&nbsp;
<span style="color: #993333;">void</span> useage<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;====================================================================<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;Useage: lsdir<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot; list the full path of a dir's subdirs or files,not same as  <span style="color: #000099; font-weight: bold;">\&quot;</span>ls -R<span style="color: #000099; font-weight: bold;">\&quot;</span>. <span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot; -h,<span style="color: #000099; font-weight: bold;">\t</span>print this message.<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot; -d dirname,<span style="color: #000099; font-weight: bold;">\t</span>recursely print full path of files. <span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot; -D,<span style="color: #000099; font-weight: bold;">\t</span>print dirs only. <span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot; -F,<span style="color: #000099; font-weight: bold;">\t</span>print files only. <span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot; -A,<span style="color: #000099; font-weight: bold;">\t</span>print files and dirs(defult). <span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot; -R,<span style="color: #000099; font-weight: bold;">\t</span>print dir recurse(defult). <span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot; -r,<span style="color: #000099; font-weight: bold;">\t</span>only print current dir. <span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot; none argvs,<span style="color: #000099; font-weight: bold;">\t</span>print current path.<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;<span style="color: #000099; font-weight: bold;">\t</span><span style="color: #000099; font-weight: bold;">\t</span><span style="color: #000099; font-weight: bold;">\t</span><span style="color: #000099; font-weight: bold;">\t</span>---zhouchuan,2010.8.27.<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;====================================================================<span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
<span style="color: #009900;">&#125;</span>
&nbsp;
<span style="color: #993333;">int</span> main<span style="color: #009900;">&#40;</span><span style="color: #993333;">int</span> argc<span style="color: #339933;">,</span> <span style="color: #993333;">char</span><span style="color: #339933;">*</span> argv<span style="color: #009900;">&#91;</span><span style="color: #009900;">&#93;</span><span style="color: #009900;">&#41;</span>
<span style="color: #009900;">&#123;</span>
 <span style="color: #993333;">int</span> oc<span style="color: #339933;">;</span>                     <span style="color: #808080; font-style: italic;">/*选项字符 */</span>
 <span style="color: #993333;">char</span> <span style="color: #339933;">*</span>b_opt_arg<span style="color: #339933;">;</span>            <span style="color: #808080; font-style: italic;">/*选项参数字串 */</span>
 <span style="color: #993333;">char</span> <span style="color: #339933;">*</span>topdir<span style="color: #339933;">=</span>NULL<span style="color: #339933;">,</span> pwd<span style="color: #009900;">&#91;</span><span style="color: #0000dd;">2</span><span style="color: #009900;">&#93;</span><span style="color: #339933;">=</span> <span style="color: #ff0000;">&quot;.&quot;</span><span style="color: #339933;">;</span>
&nbsp;
 <span style="color: #b1b100;">while</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#40;</span>oc <span style="color: #339933;">=</span> getopt<span style="color: #009900;">&#40;</span>argc<span style="color: #339933;">,</span> argv<span style="color: #339933;">,</span> <span style="color: #ff0000;">&quot;hd:DFARr&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span> <span style="color: #339933;">!=</span> <span style="color: #339933;">-</span><span style="color: #0000dd;">1</span><span style="color: #009900;">&#41;</span>
 <span style="color: #009900;">&#123;</span>
 <span style="color: #b1b100;">switch</span><span style="color: #009900;">&#40;</span>oc<span style="color: #009900;">&#41;</span>
 <span style="color: #009900;">&#123;</span>
 <span style="color: #b1b100;">case</span> <span style="color: #ff0000;">'h'</span><span style="color: #339933;">:</span>
 <span style="color: #666666; font-style: italic;">//-h,则打印使用方法</span>
 useage<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #b1b100;">return</span> <span style="color: #0000dd;">0</span><span style="color: #339933;">;</span>
 <span style="color: #000000; font-weight: bold;">break</span><span style="color: #339933;">;</span>
 <span style="color: #b1b100;">case</span> <span style="color: #ff0000;">'D'</span><span style="color: #339933;">:</span>
 g_PRINT_TYPE <span style="color: #339933;">=</span>PRINT_DIR_ONLY <span style="color: #339933;">;</span>
 <span style="color: #000000; font-weight: bold;">break</span> <span style="color: #339933;">;</span>
 <span style="color: #b1b100;">case</span> <span style="color: #ff0000;">'F'</span><span style="color: #339933;">:</span>
 g_PRINT_TYPE <span style="color: #339933;">=</span>PRINT_FILE_ONLY <span style="color: #339933;">;</span>
 <span style="color: #000000; font-weight: bold;">break</span> <span style="color: #339933;">;</span>
 <span style="color: #b1b100;">case</span> <span style="color: #ff0000;">'A'</span><span style="color: #339933;">:</span>
 g_PRINT_TYPE <span style="color: #339933;">=</span>PRINT_FILE_AND_DIR <span style="color: #339933;">;</span>
 <span style="color: #000000; font-weight: bold;">break</span> <span style="color: #339933;">;</span>
 <span style="color: #b1b100;">case</span> <span style="color: #ff0000;">'R'</span><span style="color: #339933;">:</span>
 g_DIR_RECURSE <span style="color: #339933;">=</span> DIR_RECURSE_YES<span style="color: #339933;">;</span>
 <span style="color: #666666; font-style: italic;">//       printf(&quot; DIR_RECURSE_YES&quot;);</span>
 <span style="color: #000000; font-weight: bold;">break</span><span style="color: #339933;">;</span>
 <span style="color: #b1b100;">case</span> <span style="color: #ff0000;">'r'</span><span style="color: #339933;">:</span>
 g_DIR_RECURSE <span style="color: #339933;">=</span> DIR_RECURSE_NO<span style="color: #339933;">;</span>
 <span style="color: #666666; font-style: italic;">//    printf(&quot; DIR_RECURSE_NO&quot;);</span>
 <span style="color: #000000; font-weight: bold;">break</span><span style="color: #339933;">;</span>
 <span style="color: #b1b100;">case</span> <span style="color: #ff0000;">'d'</span><span style="color: #339933;">:</span>
 b_opt_arg <span style="color: #339933;">=</span> optarg<span style="color: #339933;">;</span>
 <span style="color: #666666; font-style: italic;">//      printf(&quot;dir %s\n&quot;, optarg);</span>
 topdir<span style="color: #339933;">=</span>optarg<span style="color: #339933;">;</span>
 <span style="color: #000000; font-weight: bold;">break</span><span style="color: #339933;">;</span>
 <span style="color: #009900;">&#125;</span>
 <span style="color: #009900;">&#125;</span>
 <span style="color: #b1b100;">if</span><span style="color: #009900;">&#40;</span>topdir<span style="color: #339933;">==</span>NULL<span style="color: #009900;">&#41;</span>
 <span style="color: #009900;">&#123;</span>
 <span style="color: #666666; font-style: italic;">//   printf(&quot;dir current&quot;);</span>
 topdir<span style="color: #339933;">=</span>pwd<span style="color: #339933;">;</span>
 <span style="color: #009900;">&#125;</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;Directory scan of <span style="color: #000099; font-weight: bold;">\&quot;</span>%s<span style="color: #000099; font-weight: bold;">\&quot;</span>:<span style="color: #000099; font-weight: bold;">\n</span> &quot;</span><span style="color: #339933;">,</span>topdir<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 printdir<span style="color: #009900;">&#40;</span>topdir<span style="color: #339933;">,</span><span style="color: #0000dd;">0</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #000066;">printf</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;===Done.<span style="color: #000099; font-weight: bold;">\n</span> &quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&nbsp;
 <span style="color: #b1b100;">return</span> <span style="color: #0000dd;">0</span><span style="color: #339933;">;</span>
<span style="color: #009900;">&#125;</span></pre></td></tr></table></div>

<p>在很多时候,我们可能需要得到一个目录下所有文件的全路径,以供后续计算.<br />
如要计算当前目录所有文件的md5值:</p>
<div>
<p>./lsdir -F|grep &#8221;/&#8221;|while read LINE;do md5sum $LINE;done;</p>
<p>源码: <a href="http://imzc.net/wp-content/uploads/2010/08/lsdir.zip">lsdir</a></p>
</div>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/20/feed/</wfw:commentRss>
		<slash:comments>296</slash:comments>
		</item>
		<item>
		<title>[转]编写可移植C/C++程序的要点</title>
		<link>http://imzc.net/archives/22/</link>
		<comments>http://imzc.net/archives/22/#comments</comments>
		<pubDate>Thu, 08 Oct 2009 14:44:00 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[C/C++]]></category>
		<category><![CDATA[c]]></category>

		<guid isPermaLink="false">http://imzc.net/?action=show&#038;id=109</guid>
		<description><![CDATA[转载时请注明出处和作者联系方式：http://blog.csdn.net/absurd 作者联系方式：Li X [...]]]></description>
			<content:encoded><![CDATA[<div>
<div id="art">
<div>转载时请注明出处和作者联系方式：<a href="http://blog.csdn.net/absurd">http://blog.csdn.net/absurd</a></div>
<div>作者联系方式：Li XianJing &lt;xianjimli at hotmail dot com&gt;</div>
<div>更新时间：2006-3-11</div>
<div>昨天看了05年的《程序员(精华本)》，里面有篇关于编写可移植的C++程序的文章，引起了我一丝兴趣，大致读了一下，有点启发。不过感觉作者是位学院派的人士，没有大型项目的移植经验，把移植想得太简单了，以为一个Adapter模式就搞定了所有的东西，太理想化了。</div>
<div>以前做过两年C++程序移植工作，从Win32平台移植到Linux平台。大约有上百万行C/C++代码，历时一年多。在开发Win32版本  时，已经强调了程序的可植性，无奈Win32团队里对Linux精通的人比较少，很多问题没有想到，直到后来移植工作开始时，才发现移植并非像想的那样简  单。</div>
<div>后来，我发现大家对移植工程师都比较轻视，不管是从工资待遇还是管理层的态度来看都是这样。他们往往认为，你们不过是把别人实现好的东西移植过   去罢了，你老老实实，按步就班去做就行了，根本不需要丝毫创意。事实并非如此，特别是对于大项目，其中遇到的问题和困难可谓一言难尽。比如前面提到的那个  项目，虽然过去好几年了，很多问题我仍然记忆犹新。</div>
<div>这里总结一些经验吧，这些经验，无一不是经过大量汗水换来的，有的引起的BUG甚至耗费数周时间才查出来。写出来，供类似的项目参考，不用再走这些弯路。</div>
<div>1.分层设计，隔离平台相关的代码。就像可测试性一样，可移植性也要从设计抓起。一般来说，最上层和最下层都不具有良好的可移植性。最上层是GUI，大多数GUI都不是跨平台的，如Win32 SDK和MFC。最下层是操作系统API，大多部分操作系统API都是专用的。</div>
<div>如果这两层的代码散布在整个软件中，那么这个软件的可植性将非常的差，这是不言自明的。那么如何避免这种情况呢？当然是分层设计了：</div>
<div>最底层采用Adapter模式，把不同操作系统的API封装成一套统一的接口。至于封装成类还是封装成函数，要看你采用的C还是C++写的程序   了。这看起来很简单，其实不尽然（看完整篇文章后你会明白的），它将耗去你大量的时间去编写代码，去测试它们。采用现存的程序库，是明智的做法，有很多这  样的库，比如，C库有glib（GNOME的基础类），C++库有ACE(ADAPTIVE Communication  Environment)等等，在开发第一个平台时就采用这些库，可以大大减少移植的工作量。</div>
<div>最上层采用MVC模型，分离界面表现与内部逻辑代码。把大部分代码放到内部逻辑里面，界面仅仅是显示和接收输入，即使要换一套GUI，工作量也   不大。这同时也是提高可测试性的手段之一，当然还有其它一些附加好处。所以即使你采用QT或者GTK+等跨平台的GUI设计软件界面，分离界面表现与内部  逻辑也是非常有用的。</div>
<div>若做到了以上两点，程序的可移植性基本上有保障了，其它的只是技术细节问题。</div>
<div>2.事先熟悉各目标平台，合理抽象底层功能。这一点是建立在分层设计之上的，大多数底层函数，像线程、同步机制和IPC机制等等，不同平台提供   的函数，几乎是一一对应的，封装这些函数很简单，实现Adapter的工作几乎只是体力活。然而，对于一些比较特殊的应用，如图形组件本身，就拿GTK+  来说吧，基于X  Window的功能和基于Win32的功能，两者差巨大，除了窗口、事件等基本概念外，几乎没有什么相同的，如果不事先了解各个平台的特性，在设计时就精  心考虑的话，抽象出来的抽口在另外一个平台几乎无法实现。</div>
<div>3.尽量使用标准C/C++函数。大多数平台都会实现POSIX(Portable Operating System  Interface)规定的函数，但这些函数较原生(Native)  函数来说，性能上的表现可能较次一些，用起来也不如原生函数方便。但是，最好不要贪图这种便宜而使用原生函数函数，否则搬起的石头最终会轧到自己的脚。比  如，文件操作就用fopen之类的函数，而不要用CreateFile之类的函数等。</div>
<div>4.尽量不要使用C/C++新标准里出现的特性。并不是所有的编译器都支持这些特性，像VC就不支持C99里面要求的可变参数的宏，VC对一些模板特性的支持也不全面。为了安全起见，这方面不要太激进了。</div>
<div>5.尽量不要使用C/C++标准里没有明确规定的特性。比如你有多个动态库，每个动态库都有全局对象，而且这些全局对象的构造还有依赖关系，那   你迟早会遇到麻烦的，这些全局对象构造的先后顺序在标准里是没有规定的。在一个平台上运行正确，在另外一个平台上可能莫明其妙的死机，最终还是要对程序作  大量修改。</div>
<div>6.尽量不要使用准标准函数。有些函数大多数平台上都有，它们使用得太广泛了，以至于大家都把它们当成标准了，比如atoi（把字符串转换成整  数）、strdup(克隆字符串)、alloca（在栈分配自动内存）等等。不怕一万，就怕万一，除非明白你在做什么，否则还是别碰它们为好。</div>
<div>7.注意标准函数的细节。也许你不相信，即使是标准函数，抛开内部实现不论，就其外在表现的差异也有时令人惊讶。这里略举几个例子：</div>
<div>l         int accept(int s, struct sockaddr *addr, socklen_t  *addrlen);addr/  addrlen本来是输出参数，如果是C++程序员，不管怎么样，你已经习惯于初始化所有的变量，不会有问题。如果是C程序员，就难说了，若没有初始化它  们，程序可能莫名其妙的crash，而你做梦也怀疑不到它头它。这在Win32下没问题，在Linux下才会出现。</div>
<div>l       <span style="color: #ff6600;"> int snprintf(char *str, size_t size, const char *format, &#8230;);第二个参数size，在Win32下不包括空字符在内，在Linux下包括空字符，这一个字符的差异，也可能让你耗上几个小时。</span></div>
<div>l         int stat(const char *file_name, struct stat  *buf);这个函数本身没有问题，问题出在结构stat上，st_ctime在Win32下代表创建(create)时间，在Linux下代表最后修改  (change)时间。</div>
<div>l         FILE *fopen(const char *path, const char *mode);在读取二进制文件，没有什么问题。在读取文本文件可要小心，Win32下自动预处理，读出来的内容与文件实际都长度不一样，在Linux则没有问题。</div>
<div>8.小心数据标准数据类型。不少人已经吃过int类型由16位转变成32位带来的苦头，这已经是陈年往事了，这里且不谈。你可知道char在有  的系统上是有符号的，在有的系统是无符号的吗？你可知道wchar_t在Win32下是16位的，在Linux  下是32位的吗？你可知道有符号的1bit的位域，取值是0和-1而不是0和1吗？这些貌合神离的东东，端的是神出鬼没，一不小心着了它的道。</div>
<div>9.最好不要使用平台独有的特性。比如Win32下DLL可以提供一个DllMain函数，在特定的时间，操作系统的Loader会自动调用这个函数。这类功能很好用，但最好不要用，目标平台可不能保证有这种功能。</div>
<div>10.最好不要使用编译器特有的特性。现代的编译器都做很人性化，考虑得很周到，一些功能用起非常方便。像在VC里，你要实现线程局部存储，你  都不调用TlsGetValue /Tls TlsSetValue之类的函数，在变量前加一个__declspec( thread  )就行了，然而尽管在pthread里有类似的功能，却不能按这种方式实现，所以无法移植到Linux下。同样gcc也有很多扩展，是在VC或者其它编译  器里所没有的。</div>
<div>11.注意平台的特性。比如:</div>
<div>l         在Win32下的DLL里面，除非明确指明为export的函数外，其它函数对外都是不可见的。而在Linux下，所有的非static的全局变量和函数，对外全部是可见的。这要特别小心，同名函数引起的问题，让你查上两天也不为过。</div>
<div>l         目录分隔符，在Win32下用’\\’，在Linux下用’/’。</div>
<div>l         文本文件换行符，在Win32下用’\r\n’，在Linux下用’\n’，在MacOS下用’\r’。</div>
<div>l         字节顺序（大端/小端），不同硬件平台的字节顺序可能不一样。</div>
<div>l         字节对齐，在有的平台(如x86）上，字节不对齐，无非速度慢一点，而有的平台（如arm）上，它完全用错误的方式去读取数据，而且不会给你一点提示。若出问题，可能让你一点头绪都没有。</div>
<div>12.最好清楚不同平台的资源限制。想必你还记得DOS下同时打开的文件个数限制在几十个的情形吧，如今操作系统的功能已经强大多了，但是并非  没有限制。比如Linux下的共享内存默认的最大值是4M。若你对目标平台常见的资源限制了然于胸，可能有很大的帮助，一些问题很容易定位。</div>
<div>可移植性的问题决不限于以上几种，一方面，即使以前遇到过的问题，部份已经忘记了。另外一方面，还有很多未知的问题，根本没有遇到过。这里算是抛砖引玉吧，请大家补充。</div>
</div>
<p><span style="color: #000099;"><strong>原文地址</strong></span> <a href="http://blog.csdn.net/absurd/archive/2006/03/11/622055.aspx" target="_blank">http://blog.csdn.net/absurd/archive/2006/03/11/622055.aspx</a></p>
</div>
<p>﻿</p>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/22/feed/</wfw:commentRss>
		<slash:comments>342</slash:comments>
		</item>
		<item>
		<title>C++部分内容练习(复习)</title>
		<link>http://imzc.net/archives/24/</link>
		<comments>http://imzc.net/archives/24/#comments</comments>
		<pubDate>Mon, 13 Jul 2009 13:50:00 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[C/C++]]></category>
		<category><![CDATA[c]]></category>

		<guid isPermaLink="false">http://imzc.net/?action=show&#038;id=98</guid>
		<description><![CDATA[练习部分有:const关键字,函数指针,内部类,初始化列表,

STL vector with iterator 和 for_each 算法.]]></description>
			<content:encoded><![CDATA[<p>练习部分有:const关键字,函数指针,内部类,初始化列表,</p>
<p>STL vector with iterator 和 for_each 算法.</p>
<p>直接看代码,注意看注释.</p>

<div class="wp_syntax"><table><tr><td class="line_numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
</pre></td><td class="code"><pre class="c" style="font-family:monospace;"><span style="color: #666666; font-style: italic;">//VC2005,dev-cpp 4.9.9.2(gcc)下编译通过.</span>
&nbsp;
﻿<span style="color: #666666; font-style: italic;">//main.cpp  </span>
 <span style="color: #339933;">#include&lt;iostream&gt;  </span>
 <span style="color: #339933;">#include &lt;string&gt;  </span>
 <span style="color: #339933;">#include &lt;vector&gt;  </span>
 <span style="color: #339933;">#include &lt;algorithm&gt;//for_each  </span>
&nbsp;
 using namespace std<span style="color: #339933;">;</span>  
&nbsp;
 <span style="color: #993333;">void</span> prints<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 <span style="color: #993333;">void</span> copy<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 <span style="color: #993333;">void</span> <span style="color: #009900;">&#40;</span><span style="color: #339933;">*</span>pFun<span style="color: #009900;">&#91;</span><span style="color: #009900;">&#93;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #339933;">=</span> <span style="color: #009900;">&#123;</span>prints<span style="color: #339933;">,</span> copy<span style="color: #009900;">&#125;</span><span style="color: #339933;">;</span><span style="color: #666666; font-style: italic;">//定义一个函数指针数组  </span>
&nbsp;
 <span style="color: #666666; font-style: italic;">//以下为for_each第三个参数的定义  </span>
 template<span style="color: #339933;">&lt;</span>class T<span style="color: #339933;">&gt;</span>  
 class mFun  
 <span style="color: #009900;">&#123;</span>  
 private<span style="color: #339933;">:</span>  
 T fa<span style="color: #339933;">;</span>  
 public<span style="color: #339933;">:</span>  
 mFun<span style="color: #009900;">&#40;</span><span style="color: #993333;">const</span> T <span style="color: #339933;">&amp;</span>name<span style="color: #009900;">&#41;</span><span style="color: #339933;">:</span>fa<span style="color: #009900;">&#40;</span>name<span style="color: #009900;">&#41;</span>  
 <span style="color: #009900;">&#123;</span> <span style="color: #009900;">&#125;</span>  
&nbsp;
 <span style="color: #993333;">void</span> operator<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#40;</span>T <span style="color: #339933;">&amp;</span>name<span style="color: #009900;">&#41;</span><span style="color: #993333;">const</span>  
 <span style="color: #009900;">&#123;</span>  
 name<span style="color: #339933;">*=</span>fa<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
 <span style="color: #009900;">&#125;</span><span style="color: #339933;">;</span>   
&nbsp;
 <span style="color: #666666; font-style: italic;">//以下为双向链表的定义</span>
 <span style="color: #666666; font-style: italic;">//暂时只实现了简单的加入和删除,主要是体现一个思想. </span>
 template<span style="color: #339933;">&lt;</span>class Type<span style="color: #339933;">&gt;</span>  
 class LIST  
 <span style="color: #009900;">&#123;</span>  
 public<span style="color: #339933;">:</span>  
 <span style="color: #666666; font-style: italic;">//无参数构造函数.  </span>
 LIST<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>  
 head <span style="color: #339933;">=</span> NULL<span style="color: #339933;">;</span>  
 tail <span style="color: #339933;">=</span>NULL<span style="color: #339933;">;</span>  
 count <span style="color: #339933;">=</span> <span style="color: #0000dd;">0</span><span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
&nbsp;
 <span style="color: #666666; font-style: italic;">//前插入式双向链表  </span>
 <span style="color: #993333;">void</span> Add<span style="color: #009900;">&#40;</span>Type d<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>  
 <span style="color: #666666; font-style: italic;">//注意处理空链表和有数据的链表时添加结点的问题  </span>
 <span style="color: #b1b100;">if</span><span style="color: #009900;">&#40;</span>head<span style="color: #339933;">==</span>NULL<span style="color: #009900;">&#41;</span>  
 <span style="color: #009900;">&#123;</span>  
 head <span style="color: #339933;">=</span> new _node<span style="color: #339933;">&lt;</span>Type<span style="color: #339933;">&gt;</span><span style="color: #009900;">&#40;</span>d<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 head<span style="color: #339933;">-&gt;</span>setNext<span style="color: #009900;">&#40;</span>head<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 head<span style="color: #339933;">-&gt;</span>setPrev<span style="color: #009900;">&#40;</span>head<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 tail <span style="color: #339933;">=</span> head<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span><span style="color: #b1b100;">else</span>  
 <span style="color: #009900;">&#123;</span>  
 _node<span style="color: #339933;">&lt;</span>Type<span style="color: #339933;">&gt;</span> <span style="color: #339933;">*</span> temp <span style="color: #339933;">=</span> new _node<span style="color: #339933;">&lt;</span>Type<span style="color: #339933;">&gt;</span><span style="color: #009900;">&#40;</span>d<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 temp<span style="color: #339933;">-&gt;</span>setPrev<span style="color: #009900;">&#40;</span>head<span style="color: #339933;">-&gt;</span>Prev<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 temp<span style="color: #339933;">-&gt;</span>setNext<span style="color: #009900;">&#40;</span>head<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 head<span style="color: #339933;">-&gt;</span>setPrev<span style="color: #009900;">&#40;</span>temp<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 tail<span style="color: #339933;">-&gt;</span>setNext<span style="color: #009900;">&#40;</span>temp<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 head <span style="color: #339933;">=</span> temp<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
 count<span style="color: #339933;">++;</span>  
 <span style="color: #009900;">&#125;</span>  
&nbsp;
 <span style="color: #666666; font-style: italic;">//删除数据为d的节点  </span>
 <span style="color: #993333;">void</span> Delete<span style="color: #009900;">&#40;</span>Type d<span style="color: #009900;">&#41;</span>  
 <span style="color: #009900;">&#123;</span>  
 <span style="color: #993333;">int</span> iPos<span style="color: #339933;">=</span>count<span style="color: #339933;">;</span>  
 <span style="color: #b1b100;">for</span><span style="color: #009900;">&#40;</span>_node<span style="color: #339933;">&lt;</span>Type<span style="color: #339933;">&gt;</span> <span style="color: #339933;">*</span> p <span style="color: #339933;">=</span> head<span style="color: #339933;">;</span> iPos<span style="color: #339933;">&gt;</span><span style="color: #0000dd;">0</span><span style="color: #339933;">;</span> p<span style="color: #339933;">=</span>p<span style="color: #339933;">-&gt;</span>Next<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span>  
 <span style="color: #009900;">&#123;</span>  
 <span style="color: #339933;">--</span>iPos<span style="color: #339933;">;</span>  
 <span style="color: #b1b100;">if</span><span style="color: #009900;">&#40;</span>p<span style="color: #339933;">-&gt;</span>Data<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">==</span>d<span style="color: #009900;">&#41;</span>  
 <span style="color: #009900;">&#123;</span>  
 _node<span style="color: #339933;">&lt;</span>Type<span style="color: #339933;">&gt;</span> <span style="color: #339933;">*</span> tn<span style="color: #339933;">=</span> p<span style="color: #339933;">-&gt;</span>Next<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 _node<span style="color: #339933;">&lt;</span>Type<span style="color: #339933;">&gt;</span> <span style="color: #339933;">*</span> tp<span style="color: #339933;">=</span> p<span style="color: #339933;">-&gt;</span>Prev<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 tn<span style="color: #339933;">-&gt;</span>setPrev<span style="color: #009900;">&#40;</span>tp<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 tp<span style="color: #339933;">-&gt;</span>setNext<span style="color: #009900;">&#40;</span>tn<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 <span style="color: #666666; font-style: italic;">//如果是头结点,则还应该将头结点head移位  </span>
 <span style="color: #b1b100;">if</span><span style="color: #009900;">&#40;</span>p<span style="color: #339933;">==</span>head<span style="color: #009900;">&#41;</span>  
 head<span style="color: #339933;">=</span>head<span style="color: #339933;">-&gt;</span>Next<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 count<span style="color: #339933;">--;</span>  
 delete p<span style="color: #339933;">;</span>  
 <span style="color: #b1b100;">return</span> <span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
 <span style="color: #009900;">&#125;</span><span style="color: #666666; font-style: italic;">//end for  </span>
&nbsp;
 <span style="color: #009900;">&#125;</span>  
&nbsp;
 <span style="color: #666666; font-style: italic;">//打印所有的节点  </span>
 <span style="color: #993333;">void</span> PrintAll<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #993333;">const</span>  
 <span style="color: #009900;">&#123;</span>  
 <span style="color: #b1b100;">if</span><span style="color: #009900;">&#40;</span>head<span style="color: #339933;">!=</span>NULL<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;all data:&quot;</span><span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>  
 <span style="color: #993333;">int</span> iPos<span style="color: #339933;">=</span>count<span style="color: #339933;">;</span>  
 <span style="color: #b1b100;">for</span><span style="color: #009900;">&#40;</span>_node<span style="color: #339933;">&lt;</span>Type<span style="color: #339933;">&gt;</span> <span style="color: #339933;">*</span> p <span style="color: #339933;">=</span> head<span style="color: #339933;">;</span>iPos<span style="color: #339933;">&gt;</span><span style="color: #0000dd;">0</span> <span style="color: #339933;">;</span>p<span style="color: #339933;">=</span> p<span style="color: #339933;">-&gt;</span>Next<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#41;</span>  
 <span style="color: #009900;">&#123;</span>  
 <span style="color: #339933;">--</span>iPos<span style="color: #339933;">;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span>hex<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;0x&quot;</span><span style="color: #339933;">&lt;&lt;</span>p<span style="color: #339933;">-&gt;</span>Prev<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;-&lt;&quot;</span><span style="color: #339933;">&lt;&lt;</span>p<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;&gt;-&quot;</span><span style="color: #339933;">&lt;&lt;</span>p<span style="color: #339933;">-&gt;</span>Next<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;:&quot;</span><span style="color: #339933;">&lt;&lt;</span>dec<span style="color: #339933;">&lt;&lt;</span>p<span style="color: #339933;">-&gt;</span>Data<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;-----end-----&quot;</span><span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
 <span style="color: #009900;">&#125;</span>  
 virtual ~LIST<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>  
 <span style="color: #b1b100;">if</span><span style="color: #009900;">&#40;</span>head<span style="color: #339933;">!=</span>NULL<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>  
 <span style="color: #993333;">int</span> iPos <span style="color: #339933;">=</span> count<span style="color: #339933;">;</span>  
 <span style="color: #b1b100;">for</span><span style="color: #009900;">&#40;</span>_node<span style="color: #339933;">&lt;</span>Type<span style="color: #339933;">&gt;</span> <span style="color: #339933;">*</span> p <span style="color: #339933;">=</span> head<span style="color: #339933;">;</span>iPos<span style="color: #339933;">&gt;</span><span style="color: #0000dd;">0</span><span style="color: #339933;">;</span><span style="color: #009900;">&#41;</span>  
 <span style="color: #009900;">&#123;</span>  
 <span style="color: #339933;">--</span>iPos<span style="color: #339933;">;</span>  
 _node<span style="color: #339933;">&lt;</span>Type<span style="color: #339933;">&gt;</span> <span style="color: #339933;">*</span> t <span style="color: #339933;">=</span> p<span style="color: #339933;">;</span>  
 p<span style="color: #339933;">=</span> p<span style="color: #339933;">-&gt;</span>Next<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 delete t<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
 head <span style="color: #339933;">=</span> NULL<span style="color: #339933;">;</span>  
 tail    <span style="color: #339933;">=</span> NULL<span style="color: #339933;">;</span>  
 count <span style="color: #339933;">=</span> <span style="color: #0000dd;">0</span><span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;list deleted!&quot;</span><span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
 protected<span style="color: #339933;">:</span>  
 private<span style="color: #339933;">:</span>  
 <span style="color: #666666; font-style: italic;">//内部类,由于_node仅仅在LIST类中使用,故无必要定义至外部;</span>
 <span style="color: #666666; font-style: italic;">//可以将_node所有成员设置为public,这样,便不必有成员函数了,</span>
 <span style="color: #666666; font-style: italic;">//在封装和暴露中间取个平衡点即可,不必死守规则.</span>
 template<span style="color: #339933;">&lt;</span>class T<span style="color: #339933;">&gt;</span>  
 class _node  
 <span style="color: #009900;">&#123;</span>  
 public<span style="color: #339933;">:</span>  
 _node<span style="color: #009900;">&#40;</span>T d<span style="color: #009900;">&#41;</span><span style="color: #339933;">:</span>_data<span style="color: #009900;">&#40;</span>d<span style="color: #009900;">&#41;</span>  
 <span style="color: #009900;">&#123;</span> 
 <span style="color: #666666; font-style: italic;">//通过初始化列表来初始化_data,这样效率高.</span>
 next <span style="color: #339933;">=</span> NULL<span style="color: #339933;">;</span>  
 prev <span style="color: #339933;">=</span> NULL<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
 T <span style="color: #339933;">&amp;</span> Data<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span>  
 <span style="color: #009900;">&#123;</span>  
 <span style="color: #b1b100;">return</span> _data<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
&nbsp;
 <span style="color: #993333;">void</span> setPrev<span style="color: #009900;">&#40;</span>_node <span style="color: #339933;">*</span> pr<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>  
 prev <span style="color: #339933;">=</span> pr<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
&nbsp;
 _node <span style="color: #339933;">*</span> Prev<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span>  
 <span style="color: #009900;">&#123;</span>  
 <span style="color: #b1b100;">return</span> prev<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
&nbsp;
&nbsp;
 <span style="color: #993333;">void</span> setNext<span style="color: #009900;">&#40;</span>_node <span style="color: #339933;">*</span> n<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>  
 next <span style="color: #339933;">=</span> n<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
&nbsp;
 _node <span style="color: #339933;">*</span> Next<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span>  
 <span style="color: #009900;">&#123;</span>  
 <span style="color: #b1b100;">return</span> next<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
&nbsp;
&nbsp;
 private<span style="color: #339933;">:</span>  
 _node <span style="color: #339933;">*</span> next<span style="color: #339933;">;</span>  
 _node <span style="color: #339933;">*</span> prev<span style="color: #339933;">;</span>  
 T _data<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span><span style="color: #339933;">;</span>  
 <span style="color: #993333;">unsigned</span> <span style="color: #993333;">int</span> count<span style="color: #339933;">;</span>  
 _node<span style="color: #339933;">&lt;</span>Type<span style="color: #339933;">&gt;</span> <span style="color: #339933;">*</span> head<span style="color: #339933;">;</span><span style="color: #666666; font-style: italic;">//头结点  </span>
 _node<span style="color: #339933;">&lt;</span>Type<span style="color: #339933;">&gt;</span> <span style="color: #339933;">*</span> tail<span style="color: #339933;">;</span><span style="color: #666666; font-style: italic;">//尾结点  </span>
 <span style="color: #009900;">&#125;</span><span style="color: #339933;">;</span>  
&nbsp;
 <span style="color: #993333;">int</span> main<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span>  
 <span style="color: #009900;">&#123;</span>     
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;----------------------------------------------------------------&quot;</span><span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>   
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;const关键字练习:&quot;</span><span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>   
 <span style="color: #993333;">const</span> <span style="color: #993333;">char</span> <span style="color: #339933;">*</span>p1  <span style="color: #339933;">=</span> <span style="color: #ff0000;">&quot;Hello,你好.&quot;</span><span style="color: #339933;">;</span><span style="color: #666666; font-style: italic;">//p1可以改变,字符串内容不可改变  </span>
 <span style="color: #993333;">char</span> <span style="color: #339933;">*</span> <span style="color: #993333;">const</span> p2 <span style="color: #339933;">=</span> <span style="color: #ff0000;">&quot;imzc&quot;</span><span style="color: #339933;">;</span><span style="color: #666666; font-style: italic;">//p2不可改变,但是字符串内容可以  </span>
 <span style="color: #993333;">const</span> <span style="color: #993333;">char</span> <span style="color: #339933;">*</span> <span style="color: #993333;">const</span> p3  <span style="color: #339933;">=</span> <span style="color: #ff0000;">&quot;this is p3.&quot;</span><span style="color: #339933;">;</span><span style="color: #666666; font-style: italic;">//都不可改变  </span>
 <span style="color: #993333;">char</span> <span style="color: #339933;">*</span> t <span style="color: #339933;">=</span> new <span style="color: #993333;">char</span><span style="color: #009900;">&#91;</span><span style="color: #0000dd;">30</span><span style="color: #009900;">&#93;</span><span style="color: #339933;">;</span> 
 <span style="color: #666666; font-style: italic;">//只有通过动态分配或者char p[30]这种形式的,指向的内容才可以改变 </span>
 strcpy<span style="color: #009900;">&#40;</span>t<span style="color: #339933;">,</span>p1<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 p1<span style="color: #339933;">++</span> <span style="color: #339933;">;</span>   
 t<span style="color: #009900;">&#91;</span><span style="color: #0000dd;">1</span><span style="color: #009900;">&#93;</span><span style="color: #339933;">=</span><span style="color: #ff0000;">'a'</span><span style="color: #339933;">;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;p1:&quot;</span><span style="color: #339933;">&lt;&lt;</span>p1<span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;p2:&quot;</span><span style="color: #339933;">&lt;&lt;</span>p2<span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;p3:&quot;</span><span style="color: #339933;">&lt;&lt;</span>p3<span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;t:&quot;</span><span style="color: #339933;">&lt;&lt;</span>t<span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>  
 delete <span style="color: #009900;">&#91;</span><span style="color: #009900;">&#93;</span> t<span style="color: #339933;">;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;----------------------------------------------------------------&quot;</span><span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;函数指针练习:&quot;</span><span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>   
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;&gt;&quot;</span><span style="color: #339933;">;</span>   
 <span style="color: #993333;">int</span> index<span style="color: #339933;">=</span><span style="color: #0000dd;">0</span><span style="color: #339933;">;</span>  
 cin <span style="color: #339933;">&gt;&gt;</span>index<span style="color: #339933;">;</span>  
 <span style="color: #b1b100;">do</span><span style="color: #009900;">&#123;</span>   
 <span style="color: #b1b100;">if</span><span style="color: #009900;">&#40;</span>index<span style="color: #339933;">&gt;</span><span style="color: #0000dd;">2</span><span style="color: #339933;">||</span>index<span style="color: #339933;">&lt;=</span><span style="color: #0000dd;">0</span><span style="color: #009900;">&#41;</span>  
 <span style="color: #009900;">&#123;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;Only has two function!1,prints;2,copy.&quot;</span><span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;&gt;&quot;</span><span style="color: #339933;">;</span>  
 cin<span style="color: #339933;">&gt;&gt;</span>index<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
 <span style="color: #b1b100;">else</span>  
 <span style="color: #009900;">&#123;</span>  
 pFun<span style="color: #009900;">&#91;</span>index<span style="color: #339933;">-</span><span style="color: #0000dd;">1</span><span style="color: #009900;">&#93;</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;return to main.&quot;</span><span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
 <span style="color: #009900;">&#125;</span> <span style="color: #b1b100;">while</span> <span style="color: #009900;">&#40;</span>index<span style="color: #339933;">&gt;</span><span style="color: #0000dd;">2</span><span style="color: #339933;">||</span>index<span style="color: #339933;">&lt;=</span><span style="color: #0000dd;">0</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;----------------------------------------------------------------&quot;</span><span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;双向链表练习:&quot;</span><span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>  
 LIST<span style="color: #339933;">&lt;</span>string<span style="color: #339933;">&gt;</span> li<span style="color: #339933;">;</span>  
 li.<span style="color: #202020;">Add</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;hello&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 li.<span style="color: #202020;">Add</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;see&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 li.<span style="color: #202020;">Add</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;yes&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 li.<span style="color: #202020;">Add</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;no&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 li.<span style="color: #202020;">Add</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;3qs&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 li.<span style="color: #202020;">PrintAll</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;Delete: <span style="color: #000099; font-weight: bold;">\&quot;</span>no<span style="color: #000099; font-weight: bold;">\&quot;</span>string.&quot;</span><span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>  
 li.<span style="color: #202020;">Delete</span><span style="color: #009900;">&#40;</span><span style="color: #ff0000;">&quot;no&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 li.<span style="color: #202020;">PrintAll</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;----------------------------------------------------------------&quot;</span><span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;for_each 实例:&quot;</span><span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>  
 vector<span style="color: #339933;">&lt;</span>int<span style="color: #339933;">&gt;</span> v<span style="color: #339933;">;</span>  
 v.<span style="color: #202020;">push_back</span><span style="color: #009900;">&#40;</span><span style="color: #0000dd;">12</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 <span style="color: #b1b100;">for</span> <span style="color: #009900;">&#40;</span><span style="color: #993333;">int</span> i<span style="color: #339933;">=</span><span style="color: #0000dd;">0</span><span style="color: #339933;">;</span>i<span style="color: #339933;">&lt;</span><span style="color: #0000dd;">100</span><span style="color: #339933;">;</span>i<span style="color: #339933;">+=</span><span style="color: #0000dd;">10</span><span style="color: #009900;">&#41;</span>  
 <span style="color: #009900;">&#123;</span>  
 v.<span style="color: #202020;">push_back</span><span style="color: #009900;">&#40;</span>i<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;原始向量:&quot;</span><span style="color: #339933;">;</span>  
 <span style="color: #b1b100;">for</span> <span style="color: #009900;">&#40;</span>vector<span style="color: #339933;">&lt;</span>int<span style="color: #339933;">&gt;::</span><span style="color: #202020;">iterator</span> v1<span style="color: #339933;">=</span>v.<span style="color: #202020;">begin</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>v1<span style="color: #339933;">!=</span>v.<span style="color: #202020;">end</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>v1<span style="color: #339933;">++</span><span style="color: #009900;">&#41;</span>  
 <span style="color: #009900;">&#123;</span>  
 cout<span style="color: #339933;">&lt;&lt;*</span><span style="color: #009900;">&#40;</span>v1<span style="color: #009900;">&#41;</span><span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot; &quot;</span><span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>  
 for_each <span style="color: #009900;">&#40;</span> v.<span style="color: #202020;">begin</span> <span style="color: #009900;">&#40;</span> <span style="color: #009900;">&#41;</span> <span style="color: #339933;">,</span> v.<span style="color: #202020;">end</span> <span style="color: #009900;">&#40;</span> <span style="color: #009900;">&#41;</span> <span style="color: #339933;">,</span> mFun<span style="color: #339933;">&lt;</span>int<span style="color: #339933;">&gt;</span> <span style="color: #009900;">&#40;</span> <span style="color: #0000dd;">12</span> <span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;for_each-&gt;add(-2):&quot;</span><span style="color: #339933;">;</span>  
 <span style="color: #b1b100;">for</span> <span style="color: #009900;">&#40;</span>vector<span style="color: #339933;">&lt;</span>int<span style="color: #339933;">&gt;::</span><span style="color: #202020;">iterator</span> v1<span style="color: #339933;">=</span>v.<span style="color: #202020;">begin</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>v1<span style="color: #339933;">!=</span>v.<span style="color: #202020;">end</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>v1<span style="color: #339933;">++</span><span style="color: #009900;">&#41;</span>  
 <span style="color: #009900;">&#123;</span>  
 cout<span style="color: #339933;">&lt;&lt;*</span><span style="color: #009900;">&#40;</span>v1<span style="color: #009900;">&#41;</span><span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot; &quot;</span><span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>   
&nbsp;
 <span style="color: #b1b100;">return</span> <span style="color: #0000dd;">0</span><span style="color: #339933;">;</span>  
&nbsp;
 <span style="color: #009900;">&#125;</span>  
&nbsp;
 <span style="color: #993333;">void</span> prints<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span>  
 <span style="color: #009900;">&#123;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;prints() function&quot;</span><span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span>  
&nbsp;
 <span style="color: #993333;">void</span> copy<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span>  
 <span style="color: #009900;">&#123;</span>  
 cout<span style="color: #339933;">&lt;&lt;</span><span style="color: #ff0000;">&quot;copy function&quot;</span><span style="color: #339933;">&lt;&lt;</span>endl<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span></pre></td></tr></table></div>

]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/24/feed/</wfw:commentRss>
		<slash:comments>279</slash:comments>
		</item>
		<item>
		<title>Makefile的编写</title>
		<link>http://imzc.net/archives/72/</link>
		<comments>http://imzc.net/archives/72/#comments</comments>
		<pubDate>Mon, 06 Jul 2009 22:52:00 +0000</pubDate>
		<dc:creator>imzc</dc:creator>
				<category><![CDATA[C/C++]]></category>
		<category><![CDATA[c]]></category>
		<category><![CDATA[makefile]]></category>

		<guid isPermaLink="false">http://imzc.net/?action=show&#038;id=97</guid>
		<description><![CDATA[1 &#160; 代码如下：﻿ //function.h   void sig_int(int);   //f [...]]]></description>
			<content:encoded><![CDATA[
<div class="wp_syntax"><table><tr><td class="line_numbers"><pre>1
</pre></td><td class="code"><pre class="c" style="font-family:monospace;">&nbsp;</pre></td></tr></table></div>

<p>代码如下：﻿</p>
<p>//function.h  <br />
 void sig_int(int);  </p>
<p> //function.c  <br />
 #include&lt;stdio.h&gt;  <br />
 void sig_int(int signo)<br />
 {  <br />
 printf(&#8220;In sig_int: SIGINT,%2d.\n&#8221;,signo);  <br />
 } </p>
<p> //test.c  <br />
 #include &lt;stdio.h&gt;  <br />
 #include&lt;stdlib.h&gt;  <br />
 #include &lt;signal.h&gt;  <br />
 #include &#8220;function.h&#8221;  </p>
<p> int main(void)  <br />
 {  <br />
 sigset_t newmask,oldmask,zeromask;  <br />
 if(signal(SIGINT,sig_int)==SIG_ERR) /*设置信号处理，调用信号处理函数*/  <br />
 perror(&#8220;signal error&#8221;);  </p>
<p> sigemptyset(&amp;zeromask); /*初始化zeromask信号集*/  <br />
 sigemptyset(&amp;newmask); /*初始化newmask信号集*/  </p>
<p> if(sigprocmask(SIG_BLOCK,&amp;newmask,&amp;oldmask)&lt;0) /*把信号集newmask设置为信号屏蔽集*/  <br />
 perror(&#8220;SIG_BLOCK error&#8221;);  </p>
<p> printf(&#8220;In critical region: SIGINT\n&#8221;);  </p>
<p> if(sigsuspend(&amp;zeromask)!=-1) /*用zeromask代替信号屏蔽集，然后阻塞信号，如果有信号来通过signal调用处理函数，最后返回*/  <br />
 perror(&#8220;sigsuspend error&#8221;);  </p>
<p> printf(&#8220;After return from sigsuspend: SIGINT\n&#8221;);  <br />
 sleep(5);   <br />
 exit(0);  </p>
<p> }  </p>
<p>以上是程序源码。<br />
 对应的makefile文件为:</p>
<blockquote><p>
OBJS = test.o function.o   <br />
 CC = gcc  <br />
 CFLAGS = -Wall -g     </p>
<p> main:$(OBJS)  <br />
 $(CC) $(OBJS) -o main  <br />
 #上方为[TAB]键，而不是空格！  <br />
 test.o:test.c  <br />
 $(CC) $(CFLAGS) -c test.c     </p>
<p> function.o:function.h function.c  <br />
 $(CC) $(CFLAGS) -c function.c       </p>
<p> clean:  <br />
 rm main *.o </p>
</blockquote>
<p>Makefile文件中，最关键的是代码标示的那里，必须是一个tab键，不能用空格代替。</p>
<hr size="2" />
 </p>
<p>makefile具体讲解请看：<a href="http://wiki.ubuntu.org.cn/index.php?title=%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D&amp;variant=zh-cn#makefile.E7.9A.84.E8.A7.84.E5.88.99">跟我一起写Makefile</a>.  摘自ubuntu wiki.</p>
<h1>makefile 介绍</h1>
<p>make命令执行时，需要一个 makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。</p>
<p>首先，我们用一个示例来说明makefile的书写规则。以便给大家一个感性认识。这个示例来源于gnu的make使用手册，在这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：</p>
<p>1）如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。</p>
<p>2）如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。</p>
<p>3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。</p>
<p>只要我们的makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。</p>
<p> </p>
<p><a id="makefile.E7.9A.84.E8.A7.84.E5.88.99" name="makefile.E7.9A.84.E8.A7.84.E5.88.99"></a></p>
<h2>makefile的规则</h2>
<p>在讲述这个makefile之前，还是让我们先来粗略地看一看makefile的规则。</p>
<pre>target ... : prerequisites ...
	command
	...
	...</pre>
<p>target可以是一个object file(目标文件)，也可以是一个执行文件，还可以是一个标签（label）。对于标签这种特性，在后续的“伪目标”章节中会有叙述。</p>
<p>prerequisites就是，要生成那个target所需要的文件或是目标。</p>
<p>command也就是make需要执行的命令。（任意的shell命令）</p>
<p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在  command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执  行。这就是makefile的规则。也就是makefile中最核心的内容。</p>
<p>说到底，makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是makefile的主线和核心，但要写好一个makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢道来。内容还多着呢。：）</p>
<p><a id=".E4.B8.80.E4.B8.AA.E7.A4.BA.E4.BE.8B" name=".E4.B8.80.E4.B8.AA.E7.A4.BA.E4.BE.8B"></a></p>
<h2>一个示例</h2>
<p>正如前面所说的，如果一个工程有3个头文件，和8个c文件，我们为了完成前面所述的那三个规则，我们的makefile应该是下面的这个样子的。</p>
<pre>edit : main.o kbd.o command.o display.o \
		insert.o search.o files.o utils.o
	cc -o edit main.o kbd.o command.o display.o \
		insert.o search.o files.o utils.o

main.o : main.c defs.h
	cc -c main.c
kbd.o : kbd.c defs.h command.h
	cc -c kbd.c
command.o : command.c defs.h command.h
	cc -c command.c
display.o : display.c defs.h buffer.h
	cc -c display.c
insert.o : insert.c defs.h buffer.h
	cc -c insert.c
search.o : search.c defs.h buffer.h
	cc -c search.c
files.o : files.c defs.h buffer.h command.h
	cc -c files.c
utils.o : utils.c defs.h
	cc -c utils.c
clean :
	rm edit main.o kbd.o command.o display.o \
		insert.o search.o files.o utils.o</pre>
<p>反斜杠（\）是换行符的意思。这样比较便于makefile的易读。我们可以把这个内容保存在名字为“makefile”或“Makefile”  的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下  “make clean”就可以了。</p>
<p>在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件  （prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件  edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p>
<p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个tab键作为开头。记住，make并不管命令是怎  么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件  的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p>
<p>这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像c语言中的lable一样，其冒号后什么也没有，那  么，make就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这  样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p>
<p><a id="make.E6.98.AF.E5.A6.82.E4.BD.95.E5.B7.A5.E4.BD.9C.E7.9A.84" name="make.E6.98.AF.E5.A6.82.E4.BD.95.E5.B7.A5.E4.BD.9C.E7.9A.84"></a></p>
<h2>make是如何工作的</h2>
<p>在默认的方式下，也就是我们只输入make命令。那么，</p>
<ol>
<li>make会在当前目录下找名字叫“Makefile”或“makefile”的文件。</li>
<li>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。</li>
<li>如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。</li>
<li>如果edit所依赖的.o文件也不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）</li>
<li>当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生成make的终极任务，也就是执行文件edit了。</li>
</ol>
<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后   被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，  如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p>
<p>通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译。</p>
<p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标  file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要  新，所以 edit也会被重新链接了（详见edit目标文件后定义的命令）。</p>
<p>而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。</p>
<p><a id="makefile.E4.B8.AD.E4.BD.BF.E7.94.A8.E5.8F.98.E9.87.8F" name="makefile.E4.B8.AD.E4.BD.BF.E7.94.A8.E5.8F.98.E9.87.8F"></a></p>
<h2>makefile中使用变量</h2>
<p>在上面的例子中，先让我们看看edit的规则：</p>
<pre>edit : main.o kbd.o command.o display.o \
		insert.o search.o files.o utils.o
	cc -o edit main.o kbd.o command.o display.o \
		insert.o search.o files.o utils.o</pre>
<p>我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一   个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个  需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符  串，理解成C语言中的宏可能会更好。</p>
<p>比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：</p>
<pre>objects = main.o kbd.o command.o display.o \
		insert.o search.o files.o utils.o</pre>
<p>于是，我们就可以很方便地在我们的makefile中以“$(objects)”的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：</p>
<pre>objects = main.o kbd.o command.o display.o \
		insert.o search.o files.o utils.o

edit : $(objects)
	cc -o edit $(objects)
main.o : main.c defs.h
	cc -c main.c
kbd.o : kbd.c defs.h command.h
	cc -c kbd.c
command.o : command.c defs.h command.h
	cc -c command.c
display.o : display.c defs.h buffer.h
	cc -c display.c
insert.o : insert.c defs.h buffer.h
	cc -c insert.c
search.o : search.c defs.h buffer.h
	cc -c search.c
files.o : files.c defs.h buffer.h command.h
	cc -c files.c
utils.o : utils.c defs.h
	cc -c utils.c
clean :
	rm edit $(objects)</pre>
<p>于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。</p>
<p>关于变量更多的话题，我会在后续给你一一道来。</p>
<p><a id=".E8.AE.A9make.E8.87.AA.E5.8A.A8.E6.8E.A8.E5.AF.BC" name=".E8.AE.A9make.E8.87.AA.E5.8A.A8.E6.8E.A8.E5.AF.BC"></a></p>
<h2>让make自动推导</h2>
<p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p>
<p>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么  whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile  再也不用写得这么复杂。我们的新makefile又出炉了。</p>
<pre>objects = main.o kbd.o command.o display.o \
		insert.o search.o files.o utils.o

edit : $(objects)
	cc -o edit $(objects)

main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h

.PHONY : clean
clean :
	rm edit $(objects)</pre>
<p>这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。</p>
<p>关于更为详细的“隐晦规则”和“伪目标文件”，我会在后续给你一一道来。</p>
<p><a id=".E5.8F.A6.E7.B1.BB.E9.A3.8E.E6.A0.BC.E7.9A.84makefile" name=".E5.8F.A6.E7.B1.BB.E9.A3.8E.E6.A0.BC.E7.9A.84makefile"></a></p>
<h2>另类风格的makefile</h2>
<p>既然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。</p>
<pre>objects = main.o kbd.o command.o display.o \
		insert.o search.o files.o utils.o

edit : $(objects)
	cc -o edit $(objects)

$(objects) : defs.h
kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h

.PHONY : clean
clean :
	rm edit $(objects)</pre>
<p>这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。</p>
<p><a id=".E6.B8.85.E7.A9.BA.E7.9B.AE.E6.A0.87.E6.96.87.E4.BB.B6.E7.9A.84.E8.A7.84.E5.88.99" name=".E6.B8.85.E7.A9.BA.E7.9B.AE.E6.A0.87.E6.96.87.E4.BB.B6.E7.9A.84.E8.A7.84.E5.88.99"></a></p>
<h2>清空目标文件的规则</h2>
<p>每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：</p>
<pre>clean:
	rm edit $(objects)</pre>
<p>更为稳健的做法是：</p>
<pre>.PHONY : clean
clean :
	-rm edit $(objects)</pre>
<p>前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续   做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来  都是放在文件的最后”。</p>
<p>上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。</p>
<p><a id="Makefile.E9.87.8C.E6.9C.89.E4.BB.80.E4.B9.88.EF.BC.9F" name="Makefile.E9.87.8C.E6.9C.89.E4.BB.80.E4.B9.88.EF.BC.9F"></a></p>
<h2>Makefile里有什么？</h2>
<p>Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。</p>
<ol>
<li>显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。</li>
<li>隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写Makefile，这是由make所支持的。</li>
<li>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</li>
<li>文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个  是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部  分中讲述。</li>
<li>注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“\#”。</li>
</ol>
<p>最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。</p>
<p><a id="Makefile.E7.9A.84.E6.96.87.E4.BB.B6.E5.90.8D" name="Makefile.E7.9A.84.E6.96.87.E4.BB.B6.E5.90.8D"></a></p>
<h2>Makefile的文件名</h2>
<p>默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找  到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用   “GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多  数的make都支持“makefile”和“Makefile”这两种默认文件名。</p>
<p>当然，你可以使用别的文件名来书写Makefile，比  如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“-  f”和“&#8211;file”参数，如：make -f Make.Linux或make &#8211;file Make.AIX。</p>
<p><a id=".E5.BC.95.E7.94.A8.E5.85.B6.E5.AE.83.E7.9A.84Makefile" name=".E5.BC.95.E7.94.A8.E5.85.B6.E5.AE.83.E7.9A.84Makefile"></a></p>
<h2>引用其它的Makefile</h2>
<p>在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：</p>
<pre>include &lt;filename&gt;;</pre>
<p>filename可以是当前操作系统Shell的文件模式（可以包含路径和通配符）</p>
<p>在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和&lt;filename&gt;;可以用一个或  多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其  包含了 e.mk和f.mk，那么，下面的语句：</p>
<pre>include foo.make *.mk $(bar)</pre>
<p>等价于：</p>
<pre>include foo.make a.mk b.mk c.mk e.mk f.mk</pre>
<p>make命令开始时，会找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一   样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p>
<ol>
<li>如果make执行时，有“-I”或“&#8211;include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。</li>
<li>如果目录&lt;prefix&gt;;/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。</li>
</ol>
<p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，  make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执  行，你可以在include前加一个减号“-”。如：</p>
<pre>-include &lt;filename&gt;;</pre>
<p>其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。</p>
<p><a id=".E7.8E.AF.E5.A2.83.E5.8F.98.E9.87.8F_MAKEFILES" name=".E7.8E.AF.E5.A2.83.E5.8F.98.E9.87.8F_MAKEFILES"></a></p>
<h2>环境变量 MAKEFILES</h2>
<p>如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它   的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的  文件发现错误，make也会不理。</p>
<p>但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影  响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。</p>
<p><a id="make.E7.9A.84.E5.B7.A5.E4.BD.9C.E6.96.B9.E5.BC.8F" name="make.E7.9A.84.E5.B7.A5.E4.BD.9C.E6.96.B9.E5.BC.8F"></a></p>
<h2>make的工作方式</h2>
<p>GNU的make工作时的执行步骤入下：（想来其它的make也是类似）</p>
<ol>
<li>读入所有的Makefile。</li>
<li>读入被include的其它Makefile。</li>
<li>初始化文件中的变量。</li>
<li>推导隐晦规则，并分析所有规则。</li>
<li>为所有的目标文件创建依赖关系链。</li>
<li>根据依赖关系，决定哪些目标要重新生成。</li>
<li>执行生成命令。</li>
</ol>
<p>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全  马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。</p>
<p>当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。</p>
<p><span style="font-size: medium;"> <a href="http://www.linuxsir.org/main/doc/gnumake/GNUmake_v3.80-zh_CN_html/make-03.html">Linuxsir的资料</a>:</span></p>
<p>Makefile 总述<br />
3.1 Makefile的内容</p>
<p>在一个完整的Makefile中，包含了5个东西：显式规则、隐含规则、变量定义、指示符和注释。关于“规则”、“变量”和“Makefile指示符”将在后续的章节进行详细的讨论。本章讨论的是一些基本概念。</p>
<p>²        显式规则：它描述了在何种情况下如何更新一个或者多个被称为目标的文件（Makefile的目标文件）。书写Makefile时需要明确地给出目标文件、 目标的依赖文件列表以及更新目标文件所需要的命令（有些规则没有命令，这样的规则只是纯粹的描述了文件之间的依赖关系）。</p>
<p>²       隐含规则：它是make根据一类目标文件（典型的是根据文件名的后缀）而自动推导出来的规则。make根据目标文件的名，自动产生目标的依赖文件并使用默认的命令来对目标进行更新（建立一个规则）。</p>
<p>²       变量定义：使用一个字符或字符串代表一段文本串，当定义了一个变量以后，Makefile后续在需要使用此文本串的地方，通过引用这个变量来实现对文本串的使用。第一章的例子中，我们就定义了一个变量“objects”来表示一个.o文件列表。</p>
<p>²       Makefile指示符：指示符指明在make程序读取makefile文件过程中所要执行的一个动作。其中包括：</p>
<p>²       读取一个文件，读取给定文件名的文件，将其内容作为makefile文件的一部分。</p>
<p>²       决定（通常是根据一个变量的得值）处理或者忽略Makefile中的某一特定部分。</p>
<p>²       定义一个多行变量。</p>
<p>²        注释：Makefile中“#”字符后的内容被作为是注释内容（和shell脚本一样）处理。如果此行的第一个非空字符为“#”，那么此行为注释行。注释 行的结尾如果存在反斜线（\），那么下一行也被作为注释行。一般在书写Makefile时推荐将注释作为一个独立的行，而不要和Makefile的有效行 放在一行中书写。当在Makefile中需要使用字符“#”时，可以使用反斜线加“#”（\#）来实现（对特殊字符“#”的转义），其表示将“#”作为一 字符而不是注释的开始标志。</p>
<p>需要注意的地方：</p>
<p>Makefile中第一个规则之后的所有以[Tab]字符开始的的行，make程序都会将其交给系统shell程序去解释执行。因此，以[Tab]字符开 始的注释行也会被交给shell来处理，此命令行是否需要被执行（shell执行或者忽略）是由系统shell程序来判决的。</p>
<p>另外，在使用指示符“define”定义一个多行的变量或者命令包时，其定义体（“define”和“endef”之间的内容）会被完整的展开到 Makefile中引用此变量的地方（包含定义体中的注释行）；make在引用此变量的地方对所有的定义体进行处理，决定是注释还是有效内容。 Makefile中变量的引用和C语言中的宏类似（但是其实质并不相同，后续将会详细讨论）。对一个变量引用的地方make所做的就是将这个变量根据定义 进行基于文本的展开，展开变量的过程不涉及到任何变量的具体含义和功能分析。<br />
3.2 makefile文件的命名</p>
<p>默认的情况下，make会在工作目录（执行make的目录）下按照文件名顺序寻找makefile文件读取并执行，查找的文件名顺序为：“GNUmakefile”、“makefile”、“Makefile”。</p>
<p>通常应该使用“makefile”或者“Makefile”作为一个makefile的文件名（我们推荐使用“Makefile”，首字母大写而比较显 著，一般在一个目录中和当前目录的一些重要文件（README,Chagelist等）靠近，在寻找时会比较容易的发现它）。而 “GNUmakefile”是我们不推荐使用的文件名，因为以此命名的文件只有“GNU  make”才可以识别，而其他版本的make程序只会在工作目录下“makefile”和“Makefile”这两个文件。</p>
<p>如果make程序在工作目录下无法找到以上三个文件中的任何一个，它将不读取任何其他文件作为解析对象。但是根据make隐含规则的特性，我们可以通过命 令行指定一个目标，如果当前目录下存在符合此目标的依赖文件，那么这个命令行所指定的目标将会被创建或者更新，参见注释。</p>
<p>当makefile文件的命名不是这三个任何一个时，需要通过make的“-f”或者“&#8211;file”选项来指定make读取的makefile文件。给 make指定makefile文件的格式为：“-f  NAME”或者“—file=NAME”，它指定文件“NAME”作为执行make时读取的makefile文件。也可以通过多个“-f”或者 “&#8211;file”选项来指定多个需要读取的makefile文件，多个makefile文件将会被按照指定的顺序进行链接并被make解析执行。当通过 “-f”或者“&#8211;file”指定make读取makefile的文件时，make就不再自动查找这三个标准命名的makefile文件。</p>
<p>注释：通过命令指定目标使用make的隐含规则：</p>
<p>当前目录下不存在以“GNUmakefile”、“makefile”、“Makefile”命名的任何文件，</p>
<p>1.        当前目录下存在一个源文件foo.c的，我们可以使用“make foo.o”来使用make的隐含规则自动生成foo.o。当执行“make foo.o”时。我们可以看到其执行的命令为：</p>
<p>cc –c –o foo.o foo.c</p>
<p>之后，foo.o将会被创建或者更新。</p>
<p>2.        如果当前目录下没有foo.c文件时，就是make对.o文件目标的隐含规则中依赖文件不存在。如果使用命令“make foo.o”时，将回到到如下提示：</p>
<p>make: *** No rule to make target ‘foo.o’. Stop.</p>
<p>3.        如果直接使用命令“make”时，得到的提示信息如下：</p>
<p>make: *** No targets specified and no makefile found. Stop.</p>
<p>3.3 包含其它makefile文件</p>
<p>本节我们讨论如何在一个Makefile中包含其它的makefile文件。Makefile中包含其它文件所需要使用的关键字是“include”，和c语言对头文件的包含方式一致。</p>
<p>“include”指示符告诉make暂停读取当前的Makefile，而转去读取“include”指定的一个或者多个文件，完成以后再继续当前Makefile的读取。Makefile中指示符“include”书写在独立的一行，其形式如下：</p>
<p>include FILENAMES&#8230;</p>
<p>FILENAMES是shell所支持的文件名（可以使用通配符）。</p>
<p>指示符“include”所在的行可以一个或者多个空格（make程序在处理时将忽略这些空格）开始，切忌不能以[Tab]字符开始（如果一行以 [Tab]字符开始make程序将此行作为一个命令行来处理）。指示符“include”和文件名之间、多个文件之间使用空格或者[Tab]键隔开。行尾 的空白字符在处理时被忽略。使用指示符包含进来的Makefile中，如果存在变量或者函数的引用。它们将会在包含它们的Makefile中被展开（详细 可参考 第六章 Makefile中的变量）。</p>
<p>来看一个例子，存在三个.mk文件a.mk、b.mk、c.mk，“$(bar)”被扩展为“bish bash”。则</p>
<p>include foo *.mk $(bar)</p>
<p>等价于</p>
<p>include foo a.mk b.mk c.mk bish bash</p>
<p>之前已经提到过make程序在处理指示符include时，将暂停对当前使用指示符“include”的makefile文件的读取，而转去依此读取由 “include”指示符指定的文件列表。直到完成所有这些文件以后再回过头继续读取指示符“include”所在的makefile文件。</p>
<p>通常指示符“include”用在以下场合：</p>
<p>1.         有多个不同的程序，由不同目录下的几个独立的Makefile来描述其重建规则。它们需要使用一组通用的变量定义或者模式规则。通用的做法是将这些共同使 用的变量或者模式规则定义在一个文件中（没有具体的文件命名限制），在需要使用的Makefile中使用指示符“include”来包含此文件。</p>
<p>2.         当根据源文件自动产生依赖文件时；我们可以将自动产生的依赖关系保存在另外一个文件中，主Makefile使用指示符“include”包含这些文件。这 样的做法比直接在主Makefile中追加依赖文件的方法要明智的多。其它版本的make已经使用这种方式来处理。</p>
<p>如果指示符“include”指定的文件不是以斜线开始（绝对路径，如/usr/src/Makefile&#8230;），而且当前目录下也不存在此文 件；make将根据文件名试图在以下几个目录下查找：首先，查找使用命令行选项“-I”或者“&#8211;include-dir”指定的目录，如果找到指定的文 件，则使用这个文件；否则继续依此搜索以下几个目录（如果其存在）：“/usr/gnu/include”、“/usr/local/include”和 “/usr/include”。</p>
<p>当在这些目录下都没有找到“include”指定的文件时，make将会提示一个包含文件未找到的告警提示，但是不会立刻退出。而是继续处理 Makefile的后续内容。当完成读取整个Makefile后，make将试图使用规则来创建通过指示符“include”指定的但未找到的文件，当不 能创建它时（没有创建这个文件的规则），make将提示致命错误并退出。会输出类似如下错误提示：</p>
<p>Makefile:错误的行数：未找到文件名：提示信息（No such file or directory）</p>
<p>Make： *** No rule to make target ‘&lt;filename&gt;’. Stop</p>
<p>通常我们在Makefile中可使用“-include”来代替“include”，来忽略由于包含文件不存在或者无法创建时的错误提示（“-”的意思是告诉make，忽略此操作的错误。make继续执行）。像下边那样：</p>
<p>-include FILENAMES&#8230;</p>
<p>使用这种方式时，当所要包含的文件不存在时不会有错误提示、make也不会退出；除此之外，和第一种方式效果相同。以下是这两种方式的比较：</p>
<p>使用“include FILENAMES&#8230;”，make程序处理时，如果“FILENAMES”列表中的任何一个文件不能正常读取而且不存在一个创建此文件的规则时make程序将会提示错误并退出。</p>
<p>使用“-include  FILENAMES&#8230;”的情况是，当所包含的文件不存在或者不存在一个规则去创建它，make程序会继续执行，只有真正由于不能正确完成终极目标的重 建时（某些必需的目标无法在当前已读取的makefile文件内容中找到正确的重建规则），才会提示致命错误并退出。<br />
为了和其它的make程序进行兼容。也可以使用“sinclude”来代替“-include”（GNU所支持的方式）。<br />
3.4  变量 MAKEFILES</p>
<p>如果在当前环境定义了一个“MAKEFILES”环境变量，make执行时首先将此变量的值作为需要读入的Makefile文件，多个文件之间使用空格分 开。类似使用指示符“include”包含其它Makefile文件一样，如果文件名非绝对路径而且当前目录也不存在此文件，make会在一些默认的目录 去寻找。它和使用“include”的区别：</p>
<p>1.         环境变量指定的makefile文件中的“目标”不会被作为make执行的“终极目标”。就是说，这些文件中所定义规则的目标，make不会将其作为“终 极目标”来看待。如果在make的工作目录下没有一个名为“Makefile”、“makefile”或者“GNUmakefile”的文件，make同 样会提示“make: *** No targets specified and no makefile found.  Stop.”；而在make的工作目录下存在这样一个文件（“Makefile”、“makefile”或者“GNUmakefile”），那么make 执行时的“终极目标”就是当前目录下这个文件中所定义的“终极目标”。</p>
<p>2.        环境变量所定义的文件列表，在执行make时，如果不能找到其中某一个文件（不存在或者无法创建）。make不会提示错误，也不退出。就是说环境变量“MAKEFILES”定义的包含文件是否存在不会导致make错误（这是比较隐蔽的地方）。</p>
<p>3.         make在执行时，首先读取的是环境变量“MAKEFILES”所指定的文件列表，之后才是工作目录下的makefile文件，“include”所指定 的文件是在make发现此关键字的时、暂停正在读取的文件而转去读取“include”所指定的文件。</p>
<p>变量“MAKEFILES”主要用在“make”的递归调用过程中的的通信。实际应用中很少设置此变量。因为一旦设置了此变量，在多级make调用时；由 于每一级make都会读取“MAKEFILES”变量所指定的文件，将导致执行出现混乱（这可能不是你想看到的执行结果）。不过，我们可以使用此环境变量 来指定一个定义了通用“隐含规则”和变量的文件，比如设置默认搜索路径；通过这种方式设置的“隐含规则”和定义的变量可以被任何make进程使用（有点象 C语言中的全局变量）。</p>
<p>也有人想让login程序自动的在自己的工作环境中设置此环境变量，编写的Makefile建立在此环境变量的基础上。此想法可以肯定地说不是一个好主 意。规劝大家千万不要这么干，否则你所编写的Makefile在其人的工作环境中肯定不能正常工作。因为别人的工作环境中可能没有设置相同的环境变量 “MAKEFILES”。<br />
推荐的做法实：在需要包含其它makefile文件时使用指示符“include”来实现。<br />
3.5 变量 MAKEFILE_LIST</p>
<p>make程序在读取多个makefile文件时，包括由环境变量“MAKEFILES”指定、命令行指、当前工作下的默认的以及使用指示符 “include”指定包含的，在对这些文件进行解析执行之前make读取的文件名将会被自动依次追加到变量“MAKEFILE_LIST”的定义域中。</p>
<p>这样我们就可以通过测试此变量的最后一个字来获取当前make程序正在处理的makefile文件名。具体地说就是在一个makefile文件中如果使用 指示符“include”包含另外一个文件之后，变量“MAKEFILE_LIST”的最后一个字只可能是指示符“include”指定所要包含的那个文 件的名字。一个makefile的内容如下：</p>
<p>name1 := $(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))</p>
<p>include inc.mk</p>
<p>name2 := $(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))</p>
<p>all:</p>
<p>@echo name1 = $(name1)</p>
<p>@echo name2 = $(name2)</p>
<p>执行make，则看到的将是如下的结果：</p>
<p>name1 = Makefile</p>
<p>name2 = inc.mk<br />
此例子中涉及到了make的函数的和变量定义的方式，这些将在后续的章节中有详细的讲述。<br />
3.6 其他特殊变量</p>
<p>GNU  make支持一个特殊的变量，此变量不能通过任何途经给它赋值。它被展开为一个特定的值。一个重要的特殊的变量是“.VARIABLES”。它被展开以后 是此引用点之前、makefile文件中所定义的所有全局变量列表。包括：空变量（未赋值的变量）和make的内嵌变量，但不包含目标指定的变量，目标指 定变量值在特定目标的上下文有效。<br />
3.7 makefile文件的重建</p>
<p>Makefile可由其它文件生成，例如RCS或SCCS文件。如果Makefile由其它文件重建，那么在make在开始解析这个Makefile时需要重新读取更新后的Makefile、而不是之前的Makefile。make的处理过程是这样的：</p>
<p>make在读入所有makefile文件之后，首先将所读取的每个makefile作为一个目标，寻找更新它们的规则。如果存在一个更新某一个 makefile文件明确规则或者隐含规则，就去更新对应的makefile文件。完成对所有的makefile文件的更新之后，如果之前所读取任何一个 makefile文件被更新，那么make就清除本次执行的状态重新读取一遍所有的makefile文件（此过程中，同样在读取完成以后也会去试图更新所 有的已经读取的makefile文件，但是一般这些文件不会再次被重建，因为它们在时间戳上已经是最新的）。读取完成以后再开始解析已经读取的 makefile文件并开始执行必要的动作。</p>
<p>实际应用中，我们会明确给出makefile文件，而并不需要来由make自动重建它们。但是make在每一次执行时总会自动地试图重建那些已经存在的 makefile文件，如果需要处于效率考虑，可以采用一些办法来避免make在执行过程时查找重建makefile的隐含规则。例如我们可以书写一个明 确的规则，以makefile文件作为目标，规则的命令定义为空。</p>
<p>Makefile规则中，如果使用一个没有依赖只有命令行的双冒号规则去更新一个文件，那么每次执行make时，此规则的目标文件将会被无条件的更新（此 规则定义的命令会被无条件执行）。如果这样一个规则的目标是makefile文件，那么执行make时，这个makefile文件（双冒号规则的目标）就 会被无条件更新，而使得make的执行陷入到一个死循环（此makefile文件被不断的更新、重新读取、更新再重新读取的过程）。为了防止这种情况的发 生，make在遇到一个目标是makefile文件的双冒号规则时，将忽略对这个规则的执行（其中包括了使用“MAKEFILES”指定、命令行选项指 定、指示符“include”指定的需要make读取的所有makefile文件中定义的这一类双冒号规则）。</p>
<p>执行make时，如果没有使用“-f（&#8211;file）”选项指定一个文件，make程序将读取缺省的文件。和使用“-f（&#8211;file）”选项不 同，make无法确定工作目录下是否存在缺省名称的makefile文件。如果缺省makefile文件不存在，但可以通过一个规则来创建它（此规则是隐 含规则），则会自动创建缺省makefile文件，之后重新读取它并开始执行。</p>
<p>因此，如果在当前目录下不存在一个缺省的makefile文件，make将会按照搜索makefile文件的名称顺序去试图创建它，直到创建成功或者超越 其缺省的命名顺序。需要明确的一点是：执行make时，如果不能成功地创建缺省的makefile文件，并不一定会导致错误。一个存在（缺省命名的或者可 被创建的）的makefile文件并不是make正确运行的前提（关于这一点大家会在后续的阅读过程中体会到）。</p>
<p>当使用“-t（&#8211;touch）”选项来更新Makefile的目标文件（更新规则目标文件的时间戳）时，对于哪些是makefile文件的目标是无效 的，这些目标文件（makefile文件）的时间戳并不会被更新。就是说即使在执行make时使用了选项“-t”，那些目标是makefile文件的规则 同样也会被执行（重建这些makefile文件，而其它的规则不会被执行，make只是简单的更新规则目标文件的时间戳）；类似还有选项“-q（— question）”和“-n（—just-print）  ”，这主要是因为一个过时的makefile文件对其它目标的重建规则在当前看来可能是错误的。</p>
<p>正因为如此，执行命令“make –f mfile –n  foo”首先会试图重建“mfile文件”、并重新读取它，之后会打印出更新目标“foo”所要执行的命令（但不会真正的执行这些命令）。在这种情况时， 如果不希望重建makefile文件。我们需要在执行make时，在命令行中将这个makefile文件作为一个最终目标，这样选项“–t”和其它的选项 就对这个makefile文件目标有效，防止执行这个makefile作为目标的规则（如果是“-t”参数，则是简单的更新这个makefile文件的时 间戳）。同样，命令“make –f mfile –n mfile  foo”会读取文件“mfile”，打印出重建文件“mfile”的命令、重建“foo”的命令而实际不执行任何命令。并且所打印的用于更新“foo”目 标的命令是选项“-f”指定的、没有被重建的“mfile”文件中所定义的命令。<br />
3.8 重载另外一个makefile</p>
<p>有些情况下，存在两个比较类似的makefile文件。其中一个（makefile-A）需要使用另外一个（makefile-B）中所定义的变量和规 则。通常我们会想到在“makefile-A”中使用指示符“include”包含“mkaefile-B”来达到目的。但使用这种方式，如果在两个 makefile文件中存在相同目标，而在不同的文件中其描述规则使用不同的命令。这样，相同的目标文件就同时存在两个不同的规则命令，这是 makefile所不允许的。遇到这种情况，使用指示符“include”显然是行不通的。GNU  make提供另外一种途径来实现此目的。具体的做法如下：</p>
<p>在需要包含的makefile文件（makefile-A）中，定义一个称之为“所有匹配模式”的规则，它用来述那些在“makefile-A”中没有给 出明确创建规则的目标的重建规则。就是说，如果在当前makefile文件中不能找到重建一个目标的规则时，就使用“所有匹配模式”所在的规则来重建这个 目标。</p>
<p>看一个例子，如果存在一个命名为“Makefile”的makefile文件，其中描述目标“foo”的规则和其他的一些规，我们也可以书写一个内容如下命名为“GNUmakefile”的文件。</p>
<p>#sample GNUmakefile</p>
<p>foo:</p>
<p>frobnicate &gt; foo</p>
<p>%: force</p>
<p>@$(MAKE) -f Makefile $@</p>
<p>force: ;</p>
<p>执行命令“make  foo”，make将使用工作目录下命名为“GNUmakefile”的文件并执行目标“foo”所在的规则，创建目标“foo”的命令 是：“frobnicate &gt; foo”。如果执行另外一个命令“make  bar”，因为在“GUNmakefile”中没有此目标的更新规则。make将使用“所有匹配模式”规则，执行命令“$(MAKE) -f  Makefile bar”。如果文件“Makefile”中存在此目标更新规则的定义，那么这个规则会被执行。此过程同样适用于其它  “GNUmakefile”中没有给出的目标更新规则。此方式的灵活之处在于：如果在“Makefile”文件中存在同样一一个目标“foo”的重建规 则，由于make执行时首先读取文件“GUNmakefile”并在其中能够找到目标“foo”的重建规则，所以make就不会去执行这个“所有模式匹配 规则”（上例中目标“%”所在的规则）。这样就避免了使用指示符“include”包含一个makefile文件时所带来的目标规则的重复定义问题。<br />
此种方式，模式规则的模式只使用了单独的“%”（我们称他为“所有模式匹配规则”），它可以匹配任何一个目标；它的依赖是“force”，保证了即使目标 文件已经存在也会执行这个规则（文件已存在时，需要根据它的依赖文件的修改情况决定是否需要重建这个目标文件）；“force”规则中使用空命令是为了防 止make程序试图寻找一个规则去创建目标“force”时，又使用了模式规则“%: force”而陷入无限循环。<br />
3.9 make如何解析makefile文件</p>
<p>GUN make的执行过程分为两个阶段。</p>
<p>第一阶段：读取所有的makefile文件（包括“MAKIFILES”变量指定的、指示符“include”指定的、以及命令行选项 “-f(&#8211;file)”指定的makefile文件），内建所有的变量、明确规则和隐含规则，并建立所有目标和依赖之间的依赖关系结构链表。</p>
<p>在第二阶段：根据第一阶段已经建立的依赖关系结构链表决定哪些目标需要更新，并使用对应的规则来重建这些目标。</p>
<p>理解make执行过程的两个阶段是很重要的。它能帮助我们更深入的了解执行过程中变量以及函数是如何被展开的。变量和函数的展开问题是书写 Makefile时容易犯错和引起大家迷惑的地方之一。本节将对这些不同的结构的展开阶段进行简单的总结（明确变量和函数的展开阶段，对正确的使用变量非 常有帮助）。首先，明确以下基本的概念；在make执行的第一阶段中如果变量和函数被展开，那么称此展开是“立即”的，此时所有的变量和函数被展开在需要 构建的结构链表的对应规则中（此规则在建立链表是需要使用）。其他的展开称之为“延后”的。这些变量和函数不会被“立即”展开，而是直到后续某些规则须要 使用时或者在make处理的第二阶段它们才会被展开。<br />
可能现在讲述的这些还不能完全理解。不过没有关系，通过后续章节内容的学习，我们会一步一步的熟悉make的执行过程。学习过程中可以回过头来参考本节的内容。相信在看完本书之后，会对make的整个过程有全面深入的理解<br />
3.9.1 变量取值</p>
<p>变量定义解析的规则如下：</p>
<p>IMMEDIATE = DEFERRED</p>
<p>IMMEDIATE ?= DEFERRED</p>
<p>IMMEDIATE := IMMEDIATE</p>
<p>IMMEDIATE += DEFERRED or IMMEDIATE</p>
<p>define IMMEDIATE</p>
<p>DEFERRED</p>
<p>Endef</p>
<p>当变量使用追加符（+=）时，如果此前这个变量是一个简单变量（使用 :=定义的）则认为它是立即展开的，其它情况时都被认为是“延后”展开的变量。<br />
3.9.2 条件语句</p>
<p>所有使用到条件语句在产生分支的地方，make程序会根据预设条件将正确地分支展开。就是说条件分支的展开是“立即”的。其中包括：“ifdef”、“ifeq”、“ifndef”和“ifneq”所确定的所有分支命令。<br />
3.9.3 规则的定义</p>
<p>所有的规则在make执行时，都按照如下的模式展开：</p>
<p>IMMEDIATE : IMMEDIATE ; DEFERRED</p>
<p>DEFERRED</p>
<p>其中，规则中目标和依赖如果引用其他的变量，则被立即展开。而规则的命令行中的变量引用会被延后展开。此模板适合所有的规则，包括明确规则、模式规则、后缀规则、静态模式规则。<br />
3.10 总结</p>
<p>make的执行过程如下：</p>
<p>1.        依次读取变量“MAKEFILES”定义的makefile文件列表</p>
<p>2.        读取工作目录下的makefile文件（根据命名的查找顺序“GNUmakefile”，“makefile”，“Makefile”，首先找到那个就读取那个）</p>
<p>3.        依次读取工作目录makefile文件中使用指示符“include”包含的文件</p>
<p>4.        查找重建所有已读取的makefile文件的规则（如果存在一个目标是当前读取的某一个makefile文件，则执行此规则重建此makefile文件，完成以后从第一步开始重新执行）</p>
<p>5.        初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支</p>
<p>6.        根据“终极目标”以及其他目标的依赖关系建立依赖关系链表</p>
<p>7.        执行除“终极目标”以外的所有的目标的规则（规则中如果依赖文件中任一个文件的时间戳比目标文件新，则使用规则所定义的命令重建目标文件）</p>
<p>8.        执行“终极目标”所在的规则</p>
<p>说明：</p>
<p>执行一个规则的过程是这样的：</p>
<p>对于一个存在的规则（明确规则和隐含规则）首先，make程序将比较目标文件和所有的依赖文件的时间戳。如果目标的时间戳比所有依赖文件的时间戳更新（依 赖文件在上一次执行make之后没有被修改），那么什么也不做。否则（依赖文件中的某一个或者全部在上一次执行make后已经被修改过），规则所定义的重 建目标的命令将会被执行。这就是make工作的基础，也是其执行规制所定义命令的依据。（后续讨论规则时将会对此详细地说明）</p>
]]></content:encoded>
			<wfw:commentRss>http://imzc.net/archives/72/feed/</wfw:commentRss>
		<slash:comments>302</slash:comments>
		</item>
	</channel>
</rss>
